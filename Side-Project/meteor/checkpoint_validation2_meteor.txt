===== 0 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterU0=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:q1.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 3 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 4 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(c8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri9=(Letter)other;returnx5.compareTo(i9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]C5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:C5)letter.compareTo(letter);for(Letterletter:C5)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 5 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 6 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 7 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.R3=R3this.E7=E7<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 8 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 9 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 10 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(y.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri4=(Letter)other;returnz5.compareTo(i4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]h7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:h7)letter.compareTo(letter);for(Letterletter:h7)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 11 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.I=I;this.b3=b3;this.O4=O4;重複定義只需要returnh4=I*b3*O4;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 12 =====
=====標準答案=====<BOM>按順序應為C7,m,z8。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 13 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 14 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如p1.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 15 =====
=====標準答案=====<BOM>keeper變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperK1=newKeeper(...);PetP1=newPet(...,K1);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringpid,Stringname,Stringtype,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetP1=newPet(pid,name,type,K1);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 16 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerc6=newScanner();intI6=c6.nextInt();//讀取數值c6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為s9[N0]，若寫成s9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 17 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 18 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入W.D2=2;W.o5=2;W.s0=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleD2=kb.nextDouble();doubleo5=kb.nextDouble();doubles0=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 19 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 20 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 21 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 22 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 23 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 24 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 25 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 26 =====
=====標準答案=====<BOM>Envelop第10行m.N0在呼叫m物件中的物件資料時,應呼叫getSender()來回傳returnN0Envelop第11行的m.v0/m.Y7與上述例子相同<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 27 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]F5={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 28 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 29 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intm8){...returnm8;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubler9=X(G5);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 30 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 31 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 32 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=o8.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 33 =====
=====標準答案=====<BOM>按順序應為i2,Z0,n5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 34 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 35 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 36 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 37 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 38 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 39 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerD1=newScanner();intp=D1.nextInt();//讀取數值D1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 40 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 41 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=d0.nextInt();doubleB8=d0.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerd0=newScanner();inta5=d0.nextInt();//讀取數值d0.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 42 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 43 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 44 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]t5){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 45 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.B3;}publicStringgetTitle(){returnthis.N8;}//可取得X7publicStringgetReceiver(){returnthis.X7;}//可取得D7publicStringgetDate(){returnthis.D7;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 46 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 47 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 48 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 49 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 50 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringm6,StringR5,Strings0,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 51 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 52 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 53 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，g3.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 54 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 55 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 56 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 57 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.T6=T6this.Q3=Q3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 58 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 59 =====
=====標準答案=====<BOM>StringE9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]E9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]d1){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 60 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 61 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的T5物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 62 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.k=kthis.X5=X5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 63 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 64 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 65 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublej4,doublep0,doubleh6)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 66 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returny6;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 67 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 68 =====
=====標準答案=====<BOM>Envelop第10行z.K0在呼叫z物件中的物件資料時,應呼叫getSender()來回傳returnK0Envelop第11行的z.R4/z.I7與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 69 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 70 =====
=====標準答案=====<BOM>T變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperx2=newKeeper(...);Petg8=newPet(...,x2);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立T物件變數的值，例如，publicPet(Stringl6,StringB9,StringU1,KeeperT){...this.T=T;}Pet建構子內已有T參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petg8=newPet(l6,B9,U1,x2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 71 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成v6.equals("貓")，v6.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 72 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringu5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 73 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]C9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 74 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(U5,...);Keeperk=newKeeper(J3,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 75 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]l3={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 76 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 77 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerP=newScanner();inti6=P.nextInt();//讀取數值P.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為L8[F0]，若寫成L8[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 78 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 79 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 80 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，q1,g1是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringq1;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 81 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringJ5,StringG8,Stringe5,StringM7,StringL2){super(J5,G8,e5,M7,L2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 82 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 83 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]b9){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 84 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 85 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 86 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 87 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成h9.equals("貓")，h9.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 88 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringn1;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringn1;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 89 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 90 =====
=====標準答案=====<BOM>B5變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(Z1,F7);透過Keeper建構子，將Z1與F7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringL6,Stringj3,Stringf9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 91 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2C9newExam2();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 92 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:Y9.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 93 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringw6,StringE3,StringN,Strings1,StringV0){super(w6,E3,N,s1,V0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 94 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如o3，c6，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterU9=(EnglishLetter)k0;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectU9){Letterk0=(Letter)U9;returnN0.compareTo(k0.getDate());}先將原本宣告成Object的k0強制轉換成Letter類別型態這樣k0就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 95 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入x4.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 96 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 97 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 98 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=l4,my=g5<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 99 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.w1=w1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 100 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 101 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"y5","b"};例如，本程式的MyMathUtil類別，需改成String[]H4={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 102 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringG3,Stringn5,doubleh4,doubleA9){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(G3,n5,h4,A9);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 103 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerW1=newScanner();intp=W1.nextInt();//讀取數值W1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 104 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 105 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 106 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.n9=n9this.D5=D5<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 107 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]n6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 108 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringK0,StringG0,Stringk){this.K0=K0;this.G0=G0;this.k=k;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 109 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=x2.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 110 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 111 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(inth0,...,Stringtestdate,...){super(h0,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 112 =====
=====標準答案=====<BOM>變數名稱e1重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 113 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringh="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 114 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperZ4=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,Z4);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 115 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 116 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 117 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫A6中的物件動作來回傳值例:A6.getSender();而不是直接呼叫A6中的物件資料System.out.println("From:"+T2+","+A6.getSender());System.out.println("To:"+H2+","+A6.getReceiver()+""+A6.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 118 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringL5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 119 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 120 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 121 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.f1=f1;this.Q1=Q1;this.Z5=Z5;重複定義只需要returnU4=f1*Q1*Z5;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 122 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 123 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 124 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=j;tel=e7;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 125 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入e8.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 126 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.W7=W7this.G7=G7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 127 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=o9,my=V0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 128 =====
=====標準答案=====<BOM>w6變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperV5=newKeeper(...);PetQ5=newPet(...,V5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立w6物件變數的值，例如，publicPet(Stringd9,Stringi0,Stringz3,Keeperw6){...this.w6=w6;}Pet建構子內已有w6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetQ5=newPet(d9,i0,z3,V5);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 129 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 130 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 131 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成tmp.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 132 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letters2=(Letter)other;returnF8.compareTo(s2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]H7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:H7)letter.compareTo(letter);for(Letterletter:H7)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 133 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 134 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 135 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q1.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterK=(Letter)other;returnA0.compareTo(K.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]p1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:p1)letter.compareTo(letter);for(Letterletter:p1)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 136 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returns1=2*(o4*N5+N5*f1+o4*f1);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(o4*N5+N5*f1+f1*o4);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returno4*N5*f1;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.o4=sc.nextDouble();System.out.print("輸入寬度:");box.N5=sc.nextDouble();System.out.print("輸入高度:");box.f1=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("s1:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(o4*N5+N5*f1+f1*o4);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returno4*N5*f1;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.o4=sc.nextDouble();System.out.print("輸入寬度:");box.N5=sc.nextDouble();System.out.print("輸入高度:");box.f1=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("s1:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 137 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 138 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerR7=newScanner();intb8=R7.nextInt();//讀取數值R7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為o6[u]，若寫成o6[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 139 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 140 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleU0,doubleD6,doubleM2)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 141 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 142 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 143 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 144 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 145 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 146 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringg5,StringD9,StringT6,Stringy2,Stringc){super(g5,D9,T6,y2,c)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringg5,StringD9,StringT6,Stringy2,Stringc){super(g5,D9,T6,y2,c)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 147 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"H9","b"};例如，本程式的MyMathUtil類別，需改成String[]s2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 148 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 149 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 150 =====
=====標準答案=====<BOM>s4,i6變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepers4=newKeeper(...);PetX1=newPet(...,s4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringB,StringT6,Stringi5,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetX1=newPet(B,T6,i5,s4);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 151 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 152 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 153 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 154 =====
=====標準答案=====<BOM>按順序應為H8,b4,K4。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 155 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterg3=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");g3.display();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 156 =====
=====標準答案=====<BOM>F4變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(q4,P2);透過Keeper建構子，將q4與P2的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringX0,Stringi9,Stringq1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 157 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(H8.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringg9,Stringa8,StringH8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 158 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]w2){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 159 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 160 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 161 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 162 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 163 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 164 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k8，B2，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 165 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(S7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterz3=(Letter)other;returnB0.compareTo(z3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]u2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:u2)letter.compareTo(letter);for(Letterletter:u2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 166 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 167 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 168 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX9,Stringh0,Stringi1,StringT5,Stringw2){super(X9,h0,i1,T5,w2)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 169 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(I5.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringo2,Stringb2)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將I5.Speak()改為D5.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperD5=newKeeper(o2,b2);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringI5,StringS2,Stringw0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 170 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 171 =====
=====標準答案=====<BOM>變數名稱v4重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 172 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 173 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringq1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 174 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，x4.equals("貓")，x4.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 175 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 176 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 177 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringY7,StringC2,Strings6,StringP3,StringA2){super(Y7,C2,s6,P3,A2)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 178 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(inte8){...returne8;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleT5=X(k1);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 179 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=J2,my=p4<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 180 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(e5,U1,K9);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 181 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成e4.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 182 =====
=====標準答案=====<BOM>變數名稱P4重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(J6.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 183 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 184 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如u6=i;應改成i=u6;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 185 =====
=====標準答案=====<BOM>v變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperv5=newKeeper(...);PetP5=newPet(...,v5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立v物件變數的值，例如，publicPet(StringX6,StringX3,StringV5,Keeperv){...this.v=v;}Pet建構子內已有v參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetP5=newPet(X6,X3,V5,v5);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 186 =====
=====標準答案=====<BOM>變數名稱z1重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 187 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 188 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 189 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 190 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 191 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 192 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 193 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringD5,StringZ0,Stringn4,StringS6,Stringc0){super(D5,Z0,n4,S6,c0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 194 =====
=====標準答案=====<BOM>按順序應為K7,g3,i2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 195 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 196 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringL5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 197 =====
=====標準答案=====<BOM>變數名稱重複宣告f[j4]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:f[1],Integer.parseInt(f[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 198 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:E2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 199 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 200 =====
=====標準答案=====<BOM>H變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperH=newKeeper(...);PetO0=newPet(...,H);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(f1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringg9,StringN4,Stringf1,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetO0=newPet(Q8,g3,P9,H);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 201 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 202 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]m9){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 203 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc2,StringL7,Stringg4,StringK4,StringB2){super(c2,L7,g4,K4,B2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 204 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 205 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringU4,StringR,Stringd0,StringW0){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(U4,R,d0,W0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 206 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 207 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 208 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.d1=d1this.N2=N2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 209 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 210 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 211 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 212 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 213 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerA8=newScanner();inta3=A8.nextInt();//讀取數值A8.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為q[v7]，若寫成q[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 214 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 215 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 216 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=r2.nextInt();doublei1=r2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr2=newScanner();intU2=r2.nextInt();//讀取數值r2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 217 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 218 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 219 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 220 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 221 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入x9.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 222 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 223 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的m3物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 224 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(a3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Strings,StringG7,StringT2,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 225 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 226 =====
=====標準答案=====<BOM>Envelope擁有Letter的j3物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+d3+","+j3.getSender());System.out.println("To:"+f2+","+j3.getReceiver()+""+j3.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 227 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 228 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.p3=p3;this.L3=L3;this.F2=F2;重複定義只需要returnD2=p3*L3*F2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 229 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 230 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 231 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 232 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如a5，K5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 233 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringv5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 234 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 235 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成k5.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 236 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);q1=scanner.nextInt();M7=scanner.nextInt();u6=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleF3;publicdoubleW7;publicdoubleJ3;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleF3;publicdoubleW7;publicdoubleJ3;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 237 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 238 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]m9={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 239 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(S9+""+q0+",您好");System.out.println(f4);System.out.println(B6+"敬上");System.out.println(K7);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 240 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleB0=X(D1);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 241 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 242 =====
=====標準答案=====<BOM>按順序應為b8,d5,U5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 243 =====
=====標準答案=====<BOM>變數名稱重複宣告Q4[E9]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:Q4[1],Integer.parseInt(Q4[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 244 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 245 =====
=====標準答案=====<BOM>E9,F9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperE9=newKeeper(...);Peta0=newPet(...,E9);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringd4,StringU5,Stringz5,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Peta0=newPet(d4,U5,z5,E9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 246 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 247 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 248 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 249 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 250 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerC7=newScanner();intF1=C7.nextInt();//讀取數值C7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為V[G4]，若寫成V[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 251 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 252 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringY;...，此外，ChineseLetter與EnglishLetter就可以刪除StringY;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 253 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 254 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 255 =====
=====標準答案=====<BOM>StringG2={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]G2={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]U0){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 256 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 257 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intD4=1;類別動作(D4);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 258 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returng3;。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 259 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannern8=newScanner();intp=n8.nextInt();//讀取數值n8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 260 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]p5){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 261 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 262 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerg1=newScanner();intr8=g1.nextInt();//讀取數值g1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為u[h0]，若寫成u[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 263 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 264 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 265 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如g1.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 266 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 267 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 268 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成m4.equals("貓")，m4.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 269 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 270 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 271 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(T7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri7=(Letter)other;returnh0.compareTo(i7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]l2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:l2)letter.compareTo(letter);for(Letterletter:l2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 272 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入X4.O3=2;X4.p9=2;X4.i4=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleO3=kb.nextDouble();doublep9=kb.nextDouble();doublei4=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 273 =====
=====標準答案=====<BOM>按順序應為i6,R3,A5。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 274 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，h5,z5是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringh5;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 275 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 276 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 277 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]c){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 278 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 279 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 280 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 281 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 282 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 283 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 284 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 285 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 286 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數W2會衝突,導致W2無法傳遞,建議在Class中宣告W2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intJ=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 287 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 288 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 289 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Q9","b"};例如，本程式的MyMathUtil類別，需改成String[]m={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 290 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intr3=1;類別動作(r3);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 291 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringf6,StringU5,StringM2,StringE4,StringX5){super(f6,U5,M2,E4,X5)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 292 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(n.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringP,Stringu2,Stringn,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 293 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，E6,d3是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringE6;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 294 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returno7=2*(O4*p7+p7*e2+O4*e2);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(O4*p7+p7*e2+e2*O4);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnO4*p7*e2;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.O4=sc.nextDouble();System.out.print("輸入寬度:");box.p7=sc.nextDouble();System.out.print("輸入高度:");box.e2=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("o7:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(O4*p7+p7*e2+e2*O4);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnO4*p7*e2;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.O4=sc.nextDouble();System.out.print("輸入寬度:");box.p7=sc.nextDouble();System.out.print("輸入高度:");box.e2=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("o7:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 295 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 296 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 297 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 298 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 299 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 300 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:m8.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 301 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 302 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 303 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 304 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringv0,Stringd9,StringE4,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 305 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=G3.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 306 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 307 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 308 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringH,StringP5,StringY0,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 309 =====
=====標準答案=====<BOM>按順序應為I5,J4,M。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 310 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 311 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 312 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 313 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數d8會衝突,導致d8無法傳遞,建議在Class中宣告d8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intV2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 314 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 315 =====
=====標準答案=====<BOM>變數名稱r4重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 316 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(E3.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中b等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:g1.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringb,StringG1,StringE3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 317 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 318 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如e8，q0，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 319 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Lettero2=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 320 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 321 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 322 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 323 =====
=====標準答案=====<BOM>按順序應為k6,q6,w2。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 324 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 325 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 326 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(j,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringt,StringH8)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 327 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數U6會衝突,導致U6無法傳遞,建議在Class中宣告U6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intb=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 328 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如p8=i;應改成i=p8;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 329 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringU6,StringZ8,StringP9,StringL6,Stringy7){super(U6,Z8,P9,L6,y7)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 330 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnn8;。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 331 =====
=====標準答案=====<BOM>b9變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(v,Y1);透過Keeper建構子，將v與Y1的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringM7,StringO6,Stringf8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 332 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(C5+""+k0+",您好");System.out.println(F0);System.out.println(O1+"敬上");System.out.println(h3);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 333 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=t.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 334 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"l5","b"};例如，本程式的MyMathUtil類別，需改成String[]r3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 335 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 336 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intk7,...,Stringtestdate,...){super(k7,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 337 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 338 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:A5=newExam(I2,J0,y8,w0,B8,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]W8){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 339 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=Q0;tel=W0;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 340 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 341 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterm7=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 342 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.P9=P9;this.t1=t1;this.V4=V4;重複定義只需要returnq7=P9*t1*V4;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 343 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 344 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 345 =====
=====標準答案=====<BOM>按順序應為r,a8,J。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 346 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的M4與englishletter與letter就可刪除StringM1,...;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 347 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(y1.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 348 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringi3,StringU7,Stringp4,Stringb9){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(i3,U7,p4,b9);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 349 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(H7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterK1=(Letter)other;returnJ2.compareTo(K1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]T6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:T6)letter.compareTo(letter);for(Letterletter:T6)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 350 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 351 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"M7","b"};例如，本程式的MyMathUtil類別，需改成String[]A7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 352 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 353 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=T7,my=b<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 354 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringA2;...，此外，ChineseLetter與EnglishLetter就可以刪除StringA2;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 355 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 356 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 357 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 358 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]k={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 359 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 360 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 361 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=o9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 362 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:T5=newExam(c7,K9,p4,P7,h9,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]i0){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 363 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]Y4){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 364 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=S7.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 365 =====
=====標準答案=====<BOM>Envelope擁有Letter的B7物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+b+","+B7.getSender());System.out.println("To:"+U5+","+B7.getReceiver()+""+B7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 366 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 367 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 368 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(O7.equals("狗"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 369 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 370 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 371 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 372 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 373 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 374 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 375 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 376 =====
=====標準答案=====<BOM>變數名稱c9重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 377 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringv3,Stringo3,StringH4){this.v3=v3;this.o3=o3;this.H4=H4;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 378 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.a1=a1this.s0=s0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 379 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用k4.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.j7=j7;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 380 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成r4.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 381 =====
=====標準答案=====<BOM>變數名稱S5重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(F8.equals("0")==false)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 382 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 383 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 384 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 385 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 386 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 387 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX2,Stringd0,Stringx,StringC0,Stringe7){super(X2,d0,x,C0,e7)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringX2,Stringd0,Stringx,StringC0,Stringe7){super(X2,d0,x,C0,e7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 388 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 389 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如P7，Z0，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 390 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringq1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 391 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 392 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 393 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=l1,my=N4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 394 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:S9.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 395 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 396 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleI2,doubleb7,doubleU8)publicstaticdoubleVolume(doubleI2,doubleb7,doubleU8)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleI2=scanner.nextDouble();System.out.println("輸入寬");doubleb7=scanner.nextDouble();System.out.println("輸入高");doubleU8=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.I2=I2;this.b7=b7;this.U8=U8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 397 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(k6.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中s1等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:W1.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Strings1,Stringw8,Stringk6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 398 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 399 =====
=====標準答案=====<BOM>按順序應為v3,D4,k0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 400 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 401 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(f3.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中W2等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:k2.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringW2,StringD8,Stringf3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 402 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 403 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入l7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 404 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 405 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.z3=z3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 406 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 407 =====
=====標準答案=====<BOM>變數名稱重複宣告F4[N5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:F4[1],Integer.parseInt(F4[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 408 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringI;...，此外，ChineseLetter與EnglishLetter就可以刪除StringI;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 409 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"s9","b"};例如，本程式的MyMathUtil類別，需改成String[]k5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 410 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 411 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 412 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 413 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 414 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intD3){...returnD3;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublef4=X(Z6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 415 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=t,my=q2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 416 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(m2),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]F9){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 417 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如b6.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 418 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.x1=x1;this.t4=t4;this.f0=f0;重複定義只需要returnn5=x1*t4*f0;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 419 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 420 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 421 =====
=====標準答案=====<BOM>Stringy0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]y0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]S3){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 422 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 423 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 424 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 425 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringX2,StringJ5,Stringa8,StringD1){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(X2,J5,a8,D1);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 426 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 427 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 428 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 429 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]R4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 430 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如D9，B0，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 431 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intI2){I2=3;returnI2;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublex4=X(d5);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 432 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 433 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 434 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Z1","b"};例如，本程式的MyMathUtil類別，需改成String[]s2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 435 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 436 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 437 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如G0，I3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterb6=(EnglishLetter)w2;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectb6){Letterw2=(Letter)b6;returnM4.compareTo(w2.getDate());}先將原本宣告成Object的w2強制轉換成Letter類別型態這樣w2就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 438 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 439 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 440 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 441 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如H0.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 442 =====
=====標準答案=====<BOM>Envelop第10行G8.r2在呼叫G8物件中的物件資料時,應呼叫getSender()來回傳returnr2Envelop第11行的G8.D8/G8.j4與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 443 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 444 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneru=newScanner();intY1=u.nextInt();//讀取數值u.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為e9[O2]，若寫成e9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 445 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerl5=newScanner();intR8=l5.nextInt();//讀取數值l5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為k5[h9]，若寫成k5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 446 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如d2，D4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 447 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 448 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 449 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(p3.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringp9,Stringi5,Stringp3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 450 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(h0.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(Stringr4,StringG3,Stringh0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 451 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 452 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intM8=1;類別動作(M8);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 453 =====
=====標準答案=====<BOM>Envelope擁有Letter的r7物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+R9+","+r7.getSender());System.out.println("To:"+q2+","+r7.getReceiver()+""+r7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 454 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringl5,StringZ4,StringN,StringM8,StringA9){super(l5,Z4,N,M8,A9)}}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 455 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k9，H9，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 456 =====
=====標準答案=====<BOM>變數名稱p重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(Pt.equals("0")==false)<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 457 =====
=====標準答案=====<BOM>StringB9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]B9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]z3){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 458 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 459 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 460 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的e1物件資料所以在呼叫e1的物件動作的時候應加上System.out.println("From:"+N9+","+e1.getSender());System.out.println("To:"+K9+","+e1.getReceiver()+""+e1.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 461 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterr=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 462 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.E8=E8this.D=D<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 463 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 464 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringl2,Stringh8,Stringi2,Stringo3,StringB7){super(l2,h8,i2,o3,B7)}}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 465 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]T3={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 466 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 467 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 468 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 469 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnS1;。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 470 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行q9.B8在呼叫q9物件中的物件資料時,應呼叫getSender()來回傳returnB8<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 471 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如a9，R6，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 472 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 473 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 474 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 475 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneru7=newScanner();intA2=u7.nextInt();//讀取數值u7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為B5[j0]，若寫成B5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 476 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 477 =====
=====標準答案=====<BOM>W7變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperW7=newKeeper(...);Petpet=newPet(...,W7);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetV2=newPet(l9,O6,s3);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(s3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立W7物件變數的值，例如，publicPet(Stringl9,StringO6,Strings3,KeeperW7){...this.W7=W7;}Pet建構子內已有W7參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetV2=newPet(l9,O6,s3,o7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫W7.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...W7.display();speak();}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 478 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 479 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterT2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");T2.display();}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 480 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 481 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterO0=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");O0.display();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 482 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(F7,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(StringU9,StringU5)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 483 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 484 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 485 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intk6){k6=3;returnk6;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublez0=X(U2);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 486 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(W3.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 487 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 488 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如R7.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 489 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，s7變數型態為Int，V4變數型態為Int，z變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:J0,m4為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 490 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 491 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnj9;。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 492 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 493 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterw0=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 494 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 495 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 496 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]D1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 497 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 498 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=I8,my=Q3<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 499 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 500 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 501 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，B2.equals("貓")，B2.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 502 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 503 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]U0){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 504 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 505 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 506 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 507 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 508 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 509 =====
=====標準答案=====<BOM>變數名稱m2重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 510 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 511 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 512 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringT4,StringS2,StringL,StringL5,StringU4){super(T4,S2,L,L5,U4)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringT4,StringS2,StringL,StringL5,StringU4){super(T4,S2,L,L5,U4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 513 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringt2;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringt2;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 514 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 515 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 516 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，，-分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 517 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(D2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterr1=(Letter)other;returnZ.compareTo(r1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]F9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:F9)letter.compareTo(letter);for(Letterletter:F9)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 518 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 519 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 520 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 521 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringz8,Stringw1,StringB2,Stringt8,StringH4){super(z8,w1,B2,t8,H4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 522 =====
=====標準答案=====<BOM>按順序應為Z0,x3,p9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 523 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 524 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringD,Stringa3,StringR6,Stringr,StringK0){super(D,a3,R6,r,K0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 525 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 526 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 527 =====
=====標準答案=====<BOM>變數名稱U4重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 528 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(ints6){s6=3;returns6;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublev8=X(t1);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 529 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnP1;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 530 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 531 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫K2中的物件動作來回傳值例:K2.getSender();而不是直接呼叫K2中的物件資料System.out.println("From:"+A7+","+K2.getSender());System.out.println("To:"+J1+","+K2.getReceiver()+""+K2.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 532 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 533 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 534 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerM5=newScanner();intp=M5.nextInt();//讀取數值M5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 535 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 536 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 537 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:q0,l5,E5,i0為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:s4,i0為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:z7,r4為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:U2,X5為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 538 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數j1會衝突,導致j1無法傳遞,建議在Class中宣告j1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intJ8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 539 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 540 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intb0){b0=3;returnb0;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublen=X(N6);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 541 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleW7,doubleS8,doublec應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.W7=a2;bb.S8=W4;bb.c=N3;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.W7=a2;bb.S8=W4;bb.c=N3;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleW7,doubleS8,doublec沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 542 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 543 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 544 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 545 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如j9，k2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterA2=(EnglishLetter)w;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectA2){Letterw=(Letter)A2;returnj4.compareTo(w.getDate());}先將原本宣告成Object的w強制轉換成Letter類別型態這樣w就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 546 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 547 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用I.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.w9=w9;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 548 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"G3","b"};例如，本程式的MyMathUtil類別，需改成String[]c0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 549 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 550 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerU9=newScanner();inti8=U9.nextInt();//讀取數值U9.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為E4[N6]，若寫成E4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 551 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=B5.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 552 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 553 =====
=====標準答案=====<BOM>D2變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperG6=newKeeper(...);Pett8=newPet(...,G6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立D2物件變數的值，例如，publicPet(Stringw,Stringa9,Stringv0,KeeperD2){...this.D2=D2;}Pet建構子內已有D2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Pett8=newPet(w,a9,v0,G6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 554 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2hnewExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 555 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 556 =====
=====標準答案=====<BOM>n4變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(s5,n5);透過Keeper建構子，將s5與n5的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringK,StringX3,StringK8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 557 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnf5;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 558 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 559 =====
=====標準答案=====<BOM>變數名稱重複宣告v2[y0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:v2[1],Integer.parseInt(v2[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 560 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringH4,StringV,StringC7,StringY2,Stringd7){super(H4,V,C7,Y2,d7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 561 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 562 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 563 =====
=====標準答案=====<BOM>變數名稱重複宣告g[z9]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g[1],Integer.parseInt(g[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 564 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]x7){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 565 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.E9=E9;this.q7=q7;this.V7=V7;重複定義只需要returnl7=E9*q7*V7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 566 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(b8)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 567 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 568 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringV,Stringf6,Stringz,Stringn6){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(V,f6,z,n6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 569 =====
=====標準答案=====<BOM>Envelop第10行N8.F4在呼叫N8物件中的物件資料時,應呼叫getSender()來回傳returnF4Envelop第11行的N8.D4/N8.S4與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 570 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:F=newExam(d6,O8,y4,V7,y8,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]t8){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 571 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(X4,p9,e3);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 572 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 573 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.J0=J0this.W=W<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 574 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 575 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterP9=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 576 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxM2=newKKBOx(l,w,h);呼叫時可用M2.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 577 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleE4,doubleH2,doubleR3應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.E4=a2;bb.H2=r8;bb.R3=M2;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.E4=a2;bb.H2=r8;bb.R3=M2;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleE4,doubleH2,doubleR3沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 578 =====
=====標準答案=====<BOM>變數名稱Z0重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 579 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 580 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數U6會衝突,導致U6無法傳遞,建議在Class中宣告U6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intV1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 581 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 582 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 583 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 584 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 585 =====
=====標準答案=====<BOM>變數名稱A5重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 586 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnY2;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 587 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.f8=f8this.u6=u6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 588 =====
=====標準答案=====<BOM>按順序應為W7,s0,Z1。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 589 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 590 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]L6){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 591 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如F，a6，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 592 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]D8){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 593 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intq4){...returnq4;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleD3=X(T9);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 594 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(R9.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(Stringu8,StringD5,StringR9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 595 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:B0.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 596 =====
=====標準答案=====<BOM>Envelope擁有Letter的z1物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+T6+","+z1.getSender());System.out.println("To:"+r0+","+z1.getReceiver()+""+z1.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 597 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如u5.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 598 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubles5=X(E);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 599 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 600 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.Z4=Z4this.b8=b8<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 601 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringa8,Stringy,Stringo4,StringQ7,Strings9){super(a8,y,o4,Q7,s9)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 602 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 603 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.H8=H8;this.W2=W2;this.r=r;重複定義只需要returnV5=H8*W2*r;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 604 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(T2.equals("貓"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 605 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如V7，b9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 606 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returns5;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 607 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 608 =====
=====標準答案=====<BOM>m0變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperm0=newKeeper(...);Petpet=newPet(...,m0);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetU0=newPet(l0,j4,h1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(h1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立m0物件變數的值，例如，publicPet(Stringl0,Stringj4,Stringh1,Keeperm0){...this.m0=m0;}Pet建構子內已有m0參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetU0=newPet(l0,j4,h1,t1);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫m0.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...m0.display();speak();}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 609 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperc7=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,c7);<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 610 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 611 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 612 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如N5.equals("狗")。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 613 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 614 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returna7;。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 615 =====
=====標準答案=====<BOM>按順序應為E8,A0,u0。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 616 =====
=====標準答案=====<BOM>按順序應為a8,M4,F0。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 617 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=e4.nextInt();doubleu0=e4.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannere4=newScanner();intI5=e4.nextInt();//讀取數值e4.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 618 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(y9.equals("狗"))<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 619 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 620 =====
=====標準答案=====<BOM>按順序應為Z2,n2,m9。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 621 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(M2.equals("狗"))<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 622 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 623 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 624 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 625 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 626 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 627 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringx8="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 628 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 629 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 630 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 631 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 632 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 633 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 634 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 635 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]A1={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 636 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如a1.equals("貓")。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 637 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=A,my=B6<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 638 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]B3){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 639 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 640 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 641 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如v5.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 642 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=y1.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 643 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]K8={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 644 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 645 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 646 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 647 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 648 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成g4.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 649 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 650 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);l1=scanner.nextInt();O4=scanner.nextInt();v2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleH7;publicdoubleJ9;publicdoubleq8;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleH7;publicdoubleJ9;publicdoubleq8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 651 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 652 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如l7.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 653 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(s8.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringH8,StringB4,StringK1,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 654 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 655 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 656 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]J5){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 657 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數d9會衝突,導致d9無法傳遞,建議在Class中宣告d9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intu4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 658 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 659 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入a5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 660 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);F=scanner.nextInt();p4=scanner.nextInt();q0=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublex8;publicdoubleO6;publicdoublee0;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublex8;publicdoubleO6;publicdoublee0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 661 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublet8,doubleF0,doubleX0)publicstaticdoubleVolume(doublet8,doubleF0,doubleX0)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublet8=scanner.nextDouble();System.out.println("輸入寬");doubleF0=scanner.nextDouble();System.out.println("輸入高");doubleX0=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.t8=t8;this.F0=F0;this.X0=X0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 662 =====
=====標準答案=====<BOM>r5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperr5=newKeeper(...);Petpet=newPet(...,r5);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetE5=newPet(m8,O2,V5);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(V5.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立r5物件變數的值，例如，publicPet(Stringm8,StringO2,StringV5,Keeperr5){...this.r5=r5;}Pet建構子內已有r5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetE5=newPet(m8,O2,V5,f9);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫r5.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...r5.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 663 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE3,Stringb2,StringL9,StringM4,StringO7){super(E3,b2,L9,M4,O7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 664 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intq3,...,Stringtestdate,...){super(q3,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 665 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:j2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 666 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 667 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringU1,Stringb8,StringV8,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 668 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如y，Z0，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 669 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 670 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 671 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 672 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(C6),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]F8){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 673 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 674 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(f7),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]t6){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 675 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=J5,my=x<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 676 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]n4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 677 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 678 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數N2會衝突,導致N2無法傳遞,建議在Class中宣告N2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intY2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 679 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(F9.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中b0等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:o3.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringb0,StringF7,StringF9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 680 =====
=====標準答案=====<BOM>變數名稱N9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 681 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，R0.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 682 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 683 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 684 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 685 =====
=====標準答案=====<BOM>按順序應為l6,N5,x9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 686 =====
=====標準答案=====<BOM>變數名稱重複宣告P1[D5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:P1[1],Integer.parseInt(P1[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 687 =====
=====標準答案=====<BOM>Envelop第10行T0.a1在呼叫T0物件中的物件資料時,應呼叫getSender()來回傳returna1Envelop第11行的T0.N9/T0.e1與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 688 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(f8,k1,D);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 689 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 690 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intH1){H1=3;returnH1;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublec2=X(T4);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 691 =====
=====標準答案=====<BOM>按順序應為b1,x3,i3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 692 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.x9=x9this.f3=f3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 693 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 694 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"h5","b"};例如，本程式的MyMathUtil類別，需改成String[]n9={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 695 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW9,Stringy9,Stringa6,Stringg6,StringE5){super(W9,y9,a6,g6,E5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 696 =====
=====標準答案=====<BOM>F2變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperF2=newKeeper(...);Petpet=newPet(...,F2);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petq8=newPet(A3,J2,L0);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(L0.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立F2物件變數的值，例如，publicPet(StringA3,StringJ2,StringL0,KeeperF2){...this.F2=F2;}Pet建構子內已有F2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petq8=newPet(A3,J2,L0,I3);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫F2.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...F2.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 697 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"t1","b"};例如，本程式的MyMathUtil類別，需改成String[]D9={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 698 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行Z5.b3在呼叫Z5物件中的物件資料時,應呼叫getSender()來回傳returnb3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 699 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 700 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleu5=X(N6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 701 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW1,StringL6,StringK1,Stringg9,Stringr9){super(W1,L6,K1,g9,r9)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 702 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 703 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 704 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 705 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 706 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如o2，G3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterj6=(EnglishLetter)V6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectj6){LetterV6=(Letter)j6;returnN4.compareTo(V6.getDate());}先將原本宣告成Object的V6強制轉換成Letter類別型態這樣V6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 707 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 708 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.length=length;this.width=width;this.height=height;重複定義只需要returnx=length*width*height;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 709 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 710 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 711 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnk1;。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 712 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringl1,Stringl,Stringf9,StringG,StringR8){super(l1,l,f9,G,R8)}}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 713 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如e0=i;應改成i=e0;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 714 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 715 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入N4.display();<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 716 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 717 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 718 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(m1.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterj0=(Letter)other;returnk2.compareTo(j0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t3)letter.compareTo(letter);for(Letterletter:t3)letter.display();<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 719 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 720 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 721 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 722 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 723 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 724 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 725 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 726 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數h0會衝突,導致h0無法傳遞,建議在Class中宣告h0即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intx0=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 727 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 728 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 729 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 730 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnA1;。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 731 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 732 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 733 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 734 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(Z4),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]V0){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 735 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的e物件資料所以在呼叫e的物件動作的時候應加上System.out.println("From:"+n5+","+e.getSender());System.out.println("To:"+r8+","+e.getReceiver()+""+e.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 736 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，O,A是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringO;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 737 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 738 =====
=====標準答案=====<BOM>U2變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperH5=newKeeper(...);PetP4=newPet(...,H5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立U2物件變數的值，例如，publicPet(Stringj6,Stringz8,StringJ3,KeeperU2){...this.U2=U2;}Pet建構子內已有U2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetP4=newPet(j6,z8,J3,H5);<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 739 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringE0,Z2,O7,w1,Y4;Letter(StringE0,StringZ2,StringO7,Stringw1,StringY4){this.E0=E0;this.Z2=Z2;this.O7=O7;this.w1=w1;this.Y4=Y4;}publicStringgetSender(){returnw1;}publicStringgetReceiver(){returnZ2;}publicStringgetDate(){returnY4;}<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 740 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入H.Q8=2;H.H3=2;H.Q6=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleQ8=kb.nextDouble();doubleH3=kb.nextDouble();doubleQ6=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 741 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 742 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成l8.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 743 =====
=====標準答案=====<BOM>變數名稱重複宣告w3[g5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:w3[1],Integer.parseInt(w3[2])<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 744 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:E0.display();<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 745 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 746 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerd2=newScanner();intp=d2.nextInt();//讀取數值d2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 747 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.S5=S5this.X1=X1<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 748 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數I2會衝突,導致I2無法傳遞,建議在Class中宣告I2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intO=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 749 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 750 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 751 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 752 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=u6.getSender();StringReceiver=u6.getReceiver();StringTitle=u6.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 753 =====
=====標準答案=====<BOM>a3變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperG6=newKeeper(...);Petj5=newPet(...,G6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立a3物件變數的值，例如，publicPet(Stringy3,StringB2,Stringd9,Keepera3){...this.a3=a3;}Pet建構子內已有a3參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petj5=newPet(y3,B2,d9,G6);<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 754 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的g物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 755 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.l9=l9;this.u5=u5;this.l1=l1;重複定義只需要returnj4=l9*u5*l1;<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 756 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 757 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的N6物件資料所以在呼叫N6的物件動作的時候應加上System.out.println("From:"+F2+","+N6.getSender());System.out.println("To:"+X2+","+N6.getReceiver()+""+N6.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 758 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"U6","b"};例如，本程式的MyMathUtil類別，需改成String[]j8={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 759 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 760 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 761 =====
=====標準答案=====<BOM>Stringd2={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]d2={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]g6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 762 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 763 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 764 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 765 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringM5,Stringr,Stringi1,StringL9,Stringd2){super(M5,r,i1,L9,d2)}}<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 766 =====
=====標準答案=====<BOM>按順序應為Y6,T7,A2。<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 767 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>變數名稱n重複宣告。<EOM>
Meteor_Score : 0.0

===== 768 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 769 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 770 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 771 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 772 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(m0+""+N9+",您好");System.out.println(b0);System.out.println(H8+"敬上");System.out.println(b8);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 773 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 774 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnj5;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 775 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(i4.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringe,Stringk9)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將i4.Speak()改為T6.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperT6=newKeeper(e,k9);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringi4,Stringw4,StringR3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 776 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringP7,StringW4,StringV,Stringr7,StringL0){super(P7,W4,V,r7,L0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 777 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 778 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 779 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp7,StringU0,StringP0,StringG3,Stringj){super(p7,U0,P0,G3,j)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 780 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 781 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 782 =====
=====標準答案=====<BOM>Envelop第10行V4.z在呼叫V4物件中的物件資料時,應呼叫getSender()來回傳returnzEnvelop第11行的V4.i8/V4.d7與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 783 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 784 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 785 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 786 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 787 =====
=====標準答案=====<BOM>變數名稱A5重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 788 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 789 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 790 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringP2,StringP8,StringK7,Stringl2){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(P2,P8,K7,l2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 791 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 792 =====
=====標準答案=====<BOM>S9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperS9=newKeeper(...);Petq6=newPet(...,S9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(t5.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringK8,Stringv3,Stringt5,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petq6=newPet(O1,L4,y6,S9);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 793 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 794 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 795 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=S2.nextInt();doubled7=S2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerS2=newScanner();intp2=S2.nextInt();//讀取數值S2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 796 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=u0,my=i7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 797 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 798 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 799 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringe4,Stringu6,doubleq8,doubleO4){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(e4,u6,q8,O4);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 800 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入G8.C6=2;G8.k9=2;G8.f=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleC6=kb.nextDouble();doublek9=kb.nextDouble();doublef=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 801 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 802 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);E0=scanner.nextInt();g3=scanner.nextInt();k6=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleo3;publicdoubleP6;publicdoubleD4;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleo3;publicdoubleP6;publicdoubleD4;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 803 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringc1,Stringf,StringK1){this.c1=c1;this.f=f;this.K1=K1;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 804 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 805 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.c3=c3this.L0=L0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 806 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 807 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 808 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 809 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 810 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 811 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 812 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，u8.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 813 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，B,t8是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringB;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 814 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 815 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 816 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]Q0){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 817 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringl5,StringT4,Stringk0,Stringn6,Stringd3){super(l5,T4,k0,n6,d3)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 818 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intK0){...returnK0;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleu7=X(g8);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 819 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(c6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterX9=(Letter)other;returna2.compareTo(X9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]z4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:z4)letter.compareTo(letter);for(Letterletter:z4)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 820 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 821 =====
=====標準答案=====<BOM>z2變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperz2=newKeeper(...);PetY9=newPet(...,z2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(v9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringj4,StringV4,Stringv9,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetY9=newPet(o4,S7,p7,z2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 822 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 823 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 824 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 825 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 826 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringB3,StringV,Stringq7,Stringi5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(B3,V,q7,i5);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 827 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 828 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 829 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperkp=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,kp);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 830 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 831 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 832 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2v2newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 833 =====
=====標準答案=====<BOM>W7變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(s,v7);透過Keeper建構子，將s與v7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringQ2,Stringc9,Stringj2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 834 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 835 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationM0=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationM0;M0=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 836 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringY9,Stringw1,Stringk8,Stringh0,Stringt2){super(Y9,w1,k8,h0,t2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 837 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F=Fthis.r1=r1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 838 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(S6,...);Keeperk=newKeeper(j5,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 839 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 840 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);E7=scanner.nextInt();K2=scanner.nextInt();l0=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleX1;publicdoubley5;publicdoubleg5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleX1;publicdoubley5;publicdoubleg5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 841 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 842 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 843 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 844 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]q8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 845 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 846 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數p5會衝突,導致p5無法傳遞,建議在Class中宣告p5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intT4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 847 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 848 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]J3){Z7.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 849 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 850 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的n4物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 851 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數Y4會衝突,導致Y4無法傳遞,建議在Class中宣告Y4即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intb8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 852 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 853 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 854 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(Y3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterH7=(Letter)other;returnp6.compareTo(H7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]G1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:G1)letter.compareTo(letter);for(Letterletter:G1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 855 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:r2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 856 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用f8.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.f=f;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 857 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 858 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 859 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxB0=newKKBOx(l,w,h);呼叫時可用B0.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 860 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=d6,my=m7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 861 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 862 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(A0.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringV1,Stringf1,StringA0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 863 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行c0.T1在呼叫c0物件中的物件資料時,應呼叫getSender()來回傳returnT1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 864 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 865 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 866 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 867 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(R7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterr5=(Letter)other;returny0.compareTo(r5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Q7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Q7)letter.compareTo(letter);for(Letterletter:Q7)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 868 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 869 =====
=====標準答案=====<BOM>按順序應為u9,g4,c6。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 870 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleB5,doubleX1,doubleO7)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 871 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 872 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 873 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 874 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 875 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=Z9,my=D7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 876 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 877 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 878 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnK0;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 879 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 880 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 881 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 882 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 883 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 884 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 885 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringQ1,Stringf0,Stringw1,Stringb,Stringe0){super(Q1,f0,w1,b,e0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 886 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 887 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如Y7.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 888 =====
=====標準答案=====<BOM>按順序應為R8,x6,V5。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 889 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 890 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 891 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp7,StringD7,StringG1,Stringg,Stringf3){super(p7,D7,G1,g,f3)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 892 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 893 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=m5.nextInt();doubleq9=m5.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerm5=newScanner();intS3=m5.nextInt();//讀取數值m5.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 894 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 895 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringJ0,StringK1,Stringt2,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 896 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(K1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]U5){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 897 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(U+""+C8+",您好");System.out.println(q0);System.out.println(M+"敬上");System.out.println(q5);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 898 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 899 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 900 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如n7=i;應改成i=n7;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 901 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 902 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"a8","b"};例如，本程式的MyMathUtil類別，需改成String[]k2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 903 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，E6.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 904 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F9=F9this.v=v<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 905 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:s2=newExam(s5,f0,J4,Q,I,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o6){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 906 =====
=====標準答案=====<BOM>按順序應為z0,t,S4。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 907 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 908 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.p5=p5this.X3=X3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 909 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如X，D2，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 910 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成E1.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 911 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 912 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero6=newScanner();intp=o6.nextInt();//讀取數值o6.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 913 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(b6.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringV8,StringO)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將b6.Speak()改為V0.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperV0=newKeeper(V8,O);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringb6,Stringb7,Stringh0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 914 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如D7，H3，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 915 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 916 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublea6,doubleA3,doublec6)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 917 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]G9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 918 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 919 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 920 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(W3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterH2=(Letter)other;returnp2.compareTo(H2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]s2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:s2)letter.compareTo(letter);for(Letterletter:s2)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 921 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 922 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 923 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.o7=o7this.y1=y1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 924 =====
=====標準答案=====<BOM>變數名稱s1重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 925 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.k6=k6;this.J8=J8;this.N8=N8;重複定義只需要returnz3=k6*J8*N8;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 926 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 927 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 928 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringj6="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 929 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 930 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.a6=a6;this.d0=d0;this.y1=y1;重複定義只需要returni1=a6*d0*y1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 931 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringt5,Stringm6,Stringj8,StringD5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(t5,m6,j8,D5);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 932 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 933 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=s3.getSender();StringReceiver=s3.getReceiver();StringTitle=s3.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 934 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 935 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 936 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入y0.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 937 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 938 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublew,doubleV3,doubleK9應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.w=N;bb.V3=S;bb.K9=V6;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.w=N;bb.V3=S;bb.K9=V6;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublew,doubleV3,doubleK9沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 939 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 940 =====
=====標準答案=====<BOM>變數名稱重複宣告P2[z5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:P2[1],Integer.parseInt(P2[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 941 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 942 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 943 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 944 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 945 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成x7.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 946 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 947 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如M9，y2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 948 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 949 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 950 =====
=====標準答案=====<BOM>按順序應為S1,w2,f9。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 951 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(T7.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 952 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 953 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringk4,Y1,z6,C6,O;Letter(Stringk4,StringY1,Stringz6,StringC6,StringO){this.k4=k4;this.Y1=Y1;this.z6=z6;this.C6=C6;this.O=O;}publicStringgetSender(){returnC6;}publicStringgetReceiver(){returnY1;}publicStringgetDate(){returnO;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 954 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringN7,Stringl6,Stringd7,Stringz9,StringL1){super(N7,l6,d7,z9,L1)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 955 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerL0=newScanner();intp=L0.nextInt();//讀取數值L0.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 956 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.e4=e4;this.d0=d0;this.N9=N9;重複定義只需要returnm3=e4*d0*N9;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 957 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 958 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用q5.display()顯示內容，此外C5.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 959 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringo5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 960 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleq8,doubleR2,doubles3)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 961 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 962 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.e4;}publicStringgetTitle(){returnthis.x1;}//可取得opublicStringgetReceiver(){returnthis.o;}//可取得y9publicStringgetDate(){returnthis.y9;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 963 =====
=====標準答案=====<BOM>按順序應為J8,B1,e0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 964 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 965 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 966 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 967 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringK,Stringz9,Stringi4,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 968 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringj5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 969 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(O8.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringt5,Stringk5)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將O8.Speak()改為b1.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperb1=newKeeper(t5,k5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringO8,StringZ2,Stringg1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 970 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(b1.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中N1等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:q0.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringN1,StringT,Stringb1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 971 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 972 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 973 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(E1.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettern=(Letter)other;returnJ2.compareTo(n.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]J3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:J3)letter.compareTo(letter);for(Letterletter:J3)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 974 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 975 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 976 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerc3=newScanner();intp=c3.nextInt();//讀取數值c3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 977 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 978 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 979 =====
=====標準答案=====<BOM>變數名稱v3重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 980 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 981 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 982 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入q2.B6=2;q2.A5=2;q2.q9=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleB6=kb.nextDouble();doubleA5=kb.nextDouble();doubleq9=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 983 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 984 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，L0,k6是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringL0;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 985 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringi8,Stringm9,Stringm8,Stringu0,Stringi2){super(i8,m9,m8,u0,i2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 986 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intR3,...,Stringtestdate,...){super(R3,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 987 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 988 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"k1","b"};例如，本程式的MyMathUtil類別，需改成String[]H2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 989 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnC6;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 990 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 991 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]F1){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 992 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb3,Stringk4,Stringb2,StringY8,StringV4){super(b3,k4,b2,Y8,V4)}}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 993 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=X0.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 994 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成R9.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 995 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的S7與englishletter與letter就可刪除StringL9,...;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 996 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]y6={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 997 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 998 =====
=====標準答案=====<BOM>StringG1={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]G1={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]f){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 999 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1000 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringB,StringZ1,StringA0,Stringe7,StringD1){super(B,Z1,A0,e7,D1)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringB,StringZ1,StringA0,Stringe7,StringD1){super(B,Z1,A0,e7,D1)}}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1001 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1002 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.V2=V2this.B5=B5<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1003 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(inth7,...,Stringtestdate,...){super(h7,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1004 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.p8=p8;this.G4=G4;this.j3=j3;重複定義只需要returno4=p8*G4*j3;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1005 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如J1.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1006 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(E8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]s2){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1007 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]O6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1008 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1009 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1010 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如n1，F9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1011 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1012 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerI6=newScanner();intZ5=I6.nextInt();//讀取數值I6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為A7[a7]，若寫成A7[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1013 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1014 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringI1,Stringh6,Stringl,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1015 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1016 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:A0=newExam(o,f1,t2,D5,Q2,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]L8){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1017 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=E.nextInt();doubleX2=E.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerE=newScanner();intF1=E.nextInt();//讀取數值E.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1018 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1019 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1020 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1021 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1022 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intM6=1;類別動作(M6);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1023 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1024 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1025 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1026 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1027 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1028 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1029 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1030 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行Y1.W在呼叫Y1物件中的物件資料時,應呼叫getSender()來回傳returnW<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1031 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1032 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);r=scanner.nextInt();T2=scanner.nextInt();w3=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleR3;publicdoublez2;publicdoubleF0;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleR3;publicdoublez2;publicdoubleF0;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1033 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:m2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1034 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1035 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數A2會衝突,導致A2無法傳遞,建議在Class中宣告A2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intI2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1036 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1037 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(G7.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringA2,StringY8)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將G7.Speak()改為T5.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperT5=newKeeper(A2,Y8);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringG7,StringU6,Stringp3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1038 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的H4物件資料所以在呼叫H4的物件動作的時候應加上System.out.println("From:"+Y8+","+H4.getSender());System.out.println("To:"+Y9+","+H4.getReceiver()+""+H4.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1039 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1040 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1041 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1042 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1043 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=l6.nextInt();doublez6=l6.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerl6=newScanner();intp3=l6.nextInt();//讀取數值l6.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1044 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成t2.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1045 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationD2=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationD2;D2=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1046 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1047 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1048 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成J2.equals("貓")，J2.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1049 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublef0,doublei0,doubleL)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1050 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb8,StringI7,Stringy3,StringE,StringD6){super(b8,I7,y3,E,D6)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringb8,StringI7,Stringy3,StringE,StringD6){super(b8,I7,y3,E,D6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1051 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleD1=X(F3);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1052 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1053 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的J2與englishletter與letter就可刪除Strings0,...;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1054 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]c0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1055 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1056 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1057 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1058 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);Z0=scanner.nextInt();l1=scanner.nextInt();l2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleZ7;publicdoubleO8;publicdoubleQ8;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleZ7;publicdoubleO8;publicdoubleQ8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1059 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1060 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，L3變數型態為Int，k8變數型態為Int，h9變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:A4,x為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1061 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1062 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1063 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerT7=newScanner();intF9=T7.nextInt();//讀取數值T7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為W[q4]，若寫成W[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1064 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.F4=F4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1065 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(F5.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterk2=(Letter)other;returnh7.compareTo(k2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]I4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:I4)letter.compareTo(letter);for(Letterletter:I4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1066 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1067 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1068 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1069 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1070 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1071 =====
=====標準答案=====<BOM>按順序應為I4,j6,z2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1072 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"J4","b"};例如，本程式的MyMathUtil類別，需改成String[]M8={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1073 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.q1=q1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1074 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubley6,doublet3,doubleY2應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.y6=c2;bb.t3=b5;bb.Y2=M3;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.y6=c2;bb.t3=b5;bb.Y2=M3;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubley6,doublet3,doubleY2沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1075 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(O5)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1076 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.W8=W8this.j8=j8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1077 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringu3,Stringd7,StringJ8,Stringv0,StringQ0){super(u3,d7,J8,v0,Q0)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringu3,Stringd7,StringJ8,Stringv0,StringQ0){super(u3,d7,J8,v0,Q0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1078 =====
=====標準答案=====<BOM>按順序應為M3,m8,y1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1079 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1080 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1081 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成w0.equals("貓")，w0.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1082 =====
=====標準答案=====<BOM>變數名稱重複宣告U3[n1]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:U3[1],Integer.parseInt(U3[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1083 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1084 =====
=====標準答案=====<BOM>Envelop第10行z8.d3在呼叫z8物件中的物件資料時,應呼叫getSender()來回傳returnd3Envelop第11行的z8.c1/z8.x0與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1085 =====
=====標準答案=====<BOM>變數名稱V8重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(P9.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1086 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1087 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1088 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerf6=newScanner();intp=f6.nextInt();//讀取數值f6.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1089 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1090 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1091 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入v9.s7=2;v9.W3=2;v9.N2=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubles7=kb.nextDouble();doubleW3=kb.nextDouble();doubleN2=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1092 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:P7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1093 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1094 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成r3.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1095 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.n9=n9this.G0=G0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1096 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=b2,my=G0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1097 =====
=====標準答案=====<BOM>變數名稱P4重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(i5.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1098 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=S3.nextInt();doubley3=S3.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerS3=newScanner();intJ1=S3.nextInt();//讀取數值S3.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1099 =====
=====標準答案=====<BOM>StringB5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]B5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]A){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1100 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringF,Stringk2,StringX1,StringA0,StringA8){super(F,k2,X1,A0,A8)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringF,Stringk2,StringX1,StringA0,StringA8){super(F,k2,X1,A0,A8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1101 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringl4,Stringq,StringH1,StringM2,Stringy5){super(l4,q,H1,M2,y5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1102 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1103 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1104 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1105 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1106 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1107 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1108 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1109 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1110 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數w5會衝突,導致w5無法傳遞,建議在Class中宣告w5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intW=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1111 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1112 =====
=====標準答案=====<BOM>變數名稱重複宣告u8[R6]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:u8[1],Integer.parseInt(u8[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1113 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=L2.nextInt();doubleG7=L2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerL2=newScanner();intF2=L2.nextInt();//讀取數值L2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1114 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1115 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1116 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1117 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1118 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerm1=newScanner();intY=m1.nextInt();//讀取數值m1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為a6[E1]，若寫成a6[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1119 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringH4,Stringf0,StringS3,Stringi6,Stringz3){super(H4,f0,S3,i6,z3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1120 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1121 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);c3=scanner.nextInt();a1=scanner.nextInt();o3=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleQ7;publicdoubleP0;publicdoubleD3;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleQ7;publicdoubleP0;publicdoubleD3;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1122 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1123 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1124 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1125 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1126 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1127 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1128 =====
=====標準答案=====<BOM>按順序應為C1,W1,E6。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1129 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.y6=y6this.g=g<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1130 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerP4=newScanner();intq6=P4.nextInt();//讀取數值P4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為H4[c2]，若寫成H4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1131 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1132 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1133 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);D2=scanner.nextInt();m8=scanner.nextInt();t2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleZ5;publicdoubleh8;publicdoubleJ7;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleZ5;publicdoubleh8;publicdoubleJ7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1134 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1135 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterU2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");U2.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1136 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1137 =====
=====標準答案=====<BOM>C4變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperC4=newKeeper(...);PetR2=newPet(...,C4);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(K2.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringK2,StringU0,StringW8,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetR2=newPet(f3,U0,Y1,C4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1138 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1139 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringz3,Stringo7,StringB9,StringD5,StringY0){super(z3,o7,B9,D5,Y0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1140 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1141 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1142 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1143 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(S4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterD8=(Letter)other;returnE3.compareTo(D8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]N7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:N7)letter.compareTo(letter);for(Letterletter:N7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1144 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1145 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1146 =====
=====標準答案=====<BOM>按順序應為d6,g7,J0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1147 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1148 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringF2;...，此外，ChineseLetter與EnglishLetter就可以刪除StringF2;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1149 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]P2){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1150 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringw7,Stringj2,StringV8,Stringa,StringN7){super(w7,j2,V8,a,N7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1151 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]t7){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1152 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1153 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1154 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1155 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1156 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1157 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerj5=newScanner();intp=j5.nextInt();//讀取數值j5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1158 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1159 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"B9","b"};例如，本程式的MyMathUtil類別，需改成String[]A1={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1160 =====
=====標準答案=====<BOM>h9,U0變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperh9=newKeeper(...);PetD6=newPet(...,h9);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringP4,Stringt6,StringZ1,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetD6=newPet(P4,t6,Z1,h9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1161 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleC2,doubleP9,doubled7)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1162 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1163 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1164 =====
=====標準答案=====<BOM>L1變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(Y7,G5);透過Keeper建構子，將Y7與G5的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringn1,Stringz3,StringT2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1165 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1166 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的chineseletter與englishletter與letter就可刪除Stringtitle,...;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1167 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1168 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(s3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringM0,Stringj,StringC0,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1169 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1170 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:U6.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1171 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，F0,e5是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringF0;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1172 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1173 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行d5.A7在呼叫d5物件中的物件資料時,應呼叫getSender()來回傳returnA7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1174 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1175 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerb5=newScanner();intp=b5.nextInt();//讀取數值b5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1176 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringH6,Stringu6,Stringr0,StringK3,Stringb0){super(H6,u6,r0,K3,b0)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringH6,Stringu6,Stringr0,StringK3,Stringb0){super(H6,u6,r0,K3,b0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1177 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]k={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1178 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1179 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1180 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(s6,k3,y3);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1181 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1182 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入N3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1183 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如s1.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1184 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1185 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1186 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1187 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1188 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1189 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，M2.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1190 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如E1.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1191 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:V1.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1192 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"W5","b"};例如，本程式的MyMathUtil類別，需改成String[]K2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1193 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如D.equals("dog")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1194 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入p2.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1195 =====
=====標準答案=====<BOM>w3變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(C,j6);透過Keeper建構子，將C與j6的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringh,StringG2,StringV4,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1196 =====
=====標準答案=====<BOM>StringO5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]O5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]D5){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1197 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1198 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1199 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]p6){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1200 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1201 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1202 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:E5.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1203 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1204 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1205 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1206 =====
=====標準答案=====<BOM>變數名稱重複宣告h0[m5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:h0[1],Integer.parseInt(h0[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1207 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intC6){C6=3;returnC6;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleF1=X(S1);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1208 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1209 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1210 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=P3,my=m1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1211 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1212 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入i5.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1213 =====
=====標準答案=====<BOM>按順序應為v5,s8,a8。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1214 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=J0;tel=E6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1215 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterG8=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");G8.display();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1216 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringa6,StringS0,Stringu3,Stringn3,Stringd6){super(a6,S0,u3,n3,d6)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1217 =====
=====標準答案=====<BOM>x3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperx3=newKeeper(...);PetR2=newPet(...,x3);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(v4.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringL,StringD,Stringv4,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetR2=newPet(G6,Q5,J9,x3);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1218 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如M8.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1219 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1220 =====
=====標準答案=====<BOM>變數名稱O0重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1221 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=s3,my=j3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1222 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1223 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1224 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.k2;}publicStringgetTitle(){returnthis.r2;}//可取得U2publicStringgetReceiver(){returnthis.U2;}//可取得e0publicStringgetDate(){returnthis.e0;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1225 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1226 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1227 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1228 =====
=====標準答案=====<BOM>M6變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperN3=newKeeper(...);Petj2=newPet(...,N3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立M6物件變數的值，例如，publicPet(Stringj1,StringE,Stringg,KeeperM6){...this.M6=M6;}Pet建構子內已有M6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petj2=newPet(j1,E,g,N3);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1229 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1230 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleL5,doublei6,doublea9)publicstaticdoubleVolume(doubleL5,doublei6,doublea9)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleL5=scanner.nextDouble();System.out.println("輸入寬");doublei6=scanner.nextDouble();System.out.println("輸入高");doublea9=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.L5=L5;this.i6=i6;this.a9=a9;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1231 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1232 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublex8,doubleW1,doublep)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1233 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1234 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1235 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringL8,Stringe6,Stringl3,Stringp5,StringT7){super(L8,e6,l3,p5,T7)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringL8,Stringe6,Stringl3,Stringp5,StringT7){super(L8,e6,l3,p5,T7)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1236 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1237 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(h2+""+m+",您好");System.out.println(H4);System.out.println(i3+"敬上");System.out.println(j3);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1238 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如P0，z3，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1239 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1240 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1241 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如c9，m5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1242 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1243 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1244 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(T4,w1,q9);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1245 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublet0,doubleb4,doubleT3應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.t0=O0;bb.b4=i5;bb.T3=l3;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.t0=O0;bb.b4=i5;bb.T3=l3;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublet0,doubleb4,doubleT3沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1246 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如Z8，D0，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1247 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行y6.R0在呼叫y6物件中的物件資料時,應呼叫getSender()來回傳returnR0<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1248 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1249 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1250 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1251 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=b2,my=A2<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1252 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero5=newScanner();inti3=o5.nextInt();//讀取數值o5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為O5[M3]，若寫成O5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1253 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1254 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1255 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]J8){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1256 =====
=====標準答案=====<BOM>變數名稱x重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1257 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperB=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,B);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1258 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.z4=z4this.f0=f0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1259 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.W2=W2this.c3=c3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1260 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1261 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1262 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(t1.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1263 =====
=====標準答案=====<BOM>按順序應為x5,R4,Q2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1264 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1265 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1266 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringv9,StringC5,Stringb1,StringE7,StringS4){super(v9,C5,b1,E7,S4)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringv9,StringC5,Stringb1,StringE7,StringS4){super(v9,C5,b1,E7,S4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1267 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1268 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1269 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(D3)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1270 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1271 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1272 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);R1=scanner.nextInt();W5=scanner.nextInt();V3=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubled5;publicdoublea;publicdoubleP8;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubled5;publicdoublea;publicdoubleP8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1273 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1274 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(m9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettery1=(Letter)other;returnk5.compareTo(y1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]H8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:H8)letter.compareTo(letter);for(Letterletter:H8)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1275 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用K3.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.a9=a9;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1276 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"d6","b"};例如，本程式的MyMathUtil類別，需改成String[]f2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1277 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringk9,u,o,e7,w2;Letter(Stringk9,Stringu,Stringo,Stringe7,Stringw2){this.k9=k9;this.u=u;this.o=o;this.e7=e7;this.w2=w2;}publicStringgetSender(){returne7;}publicStringgetReceiver(){returnu;}publicStringgetDate(){returnw2;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1278 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]d8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1279 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnv;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1280 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1281 =====
=====標準答案=====<BOM>變數名稱J7重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1282 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，m4.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1283 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成m9.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1284 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2b5newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1285 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1286 =====
=====標準答案=====<BOM>按順序應為x3,P5,H。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1287 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.D0=D0this.p7=p7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1288 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1289 =====
=====標準答案=====<BOM>按順序應為c,X7,F4。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1290 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1291 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，T1,f9是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringT1;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1292 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.e9=e9;this.r2=r2;this.R=R;重複定義只需要returng=e9*r2*R;<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1293 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1294 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1295 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1296 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1297 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1298 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1299 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1300 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1301 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1302 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1303 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成v5.equals(word)。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1304 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1305 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerZ7=newScanner();intw4=Z7.nextInt();//讀取數值Z7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為Q3[Z0]，若寫成Q3[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1306 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1307 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1308 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1309 =====
=====標準答案=====<BOM>按順序應為L8,n2,j7。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1310 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:z9=newExam(k4,h,u4,c5,S6,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Q8){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1311 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=O2,my=T7<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1312 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.x=xthis.N4=N4<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1313 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1314 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.M9=M9this.u8=u8<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1315 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如L3.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1316 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1317 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1318 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1319 =====
=====標準答案=====<BOM>Envelop第10行h.U6在呼叫h物件中的物件資料時,應呼叫getSender()來回傳returnU6Envelop第11行的h.g0/h.A3與上述例子相同<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1320 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數定義後需要位義後需注意運算變數庫變數庫，如:inta;<EOM>
Meteor_Score : 0.0

===== 1321 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如g4，q4，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1322 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1323 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]W2={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1324 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Strings9,Stringf5,StringS8,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1325 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如F9，m1，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1326 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1327 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1328 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1329 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1330 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1331 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫D5中的物件動作來回傳值例:D5.getSender();而不是直接呼叫D5中的物件資料System.out.println("From:"+j6+","+D5.getSender());System.out.println("To:"+y9+","+D5.getReceiver()+""+D5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1332 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb,Stringj6,StringL,StringR6,Stringg1){super(b,j6,L,R6,g1)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringb,Stringj6,StringL,StringR6,Stringg1){super(b,j6,L,R6,g1)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1333 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，S6.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1334 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如b，O8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1335 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1336 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=i2,my=U1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1337 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1338 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringp7,StringM1,doublek0,doubleE5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(p7,M1,k0,E5);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1339 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1340 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1341 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1342 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(into3,...,Stringtestdate,...){super(o3,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1343 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringn9,Stringd1,Stringg,Stringd0,Stringf8){super(n9,d1,g,d0,f8)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1344 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1345 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1346 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1347 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringB,StringD4,Stringj4,StringJ6,StringB8){super(B,D4,j4,J6,B8)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringB,StringD4,Stringj4,StringJ6,StringB8){super(B,D4,j4,J6,B8)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1348 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringu1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1349 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]x0){l8.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1350 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1351 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，Q7,a1是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringQ7;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1352 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:V,D0,J5,F0為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:s7,F0為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:v3,j1為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:o1,b0為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 1353 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(e0,...);Keeperk=newKeeper(N6,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1354 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1355 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1356 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringq9,Stringd8,StringD4){this.q9=q9;this.d8=d8;this.D4=D4;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1357 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成X6.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1358 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1359 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1360 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1361 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);h1=scanner.nextInt();X4=scanner.nextInt();j=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublen2;publicdoublev9;publicdoubleO;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublen2;publicdoublev9;publicdoubleO;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1362 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1363 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.L9=L9;this.H=H;this.w8=w8;重複定義只需要returnn2=L9*H*w8;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1364 =====
=====標準答案=====<BOM>按順序應為g2,y8,G5。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1365 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1366 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1367 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1368 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1369 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1370 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如Z7.equals("dog")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1371 =====
=====標準答案=====<BOM>Stringd9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]d9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]l9){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1372 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1373 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1374 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]V6){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1375 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1376 =====
=====標準答案=====<BOM>j8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperj8=newKeeper(...);Petpet=newPet(...,j8);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetN4=newPet(j1,x3,m2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(m2.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立j8物件變數的值，例如，publicPet(Stringj1,Stringx3,Stringm2,Keeperj8){...this.j8=j8;}Pet建構子內已有j8參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetN4=newPet(j1,x3,m2,E3);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫j8.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...j8.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1377 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1378 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1379 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannera5=newScanner();intM3=a5.nextInt();//讀取數值a5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為K1[a3]，若寫成K1[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1380 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1381 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerT1=newScanner();intp=T1.nextInt();//讀取數值T1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1382 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1383 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublew6=X(T2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1384 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanners5=newScanner();intX7=s5.nextInt();//讀取數值s5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為c8[r0]，若寫成c8[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1385 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1386 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=a3,my=u2<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1387 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1388 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1389 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"a6","b"};例如，本程式的MyMathUtil類別，需改成String[]q7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1390 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=u7.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1391 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerN6=newScanner();intj1=N6.nextInt();//讀取數值N6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為e4[Y8]，若寫成e4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1392 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1393 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q5.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterL8=(Letter)other;returnG1.compareTo(L8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]o6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:o6)letter.compareTo(letter);for(Letterletter:o6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1394 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1395 =====
=====標準答案=====<BOM>Stringq0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]q0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]z2){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1396 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerj2=newScanner();intp=j2.nextInt();//讀取數值j2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1397 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.e5=e5;this.F6=F6;this.q6=q6;重複定義只需要returnA3=e5*F6*q6;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1398 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫H3中的物件動作來回傳值例:H3.getSender();而不是直接呼叫H3中的物件資料System.out.println("From:"+x9+","+H3.getSender());System.out.println("To:"+b0+","+H3.getReceiver()+""+H3.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1399 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1400 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1401 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入n6.A1=2;n6.j1=2;n6.Z4=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleA1=kb.nextDouble();doublej1=kb.nextDouble();doubleZ4=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1402 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1403 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1404 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringQ8,Stringy6,Stringd5,Stringw1,Stringv3){super(Q8,y6,d5,w1,v3)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringQ8,Stringy6,Stringd5,Stringw1,Stringv3){super(Q8,y6,d5,w1,v3)}}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1405 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如T6，T5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1406 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp6,StringU3,StringD0,StringZ4,Stringb){super(p6,U3,D0,Z4,b)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringp6,StringU3,StringD0,StringZ4,Stringb){super(p6,U3,D0,Z4,b)}}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1407 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1408 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]f2){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1409 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如n7=i;應改成i=n7;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1410 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=c3;tel=z0;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1411 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1412 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1413 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1414 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intN1=1;類別動作(N1);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1415 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1416 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.P9=P9this.l9=l9<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1417 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1418 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1419 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1420 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1421 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.K8;}publicStringgetTitle(){returnthis.F5;}//可取得L1publicStringgetReceiver(){returnthis.L1;}//可取得G1publicStringgetDate(){returnthis.G1;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1422 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringp;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringp;...<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1423 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.P3=P3this.V9=V9<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1424 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1425 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1426 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(P1.equals("貓"))<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1427 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1428 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行H7.R7在呼叫H7物件中的物件資料時,應呼叫getSender()來回傳returnR7<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1429 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(W6)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1430 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1431 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1432 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1433 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如g4.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1434 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1435 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxn0=newKKBOx(l,w,h);呼叫時可用n0.volume();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1436 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1437 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1438 =====
=====標準答案=====<BOM>變數名稱r9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1439 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1440 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:U5.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1441 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1442 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1443 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1444 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(t6.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringy7,StringZ)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將t6.Speak()改為k0.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperk0=newKeeper(y7,Z);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringt6,Stringx0,Stringy5,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1445 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1446 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1447 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，R變數型態為Int，F3變數型態為Int，n4變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:m3,t1為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1448 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1449 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnSurfaceArea=2*(length*width+width*height+length*height);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(length*width+width*height+height*length);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnlength*width*height;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.length=sc.nextDouble();System.out.print("輸入寬度:");box.width=sc.nextDouble();System.out.print("輸入高度:");box.height=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("SurfaceArea:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(length*width+width*height+height*length);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnlength*width*height;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.length=sc.nextDouble();System.out.print("輸入寬度:");box.width=sc.nextDouble();System.out.print("輸入高度:");box.height=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("SurfaceArea:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1450 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(e1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]T1){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1451 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"U0","b"};例如，本程式的MyMathUtil類別，需改成String[]D={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1452 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperO=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,O);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1453 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k0，r9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1454 =====
=====標準答案=====<BOM>t8,T7變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepert8=newKeeper(...);Petc1=newPet(...,t8);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringx2,StringQ6,Stringp,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petc1=newPet(x2,Q6,p,t8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1455 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc9,StringT4,Stringt0,Stringd3,Stringn5){super(c9,T4,t0,d3,n5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1456 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb8,StringY0,StringS8,Strings4,StringK2){super(b8,Y0,S8,s4,K2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1457 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerT1=newScanner();intp=T1.nextInt();//讀取數值T1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1458 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(G2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterx3=(Letter)other;returnG9.compareTo(x3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]d0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:d0)letter.compareTo(letter);for(Letterletter:d0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1459 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1460 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1461 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1462 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1463 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1464 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1465 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫M7中的物件動作來回傳值例:M7.getSender();而不是直接呼叫M7中的物件資料System.out.println("From:"+M0+","+M7.getSender());System.out.println("To:"+u9+","+M7.getReceiver()+""+M7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1466 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，E,w6是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringE;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1467 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]b2={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1468 =====
=====標準答案=====<BOM>D1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperD1=newKeeper(...);Petz0=newPet(...,D1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(n7.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringn7,Stringp2,Stringg0,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petz0=newPet(p5,p2,g9,D1);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1469 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringX0,Stringp7,Stringp1){this.X0=X0;this.p7=p7;this.p1=p1;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1470 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，x4.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行m8m8:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1471 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1472 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1473 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1474 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數I1會衝突,導致I1無法傳遞,建議在Class中宣告I1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intG=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1475 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成g2.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1476 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1477 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intj4=1;類別動作(j4);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1478 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1479 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1480 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1481 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2F4newExam2();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1482 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(v3),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]f6){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1483 =====
=====標準答案=====<BOM>Envelop第10行u8.q9在呼叫u8物件中的物件資料時,應呼叫getSender()來回傳returnq9Envelop第11行的u8.r7/u8.u0與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1484 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1485 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1486 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫B5中的物件動作來回傳值例:B5.getSender();而不是直接呼叫B5中的物件資料System.out.println("From:"+d7+","+B5.getSender());System.out.println("To:"+O0+","+B5.getReceiver()+""+B5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1487 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1488 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1489 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1490 =====
=====標準答案=====<BOM>a9變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperg1=newKeeper(...);PetZ7=newPet(...,g1);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立a9物件變數的值，例如，publicPet(Stringe4,Stringu5,Stringu6,Keepera9){...this.a9=a9;}Pet建構子內已有a9參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetZ7=newPet(e4,u5,u6,g1);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1491 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleK8=X(F9);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1492 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intV9){V9=3;returnV9;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleY7=X(w6);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1493 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"O1","b"};例如，本程式的MyMathUtil類別，需改成String[]a0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1494 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1495 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1496 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1497 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1498 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1499 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1500 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublex7,doubleA9,doublef2)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1501 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1502 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1503 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.y4=y4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1504 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1505 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1506 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1507 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringG0,Stringf0,StringC8,StringP2,StringW5){super(G0,f0,C8,P2,W5)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1508 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(s2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterc6=(Letter)other;returnk8.compareTo(c6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t3)letter.compareTo(letter);for(Letterletter:t3)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1509 =====
=====標準答案=====<BOM>變數名稱L重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1510 =====
=====標準答案=====<BOM>按順序應為M6,c3,y3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1511 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1512 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.b0;}publicStringgetTitle(){returnthis.G0;}//可取得B2publicStringgetReceiver(){returnthis.B2;}//可取得j0publicStringgetDate(){returnthis.j0;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1513 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1514 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.m4=m4<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1515 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1516 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxl0=newKKBOx(l,w,h);呼叫時可用l0.volume();<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1517 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:Q1.display();<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1518 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1519 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=X3,my=y9<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1520 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1521 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1522 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1523 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1524 =====
=====標準答案=====<BOM>按順序應為s9,V1,A8。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1525 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如J4，a8，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterc4=(EnglishLetter)Q2;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectc4){LetterQ2=(Letter)c4;returnW9.compareTo(Q2.getDate());}先將原本宣告成Object的Q2強制轉換成Letter類別型態這樣Q2就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1526 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1527 =====
=====標準答案=====<BOM>按順序應為a0,p8,N7。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1528 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringC1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1529 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1530 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1531 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:B9.display();<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1532 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]T){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1533 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.h3=h3this.R6=R6<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1534 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1535 =====
=====標準答案=====<BOM>變數名稱重複宣告v[b0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:v[1],Integer.parseInt(v[2])<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1536 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用r7.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.u=u;...}<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1537 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1538 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]U9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1539 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1540 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1541 =====
=====標準答案=====<BOM>按順序應為d4,J2,V5。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1542 =====
=====標準答案=====<BOM>i4,z變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperi4=newKeeper(...);PetI9=newPet(...,i4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringO3,Stringi,StringC3,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetI9=newPet(O3,i,C3,i4);<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1543 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1544 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxo3=newKKBOx(l,w,h);呼叫時可用o3.volume();<EOM>
=====預測答案=====<BOM>引用函數與稱=.}請注意算JAVA程式的比較輸種運算結構。<EOM>
Meteor_Score : 0.0

===== 1545 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=e7.nextInt();doublev7=e7.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannere7=newScanner();intd7=e7.nextInt();//讀取數值e7.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1546 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1547 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(T4.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringf,StringG2,StringT4,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1548 =====
=====標準答案=====<BOM>按順序應為W1,r4,I3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1549 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(r.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterR1=(Letter)other;returna6.compareTo(R1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t6)letter.compareTo(letter);for(Letterletter:t6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1550 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=C7.nextInt();doubleR2=C7.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerC7=newScanner();intt5=C7.nextInt();//讀取數值C7.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1551 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannery3=newScanner();intp=y3.nextInt();//讀取數值y3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1552 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(m2),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o4){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1553 =====
=====標準答案=====<BOM>Envelop第10行Z3.n9在呼叫Z3物件中的物件資料時,應呼叫getSender()來回傳returnn9Envelop第11行的Z3.t7/Z3.L8與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1554 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的R2物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1555 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1556 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1557 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1558 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1559 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1560 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]B){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1561 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的O7物件資料所以在呼叫O7的物件動作的時候應加上System.out.println("From:"+Z2+","+O7.getSender());System.out.println("To:"+C+","+O7.getReceiver()+""+O7.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1562 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]r4){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1563 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=n6;tel=R9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1564 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1565 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV8=newScanner();intp=V8.nextInt();//讀取數值V8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1566 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h1,my=E6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1567 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringh4="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1568 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1569 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(Y3,u5,O9);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1570 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1571 =====
=====標準答案=====<BOM>變數名稱k9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1572 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);P3=scanner.nextInt();y3=scanner.nextInt();m3=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublep3;publicdoubleC0;publicdoubleH5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublep3;publicdoubleC0;publicdoubleH5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1573 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=s5;tel=M2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1574 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]Y2){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1575 =====
=====標準答案=====<BOM>變數名稱J8重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1576 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringe,C4,Z3,k1,f2;Letter(Stringe,StringC4,StringZ3,Stringk1,Stringf2){this.e=e;this.C4=C4;this.Z3=Z3;this.k1=k1;this.f2=f2;}publicStringgetSender(){returnk1;}publicStringgetReceiver(){returnC4;}publicStringgetDate(){returnf2;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1577 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1578 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1579 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.c=cthis.n4=n4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1580 =====
=====標準答案=====<BOM>s6,N8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepers6=newKeeper(...);Petf=newPet(...,s6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringW8,Stringd5,Stringm5,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petf=newPet(W8,d5,m5,s6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1581 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1582 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1583 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1584 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1585 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=e8,my=x7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1586 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1587 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1588 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如y，F2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1589 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1590 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1591 =====
=====標準答案=====<BOM>N8變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperm8=newKeeper(...);Petq8=newPet(...,m8);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立N8物件變數的值，例如，publicPet(StringQ5,StringE4,Stringc0,KeeperN8){...this.N8=N8;}Pet建構子內已有N8參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petq8=newPet(Q5,E4,c0,m8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1592 =====
=====標準答案=====<BOM>變數名稱b1重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(j8.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1593 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringr2,StringU6,StringD4,Strings4,Stringt4){super(r2,U6,D4,s4,t4)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringr2,StringU6,StringD4,Strings4,Stringt4){super(r2,U6,D4,s4,t4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1594 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1595 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1596 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成u.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1597 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1598 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxD2=newKKBOx(l,w,h);呼叫時可用D2.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1599 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(L0.equals("狗"))<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1600 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1601 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:f8=newExam(K5,A3,U6,f1,u,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]i2){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1602 =====
=====標準答案=====<BOM>按順序應為J8,A5,s1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1603 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=A3.getSender();StringReceiver=A3.getReceiver();StringTitle=A3.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1604 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，H8變數型態為Int，L6變數型態為Int，R5變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:k3,Q5為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1605 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=Y2.nextInt();doubleE=Y2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerY2=newScanner();inte8=Y2.nextInt();//讀取數值Y2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1606 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1607 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入V.e8=2;V.M4=2;V.j1=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublee8=kb.nextDouble();doubleM4=kb.nextDouble();doublej1=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1608 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1609 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringb7,r4,U8,c,y0;Letter(Stringb7,Stringr4,StringU8,Stringc,Stringy0){this.b7=b7;this.r4=r4;this.U8=U8;this.c=c;this.y0=y0;}publicStringgetSender(){returnc;}publicStringgetReceiver(){returnr4;}publicStringgetDate(){returny0;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1610 =====
=====標準答案=====<BOM>按順序應為T3,J3,w4。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1611 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterf1=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1612 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:z6.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1613 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringj1,StringV1,Stringe9,Stringn8,StringY3){super(j1,V1,e9,n8,Y3)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1614 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleC4=X(o3);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1615 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，m1.equals("貓")，m1.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1616 =====
=====標準答案=====<BOM>變數名稱V重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1617 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=L7;tel=j2;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1618 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1619 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入w4.w0=2;w4.s9=2;w4.L8=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublew0=kb.nextDouble();doubles9=kb.nextDouble();doubleL8=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1620 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如f8，i6，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1621 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數X會衝突,導致X無法傳遞,建議在Class中宣告X即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intS2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1622 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringy4="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1623 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1624 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1625 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1626 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.t9=t9this.j=j<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1627 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1628 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);b7=scanner.nextInt();s9=scanner.nextInt();O1=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublet;publicdoubleh1;publicdoublei2;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublet;publicdoubleh1;publicdoublei2;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1629 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"V7","b"};例如，本程式的MyMathUtil類別，需改成String[]K6={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1630 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1631 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1632 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1633 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]d8){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1634 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1635 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1636 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1637 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入a9.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1638 =====
=====標準答案=====<BOM>按順序應為e5,o7,g3。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1639 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1640 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=p,my=Y3<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1641 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1642 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=U5,my=Z9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1643 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1644 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1645 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1646 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如g0=i;應改成i=g0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1647 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1648 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h7,my=o7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1649 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringB7,StringL2,Stringh7,StringE8,StringS6){super(B7,L2,h7,E8,S6)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringB7,StringL2,Stringh7,StringE8,StringS6){super(B7,L2,h7,E8,S6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1650 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1651 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringX,e4,W7,w4,J2;Letter(StringX,Stringe4,StringW7,Stringw4,StringJ2){this.X=X;this.e4=e4;this.W7=W7;this.w4=w4;this.J2=J2;}publicStringgetSender(){returnw4;}publicStringgetReceiver(){returne4;}publicStringgetDate(){returnJ2;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1652 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1653 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1654 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb3,StringS,StringD2,StringB1,Stringy4){super(b3,S,D2,B1,y4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1655 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerR0=newScanner();intp=R0.nextInt();//讀取數值R0.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1656 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1657 =====
=====標準答案=====<BOM>StringM9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]M9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]y){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1658 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1659 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如F8，i1，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1660 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1661 =====
=====標準答案=====<BOM>按順序應為b6,n5,O7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1662 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1663 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1664 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.N=Nthis.O=O<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1665 =====
=====標準答案=====<BOM>變數名稱重複宣告g2[r3]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g2[1],Integer.parseInt(g2[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1666 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.W8=W8this.z6=z6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1667 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1668 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1669 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1670 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫t0中的物件動作來回傳值例:t0.getSender();而不是直接呼叫t0中的物件資料System.out.println("From:"+H5+","+t0.getSender());System.out.println("To:"+w6+","+t0.getReceiver()+""+t0.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1671 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1672 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1673 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1674 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1675 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1676 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(m2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterq1=(Letter)other;returnK9.compareTo(q1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]A4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:A4)letter.compareTo(letter);for(Letterletter:A4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1677 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1678 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1679 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1680 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1681 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1682 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1683 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringH3,Stringp4,Stringa,Stringl0,StringW6){super(H3,p4,a,l0,W6)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1684 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1685 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(G5,...);Keeperk=newKeeper(R9,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1686 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:z1=newExam(s2,f4,R8,B,l9,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]q4){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1687 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(g5,...);Keeperk=newKeeper(J9,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1688 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1689 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]E9){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1690 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intN9=1;類別動作(N9);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1691 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1692 =====
=====標準答案=====<BOM>Envelop第10行x.J6在呼叫x物件中的物件資料時,應呼叫getSender()來回傳returnJ6Envelop第11行的x.K9/x.J9與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1693 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1694 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(l8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]n5){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1695 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1696 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.K1=K1;this.Y7=Y7;this.L1=L1;重複定義只需要returne0=K1*Y7*L1;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1697 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的b物件資料所以在呼叫b的物件動作的時候應加上System.out.println("From:"+I0+","+b.getSender());System.out.println("To:"+i4+","+b.getReceiver()+""+b.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1698 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1699 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如pid.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1700 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2e7newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1701 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublei1,doubleo7,doublea7)publicstaticdoubleVolume(doublei1,doubleo7,doublea7)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublei1=scanner.nextDouble();System.out.println("輸入寬");doubleo7=scanner.nextDouble();System.out.println("輸入高");doublea7=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.i1=i1;this.o7=o7;this.a7=a7;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1702 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1703 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1704 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1705 =====
=====標準答案=====<BOM>按順序應為q2,M0,q8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1706 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，z7變數型態為Int，K8變數型態為Int，I4變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:i1,f9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1707 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1708 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1709 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1710 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.s4=s4;this.e=e;this.g0=g0;重複定義只需要returnj0=s4*e*g0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1711 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringf0,StringX0,Stringf1,Strings6,Stringx2){super(f0,X0,f1,s6,x2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1712 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1713 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1714 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1715 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數h5會衝突,導致h5無法傳遞,建議在Class中宣告h5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intZ0=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1716 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1717 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入Z4.v0=2;Z4.f7=2;Z4.g6=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublev0=kb.nextDouble();doublef7=kb.nextDouble();doubleg6=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1718 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnf9;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1719 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]R6){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1720 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的r4物件資料所以在呼叫r4的物件動作的時候應加上System.out.println("From:"+n8+","+r4.getSender());System.out.println("To:"+e1+","+r4.getReceiver()+""+r4.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1721 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1722 =====
=====標準答案=====<BOM>按順序應為R9,r4,t0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1723 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=r6.nextInt();doubleD8=r6.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr6=newScanner();intO7=r6.nextInt();//讀取數值r6.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1724 =====
=====標準答案=====<BOM>T1,U5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperT1=newKeeper(...);Petn7=newPet(...,T1);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringU8,Stringb7,StringQ1,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petn7=newPet(U8,b7,Q1,T1);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1725 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(g7),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]I4){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1726 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringi4,StringW,Strings7,Stringg0,Stringp1){super(i4,W,s7,g0,p1)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1727 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.x0=x0;this.o3=o3;this.m4=m4;重複定義只需要returnk3=x0*o3*m4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1728 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleW6=X(i2);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1729 =====
=====標準答案=====<BOM>z5,Q變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperz5=newKeeper(...);PetK5=newPet(...,z5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringX9,Stringf0,StringJ8,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetK5=newPet(X9,f0,J8,z5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1730 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intu=1;類別動作(u);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1731 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringr8,StringF8,StringZ5,StringE2,Stringg5){super(r8,F8,Z5,E2,g5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1732 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1733 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1734 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]T9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1735 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1736 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1737 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1738 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1739 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的M9物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1740 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1741 =====
=====標準答案=====<BOM>Stringd9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]d9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]A4){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1742 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1743 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1744 =====
=====標準答案=====<BOM>按順序應為I7,Y9,J1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1745 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleC4,doubleb9,doubled應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.C4=R;bb.b9=g8;bb.d=i9;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.C4=R;bb.b9=g8;bb.d=i9;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleC4,doubleb9,doubled沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1746 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(z0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh9=(Letter)other;returnC7.compareTo(h9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]M4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:M4)letter.compareTo(letter);for(Letterletter:M4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1747 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(o1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]H1){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1748 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]h1){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1749 =====
=====標準答案=====<BOM>StringO0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]O0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]P4){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1750 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]v2){H5.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1751 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperZ5=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,Z5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1752 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1753 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1754 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行s8.Z0在呼叫s8物件中的物件資料時,應呼叫getSender()來回傳returnZ0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1755 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1756 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.m8=m8this.w1=w1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1757 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]l7){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1758 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1759 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入r8.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1760 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperx=newKeeper(...);Pets9=newPet(...,x);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(j5.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringj5,StringO2,StringM1,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Pets9=newPet(d2,O2,Z2,x);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1761 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1762 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=Y6,my=a<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1763 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入P2.X2=2;P2.Q3=2;P2.c4=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleX2=kb.nextDouble();doubleQ3=kb.nextDouble();doublec4=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1764 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1765 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1766 =====
=====標準答案=====<BOM>按順序應為A0,o8,Z4。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1767 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc0,StringB,Stringw1,StringE5,StringQ0){super(c0,B,w1,E5,Q0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1768 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringf6="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1769 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetteru2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");u2.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1770 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1771 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1772 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1773 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1774 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1775 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1776 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1777 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerY9=newScanner();intp=Y9.nextInt();//讀取數值Y9.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1778 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleW2=X(m2);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1779 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1780 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1781 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1782 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數b2會衝突,導致b2無法傳遞,建議在Class中宣告b2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intN1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1783 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1784 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如M1，e4，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterL0=(EnglishLetter)B4;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectL0){LetterB4=(Letter)L0;returnE1.compareTo(B4.getDate());}先將原本宣告成Object的B4強制轉換成Letter類別型態這樣B4就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1785 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]k2){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1786 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc4,Stringk5,Stringt9,StringI1,Strings4){super(c4,k5,t9,I1,s4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1787 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1788 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1789 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringD4="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1790 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1791 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationg7=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationg7;g7=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1792 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringu0,e9,R8,i5,E9;Letter(Stringu0,Stringe9,StringR8,Stringi5,StringE9){this.u0=u0;this.e9=e9;this.R8=R8;this.i5=i5;this.E9=E9;}publicStringgetSender(){returni5;}publicStringgetReceiver(){returne9;}publicStringgetDate(){returnE9;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1793 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1794 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1795 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1796 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1797 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringT9,StringR9,Stringj4,Stringo5,StringK9){super(T9,R9,j4,o5,K9)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1798 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringA="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1799 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1800 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如ints4=1;類別動作(s4);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1801 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如E1.equals("貓")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1802 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如h9，T0，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterf2=(EnglishLetter)D;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectf2){LetterD=(Letter)f2;returnp9.compareTo(D.getDate());}先將原本宣告成Object的D強制轉換成Letter類別型態這樣D就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1803 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"M8","b"};例如，本程式的MyMathUtil類別，需改成String[]n0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1804 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]z9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1805 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"x4","b"};例如，本程式的MyMathUtil類別，需改成String[]U7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1806 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringU0,StringS3,StringD5,Stringw9,StringY4){super(U0,S3,D5,w9,Y4)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1807 =====
=====標準答案=====<BOM>a,b變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepera=newKeeper(...);Petx=newPet(...,a);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringp,Stringn,Stringt,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petx=newPet(p,n,t,a);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1808 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數b5會衝突,導致b5無法傳遞,建議在Class中宣告b5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intU8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1809 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=H3;tel=J3;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1810 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1811 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]z0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1812 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]v4){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1813 =====
=====標準答案=====<BOM>變數名稱重複宣告g6[p1]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g6[1],Integer.parseInt(g6[2])<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1814 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如E1，v4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1815 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成m.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1816 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1817 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1818 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫i5中的物件動作來回傳值例:i5.getSender();而不是直接呼叫i5中的物件資料System.out.println("From:"+u1+","+i5.getSender());System.out.println("To:"+C6+","+i5.getReceiver()+""+i5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1819 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1820 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1821 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringM1,Stringf3,Stringn3,Stringa9,StringY1){super(M1,f3,n3,a9,Y1)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringM1,Stringf3,Stringn3,Stringa9,StringY1){super(M1,f3,n3,a9,Y1)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1822 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intr8){...returnr8;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublez7=X(F0);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1823 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1824 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.X8=X8;this.V5=V5;this.R8=R8;重複定義只需要returnD=X8*V5*R8;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1825 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]J0){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1826 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterN1=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");N1.display();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1827 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1828 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1829 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1830 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用H9.display()顯示內容，此外Q8.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1831 =====
=====標準答案=====<BOM>變數名稱p9重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1832 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=g3,my=d4<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1833 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1834 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringm,StringE5,Stringr7,Stringr9,Stringq5){super(m,E5,r7,r9,q5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1835 =====
=====標準答案=====<BOM>按順序應為Z2,W2,H3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1836 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(e1.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringx0,Stringz6)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將e1.Speak()改為V3.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperV3=newKeeper(x0,z6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringe1,StringH,StringE,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1837 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1838 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubled7,doubleV,doubleN8)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1839 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringD8,v2,v4,D2,y4;Letter(StringD8,Stringv2,Stringv4,StringD2,Stringy4){this.D8=D8;this.v2=v2;this.v4=v4;this.D2=D2;this.y4=y4;}publicStringgetSender(){returnD2;}publicStringgetReceiver(){returnv2;}publicStringgetDate(){returny4;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1840 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(B.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterK5=(Letter)other;returnG0.compareTo(K5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]q={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:q)letter.compareTo(letter);for(Letterletter:q)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1841 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleB7,doubleG0,doublep1)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1842 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1843 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的G6與englishletter與letter就可刪除Stringc0,...;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1844 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1845 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1846 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1847 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1848 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入b2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1849 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]b3){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1850 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如g4=i;應改成i=g4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1851 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1852 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerS8=newScanner();intp=S8.nextInt();//讀取數值S8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1853 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1854 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1855 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1856 =====
=====標準答案=====<BOM>Envelop第10行o6.o3在呼叫o6物件中的物件資料時,應呼叫getSender()來回傳returno3Envelop第11行的o6.g1/o6.m2與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1857 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行o7.n7在呼叫o7物件中的物件資料時,應呼叫getSender()來回傳returnn7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1858 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如b5，I2，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1859 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1860 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1861 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1862 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數Y6會衝突,導致Y6無法傳遞,建議在Class中宣告Y6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intd=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1863 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1864 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterZ1=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1865 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成F9.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1866 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入a5.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1867 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1868 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]O7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1869 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1870 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1871 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1872 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1873 =====
=====標準答案=====<BOM>Stringr0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]r0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]F6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1874 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如q7，j5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1875 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1876 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]F9={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1877 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1878 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1879 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1880 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1881 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringa,Stringp,StringH9,Strings5,StringX2){super(a,p,H9,s5,X2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1882 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringn9,StringL0,StringC0,Stringl2,StringN1){super(n9,L0,C0,l2,N1)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1883 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1884 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1885 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入y3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1886 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:O.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1887 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1888 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(N5),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]E7){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1889 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1890 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1891 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1892 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=X5,my=S8<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1893 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入g9.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1894 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1895 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1896 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1897 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1898 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringe8,k4,Z7,p4,i;Letter(Stringe8,Stringk4,StringZ7,Stringp4,Stringi){this.e8=e8;this.k4=k4;this.Z7=Z7;this.p4=p4;this.i=i;}publicStringgetSender(){returnp4;}publicStringgetReceiver(){returnk4;}publicStringgetDate(){returni;}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1899 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1900 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數V7會衝突,導致V7無法傳遞,建議在Class中宣告V7即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intG0=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1901 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1902 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1903 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成R6.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1904 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerO3=newScanner();intp=O3.nextInt();//讀取數值O3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1905 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnf5=2*(f8*t3+t3*g0+f8*g0);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(f8*t3+t3*g0+g0*f8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnf8*t3*g0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.f8=sc.nextDouble();System.out.print("輸入寬度:");box.t3=sc.nextDouble();System.out.print("輸入高度:");box.g0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("f5:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(f8*t3+t3*g0+g0*f8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnf8*t3*g0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.f8=sc.nextDouble();System.out.print("輸入寬度:");box.t3=sc.nextDouble();System.out.print("輸入高度:");box.g0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("f5:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1906 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1907 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1908 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letteri9=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1909 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1910 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1911 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1912 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1913 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"O","b"};例如，本程式的MyMathUtil類別，需改成String[]s7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1914 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1915 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1916 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intW7){...returnW7;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublei5=X(F7);<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1917 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1918 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1919 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如p7.equals("dog")。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1920 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1921 =====
=====標準答案=====<BOM>變數名稱Y0重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1922 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1923 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intn6){n6=3;returnn6;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublen1=X(c5);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1924 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1925 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1926 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.u9=u9this.b4=b4<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1927 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行u.Z3在呼叫u物件中的物件資料時,應呼叫getSender()來回傳returnZ3<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1928 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 1929 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1930 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1931 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1932 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1933 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1934 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1935 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]S={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1936 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1937 =====
=====標準答案=====<BOM>變數名稱重複宣告g7[d0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g7[1],Integer.parseInt(g7[2])<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1938 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1939 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1940 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1941 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(c5.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringY5,StringV3)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將c5.Speak()改為e1.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keepere1=newKeeper(Y5,V3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringc5,Stringt9,StringT1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1942 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=T2,my=o5<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1943 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1944 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]F8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1945 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1946 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringi5,StringV7,StringA3,StringP1){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(i5,V7,A3,P1);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1947 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]C5){s5.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1948 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(z9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letters9=(Letter)other;returnU7.compareTo(s9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]W6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:W6)letter.compareTo(letter);for(Letterletter:W6)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1949 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1950 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2T1newExam2();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1951 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1952 =====
=====標準答案=====<BOM>按順序應為N,K5,V7。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1953 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1954 =====
=====標準答案=====<BOM>變數名稱P9重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1955 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1956 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"s0","b"};例如，本程式的MyMathUtil類別，需改成String[]W0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1957 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1958 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1959 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1960 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>width點稱=0,0.!陣列誤，。<EOM>
Meteor_Score : 0.0

===== 1961 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1962 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1963 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringL6,StringZ3,Stringu7){this.L6=L6;this.Z3=Z3;this.u7=u7;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1964 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1965 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入L7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1966 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1967 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1968 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringd8="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1969 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1970 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.M7=M7this.X3=X3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1971 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1972 =====
=====標準答案=====<BOM>t4,H4變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepert4=newKeeper(...);Petq1=newPet(...,t4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringM1,StringO0,Stringb6,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petq1=newPet(M1,O0,b6,t4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1973 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1974 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]w){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1975 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1976 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intb9){b9=3;returnb9;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleO0=X(J3);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1977 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1978 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如j7，S6，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1979 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1980 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1981 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Strings0,Stringo5,StringD2,Stringf,StringD5){super(s0,o5,D2,f,D5)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Strings0,Stringo5,StringD2,Stringf,StringD5){super(s0,o5,D2,f,D5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1982 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1983 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1984 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(M0.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(Stringh,StringT6,StringM0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1985 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1986 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1987 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1988 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1989 =====
=====標準答案=====<BOM>按順序應為L6,J3,r5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1990 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫Q8中的物件動作來回傳值例:Q8.getSender();而不是直接呼叫Q8中的物件資料System.out.println("From:"+F4+","+Q8.getSender());System.out.println("To:"+j1+","+Q8.getReceiver()+""+Q8.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1991 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1992 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1993 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1994 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1995 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1996 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1997 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW,StringY2,StringF2,Stringo6,Stringw2){super(W,Y2,F2,o6,w2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1998 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr7=newScanner();intp=r7.nextInt();//讀取數值r7.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1999 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.V=V<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2000 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intR9){...returnR9;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublem9=X(w);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2001 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp8,StringF9,StringH1,StringD2,Stringa){super(p8,F9,H1,D2,a)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2002 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationo2=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationo2;o2=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2003 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，F4.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行N8N8:<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2004 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]p9){D9.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2005 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2006 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2007 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2008 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2009 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.f4=f4this.M4=M4<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2010 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k9,my=F8<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2011 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2012 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如V1，h4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2013 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2014 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]g0){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2015 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringd7,StringX0,StringW,StringQ4){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(d7,X0,W,Q4);<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2016 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2017 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2018 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=G0,my=T6<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2019 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr=newScanner();intp=r.nextInt();//讀取數值r.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2020 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);c8=scanner.nextInt();L9=scanner.nextInt();R6=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleM9;publicdoublew7;publicdoublem4;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleM9;publicdoublew7;publicdoublem4;<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2021 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2022 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2023 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannery8=newScanner();intp=y8.nextInt();//讀取數值y8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2024 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2025 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2026 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2027 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2028 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(v5,...);Keeperk=newKeeper(s6,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2029 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2030 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2031 =====
=====標準答案=====<BOM>按順序應為J9,S2,r0。<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2032 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnH9=2*(l8*z7+z7*t4+l8*t4);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(l8*z7+z7*t4+t4*l8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnl8*z7*t4;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.l8=sc.nextDouble();System.out.print("輸入寬度:");box.z7=sc.nextDouble();System.out.print("輸入高度:");box.t4=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("H9:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(l8*z7+z7*t4+t4*l8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnl8*z7*t4;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.l8=sc.nextDouble();System.out.print("輸入寬度:");box.z7=sc.nextDouble();System.out.print("輸入高度:");box.t4=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("H9:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2033 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數定義後需要初始位義後需要化,需要化,需先誤對給於函數庫變數名稱物件的庫應在算為Keeper物件，因為Keeper予函數型態參數值,例如:下:intp=newthis.}<EOM>
Meteor_Score : 0.0

===== 2034 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2035 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2036 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]u7){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2037 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringA0,R5,t7,T9,k3;Letter(StringA0,StringR5,Stringt7,StringT9,Stringk3){this.A0=A0;this.R5=R5;this.t7=t7;this.T9=T9;this.k3=k3;}publicStringgetSender(){returnT9;}publicStringgetReceiver(){returnR5;}publicStringgetDate(){returnk3;}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2038 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入G2.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2039 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2040 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2041 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]r8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2042 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(D0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterx4=(Letter)other;returnq7.compareTo(x4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]v2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:v2)letter.compareTo(letter);for(Letterletter:v2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2043 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2044 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2045 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2046 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.A0=A0<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2047 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數E3會衝突,導致E3無法傳遞,建議在Class中宣告E3即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intJ3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2048 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(h.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterC2=(Letter)other;returnX.compareTo(C2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]o1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:o1)letter.compareTo(letter);for(Letterletter:o1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2049 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2050 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerE5=newScanner();intp=E5.nextInt();//讀取數值E5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2051 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublev0,doubleb6,doublec8應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.v0=G0;bb.b6=I0;bb.c8=i2;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.v0=G0;bb.b6=I0;bb.c8=i2;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublev0,doubleb6,doublec8沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2052 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]G0={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2053 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2054 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterz2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");z2.display();}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2055 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2f9newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2056 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperR=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,R);<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2057 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2058 =====
=====標準答案=====<BOM>變數名稱E重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2059 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2060 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2061 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnr3;。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2062 =====
=====標準答案=====<BOM>變數名稱f7重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2063 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterg1=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");g1.display();}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2064 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(d2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh7=(Letter)other;returnU9.compareTo(h7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]U={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:U)letter.compareTo(letter);for(Letterletter:U)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2065 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前誤。<EOM>
Meteor_Score : 0.0

===== 2066 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringV8,Stringy4,Stringo2,Stringp2,Stringx8){super(V8,y4,o2,p2,x8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2067 =====
=====標準答案=====<BOM>Envelop第10行K.f3在呼叫K物件中的物件資料時,應呼叫getSender()來回傳returnf3Envelop第11行的K.g8/K.R與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2068 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2069 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2070 =====
=====標準答案=====<BOM>按順序應為y0,g2,T9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2071 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h5,my=W0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2072 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2073 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(n3)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2074 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2075 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2076 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleC9,doubleS1,doubleh9)publicstaticdoubleVolume(doubleC9,doubleS1,doubleh9)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleC9=scanner.nextDouble();System.out.println("輸入寬");doubleS1=scanner.nextDouble();System.out.println("輸入高");doubleh9=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.C9=C9;this.S1=S1;this.h9=h9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2077 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的G3物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2078 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.d1=d1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2079 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2080 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2081 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringo8,StringK2,Stringt4,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2082 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2083 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerQ4=newScanner();intp=Q4.nextInt();//讀取數值Q4.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2084 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);O7=scanner.nextInt();o1=scanner.nextInt();A5=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleW3;publicdoubleR2;publicdoubled6;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleW3;publicdoubleR2;publicdoubled6;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2085 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2086 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2087 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.P6=P6this.l1=l1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2088 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2089 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2090 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2091 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]W8){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2092 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringP6,StringC9,StringP3,StringO7,StringU8){super(P6,C9,P3,O7,U8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2093 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2094 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2095 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.G8=G8this.V5=V5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2096 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:N5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2097 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入I4.i3=2;I4.H4=2;I4.a4=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublei3=kb.nextDouble();doubleH4=kb.nextDouble();doublea4=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2098 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2099 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2100 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2101 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]d2){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2102 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=o2,my=X6<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2103 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2104 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]m9){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2105 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2106 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringq1,Stringz,StringY4){this.q1=q1;this.z=z;this.Y4=Y4;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2107 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如L9，m2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2108 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數e7會衝突,導致e7無法傳遞,建議在Class中宣告e7即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。inti5=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2109 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(r.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringA0,StringM3)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將r.Speak()改為l3.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperl3=newKeeper(A0,M3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringr,Stringt,StringI2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2110 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2111 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2112 =====
=====標準答案=====<BOM>R9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperR9=newKeeper(...);PetS1=newPet(...,R9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(F0.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringF0,StringY3,StringM5,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetS1=newPet(T4,Y3,w2,R9);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2113 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2114 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2115 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2116 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.M9=M9this.C2=C2<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2117 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2118 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=q9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2119 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2120 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(n8+""+w7+",您好");System.out.println(t7);System.out.println(g3+"敬上");System.out.println(v2);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2121 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2122 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如t1.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2123 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2124 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringQ7,S8,H9,X9,Z0;Letter(StringQ7,StringS8,StringH9,StringX9,StringZ0){this.Q7=Q7;this.S8=S8;this.H9=H9;this.X9=X9;this.Z0=Z0;}publicStringgetSender(){returnX9;}publicStringgetReceiver(){returnS8;}publicStringgetDate(){returnZ0;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2125 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2126 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.a2=a2this.j9=j9<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2127 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2128 =====
=====標準答案=====<BOM>按順序應為f7,q9,d。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2129 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2130 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2131 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2132 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入Z1.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2133 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringx1,StringI6,Stringd4,Stringp8,Stringo8){super(x1,I6,d4,p8,o8)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2134 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]l4){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2135 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intF8){F8=3;returnF8;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleb7=X(p6);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2136 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(i9.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中W3等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:S3.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringW3,StringQ,Stringi9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2137 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]C0={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2138 =====
=====標準答案=====<BOM>按順序應為h6,d2,c2。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2139 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2140 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.i7;}publicStringgetTitle(){returnthis.W4;}//可取得Z7publicStringgetReceiver(){returnthis.Z7;}//可取得Z6publicStringgetDate(){returnthis.Z6;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2141 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.P2=P2this.y=y<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2142 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，l5變數型態為Int，M8變數型態為Int，i4變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:n4,p為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2143 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2144 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2145 =====
=====標準答案=====<BOM>變數名稱d8重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2146 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h6,my=z5<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2147 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerI1=newScanner();intA0=I1.nextInt();//讀取數值I1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為k2[w0]，若寫成k2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2148 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2149 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.q9=q9this.I4=I4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2150 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2151 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerD=newScanner();intq4=D.nextInt();//讀取數值D.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為s7[Q1]，若寫成s7[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2152 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2153 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=X4,my=r4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2154 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2155 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2156 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(M6,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringo0,StringP4)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2157 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2158 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2159 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleW6,doublen1,doubleb7)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2160 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2161 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2162 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2163 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerl=newScanner();intY3=l.nextInt();//讀取數值l.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為D0[D8]，若寫成D0[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2164 =====
=====標準答案=====<BOM>StringP7={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]P7={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]W7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2165 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV9=newScanner();intp=V9.nextInt();//讀取數值V9.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2166 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2167 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如c2，L4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2168 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringM7,StringG4,Stringl6,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2169 =====
=====標準答案=====<BOM>r變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperr=newKeeper(...);PetF0=newPet(...,r);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(H4.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringH4,Strings1,StringI6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetF0=newPet(j9,s1,z8,r);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2170 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2171 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2172 =====
=====標準答案=====<BOM>按順序應為N5,z1,t7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2173 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如s1，a，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetters8=(EnglishLetter)K4;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objects8){LetterK4=(Letter)s8;returny6.compareTo(K4.getDate());}先將原本宣告成Object的K4強制轉換成Letter類別型態這樣K4就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2174 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2175 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]t7){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2176 =====
=====標準答案=====<BOM>變數名稱重複宣告k3[r3]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:k3[1],Integer.parseInt(k3[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2177 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(F5.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettert=(Letter)other;returnf9.compareTo(t.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]T2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:T2)letter.compareTo(letter);for(Letterletter:T2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2178 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2179 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數D5會衝突,導致D5無法傳遞,建議在Class中宣告D5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intf2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2180 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2181 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2182 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.r4=r4this.a5=a5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2183 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.e5=e5this.z5=z5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2184 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq9=newScanner();intG=q9.nextInt();//讀取數值q9.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為i1[Q0]，若寫成i1[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2185 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2186 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2187 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=K0;tel=N2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2188 =====
=====標準答案=====<BOM>F3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperF3=newKeeper(...);Petpet=newPet(...,F3);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petl0=newPet(M4,c,p9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(p9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立F3物件變數的值，例如，publicPet(StringM4,Stringc,Stringp9,KeeperF3){...this.F3=F3;}Pet建構子內已有F3參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petl0=newPet(M4,c,p9,m7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫F3.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...F3.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2189 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);u3=scanner.nextInt();d9=scanner.nextInt();X7=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubley;publicdoubleN7;publicdoublea6;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubley;publicdoubleN7;publicdoublea6;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2190 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2191 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，U6,I7是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringU6;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2192 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=x3.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2193 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2194 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2195 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=w6.nextInt();doubleE9=w6.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerw6=newScanner();intA5=w6.nextInt();//讀取數值w6.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2196 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行o1.b在呼叫o1物件中的物件資料時,應呼叫getSender()來回傳returnb<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2197 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2198 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.a=a;this.k9=k9;this.w3=w3;重複定義只需要returnr0=a*k9*w3;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2199 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.o6=o6;this.A7=A7;this.a4=a4;重複定義只需要returnc6=o6*A7*a4;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2200 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2201 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2202 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2203 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerK=newScanner();intN1=K.nextInt();//讀取數值K.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為g9[C]，若寫成g9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2204 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2205 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2206 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=X6,my=B0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2207 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(F3.equals("貓"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2208 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr1=newScanner();intL9=r1.nextInt();//讀取數值r1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為W0[j8]，若寫成W0[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2209 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2210 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2211 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2212 =====
=====標準答案=====<BOM>按順序應為G1,N4,b9。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2213 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX5,StringG6,Stringt8,StringJ7,StringW6){super(X5,G6,t8,J7,W6)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2214 =====
=====標準答案=====<BOM>按順序應為b1,K2,T8。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2215 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]g0){w4.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2216 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnI9=2*(E8*K8+K8*m0+E8*m0);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(E8*K8+K8*m0+m0*E8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnE8*K8*m0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.E8=sc.nextDouble();System.out.print("輸入寬度:");box.K8=sc.nextDouble();System.out.print("輸入高度:");box.m0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("I9:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(E8*K8+K8*m0+m0*E8);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnE8*K8*m0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.E8=sc.nextDouble();System.out.print("輸入寬度:");box.K8=sc.nextDouble();System.out.print("輸入高度:");box.m0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("I9:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2217 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringZ2,Stringz1,Stringy3,StringU6,Stringi0){super(Z2,z1,y3,U6,i0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2218 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2219 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數N4會衝突,導致N4無法傳遞,建議在Class中宣告N4即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intC2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2220 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如a4.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2221 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterz6=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2222 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如i.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2223 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringB7="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2224 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2225 =====
=====標準答案=====<BOM>按順序應為l6,e1,C9。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2226 =====
=====標準答案=====<BOM>n1變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(f5,D7);透過Keeper建構子，將f5與D7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringl5,Stringq1,StringX1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2227 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2228 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]a7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2229 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2230 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.k5=k5this.N4=N4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2231 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2232 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2233 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=D,my=h6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2234 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2235 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(K1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringw1,Stringn0,StringA1,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2236 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"B3","b"};例如，本程式的MyMathUtil類別，需改成String[]i0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2237 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keepery5=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,y5);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2238 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2239 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2240 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]d3={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2241 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(D7.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringP3,Stringw)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將D7.Speak()改為Q.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperQ=newKeeper(P3,w);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringD7,Stringg4,Stringj8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2242 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2243 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2244 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:j9=newExam(W6,O,H4,q1,Q2,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o4){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2245 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2246 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]M0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2247 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數t6會衝突,導致t6無法傳遞,建議在Class中宣告t6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intp9=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2248 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2249 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringO4,Stringq2,Stringd0,Stringh6,Stringr2){super(O4,q2,d0,h6,r2)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringO4,Stringq2,Stringd0,Stringh6,Stringr2){super(O4,q2,d0,h6,r2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2250 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=c4,my=M0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2251 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.O0=O0this.B4=B4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2252 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2253 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2254 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2255 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2256 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如K1.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2257 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，g0,F3是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringg0;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2258 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2259 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2260 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2261 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值，，-分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2262 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2gnewExam2();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2263 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F1=F1this.a3=a3<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2264 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2265 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationt6=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationt6;t6=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2266 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(b1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o1){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2267 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringo4,Stringi6,StringJ9){this.o4=o4;this.i6=i6;this.J9=J9;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2268 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2269 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2270 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2271 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2272 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2273 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2274 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2275 =====
=====標準答案=====<BOM>變數名稱重複宣告A9[e8]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:A9[1],Integer.parseInt(A9[2])<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2276 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringd1,Stringg0,Stringo0,StringG1,StringA7){super(d1,g0,o0,G1,A7)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2277 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2278 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2279 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:y,i7,K1,d為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:p1,d為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:Q7,K4為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:e9,F9為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2280 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2281 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2282 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2283 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2284 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2285 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX9,StringZ5,Stringp5,StringF,StringR3){super(X9,Z5,p5,F,R3)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2286 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=W3,my=A3<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2287 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]S8){Y0.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2288 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2289 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2290 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2291 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F5=F5this.H2=H2<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2292 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2293 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2294 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2295 =====
=====標準答案=====<BOM>按順序應為o8,d0,q9。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2296 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2297 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2298 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(C6,...);Keeperk=newKeeper(u2,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2299 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2300 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnB2;。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2301 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]F0){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2302 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2303 =====
=====標準答案=====<BOM>變數名稱m5重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2304 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);T4=scanner.nextInt();V5=scanner.nextInt();A1=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleE8;publicdoublet1;publicdoubleN3;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleE8;publicdoublet1;publicdoubleN3;<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2305 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2306 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2307 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2308 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2309 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2310 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleC7,doubleM,doublem2)<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2311 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2312 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2313 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2314 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2315 =====
=====標準答案=====<BOM>E8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperE8=newKeeper(...);Petpet=newPet(...,E8);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petw9=newPet(P1,D8,w1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(w1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立E8物件變數的值，例如，publicPet(StringP1,StringD8,Stringw1,KeeperE8){...this.E8=E8;}Pet建構子內已有E8參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petw9=newPet(P1,D8,w1,G);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫E8.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...E8.display();speak();}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2316 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2317 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2318 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(pid.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringid,Stringtel)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將pid.Speak()改為x.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperx=newKeeper(id,tel);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringpid,Stringname,Stringtype,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2319 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2320 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(E7.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringa9,StringA,Stringx8,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2321 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如v，t5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱kb.}<EOM>
Meteor_Score : 0.0

===== 2322 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2323 =====
=====標準答案=====<BOM>Stringb6={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]b6={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Z2){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2324 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intf1=1;類別動作(f1);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2325 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2326 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2327 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2328 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2329 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2330 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]o){F9.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2331 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2332 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2333 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2334 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2335 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2336 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=W1,my=J1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2337 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2338 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=k8.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2339 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，c5.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2340 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2341 =====
=====標準答案=====<BOM>按順序應為w0,w4,L1。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2342 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(s0+""+V+",您好");System.out.println(R5);System.out.println(A7+"敬上");System.out.println(K4);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2343 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，y9變數型態為Int，y1變數型態為Int，b2變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:X5,X7為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2344 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(T7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh9=(Letter)other;returng.compareTo(h9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]G3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:G3)letter.compareTo(letter);for(Letterletter:G3)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2345 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2346 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]z5={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2347 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=i2,my=B1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2348 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數p8會衝突,導致p8無法傳遞,建議在Class中宣告p8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intE3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2349 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數b5會衝突,導致b5無法傳遞,建議在Class中宣告b5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intx=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2350 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2351 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的I0物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2352 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=e5.getSender();StringReceiver=e5.getReceiver();StringTitle=e5.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2353 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2354 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringR0="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2355 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublev0,doubleO9,doublek4)publicstaticdoubleVolume(doublev0,doubleO9,doublek4)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublev0=scanner.nextDouble();System.out.println("輸入寬");doubleO9=scanner.nextDouble();System.out.println("輸入高");doublek4=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.v0=v0;this.O9=O9;this.k4=k4;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2356 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2357 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2358 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"m9","b"};例如，本程式的MyMathUtil類別，需改成String[]d={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2359 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2360 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2361 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2362 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2363 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2364 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2365 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2366 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2367 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]N){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2368 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2369 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(l2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri6=(Letter)other;returnH3.compareTo(i6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Y8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Y8)letter.compareTo(letter);for(Letterletter:Y8)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2370 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringtitle,Stringreceiver,Stringcontent,Stringsender,Stringdate){super(title,receiver,content,sender,date)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2371 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleH2,doublev5,doubleN6)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2372 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleV6,doubley8,doublei3應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.V6=m3;bb.y8=T4;bb.i3=b5;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.V6=m3;bb.y8=T4;bb.i3=b5;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleV6,doubley8,doublei3沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2373 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringK,l9,J5,c9,M2;Letter(StringK,Stringl9,StringJ5,Stringc9,StringM2){this.K=K;this.l9=l9;this.J5=J5;this.c9=c9;this.M2=M2;}publicStringgetSender(){returnc9;}publicStringgetReceiver(){returnl9;}publicStringgetDate(){returnM2;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2374 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=e5.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2375 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringJ1,Stringq2,Stringy9,Stringi1,StringA8){super(J1,q2,y9,i1,A8)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2376 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"c2","b"};例如，本程式的MyMathUtil類別，需改成String[]N5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2377 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2378 =====
=====標準答案=====<BOM>按順序應為S1,o2,R6。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2379 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationR2=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationR2;R2=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2380 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringx7="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2381 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringU1,StringS,Stringy7,Stringf5,Stringa9){super(U1,S,y7,f5,a9)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2382 =====
=====標準答案=====<BOM>StringA8={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]A8={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]G5){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2383 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]N4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2384 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(e3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettert9=(Letter)other;returnp.compareTo(t9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]x9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:x9)letter.compareTo(letter);for(Letterletter:x9)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2385 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]l3){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2386 =====
=====標準答案=====<BOM>變數名稱e4重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2387 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數i8會衝突,導致i8無法傳遞,建議在Class中宣告i8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intc1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2388 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"L4","b"};例如，本程式的MyMathUtil類別，需改成String[]B1={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2389 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2390 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2391 =====
=====標準答案=====<BOM>Envelop第10行n3.n8在呼叫n3物件中的物件資料時,應呼叫getSender()來回傳returnn8Envelop第11行的n3.z7/n3.E8與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2392 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerM6=newScanner();inte3=M6.nextInt();//讀取數值M6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為c7[I6]，若寫成c7[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2393 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2394 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2395 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入C9.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2396 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2397 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2398 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2399 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(y)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2400 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=U6,my=E4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2401 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intq2=1;類別動作(q2);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2402 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=V2,my=v4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2403 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2404 =====
=====標準答案=====<BOM>按順序應為k1,i2,M5。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2405 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2406 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2407 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2408 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2409 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2410 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2411 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2412 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入R4.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2413 =====
=====標準答案=====<BOM>按順序應為d0,H3,I5。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2414 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringS9,StringK,Stringt3,StringC6){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(S9,K,t3,C6);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2415 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，s7.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2416 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2417 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2418 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]h5){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2419 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.o4=o4this.p0=p0<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2420 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2421 =====
=====標準答案=====<BOM>K1,w8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperK1=newKeeper(...);PetX6=newPet(...,K1);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringv9,StringG,StringI5,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetX6=newPet(v9,G,I5,K1);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2422 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2423 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2424 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]D8){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2425 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:r7.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2426 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2427 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.a9;}publicStringgetTitle(){returnthis.G0;}//可取得K2publicStringgetReceiver(){returnthis.K2;}//可取得p4publicStringgetDate(){returnthis.p4;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2428 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2429 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如e0.equals("貓")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2430 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2431 =====
=====標準答案=====<BOM>變數名稱g重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2432 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intm){m=3;returnm;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleI6=X(B2);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2433 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2434 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的b5物件資料所以在呼叫b5的物件動作的時候應加上System.out.println("From:"+R5+","+b5.getSender());System.out.println("To:"+B7+","+b5.getReceiver()+""+b5.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2435 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxW0=newKKBOx(l,w,h);呼叫時可用W0.volume();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2436 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2437 =====
=====標準答案=====<BOM>變數名稱O4重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2438 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2439 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2440 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperU3=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,U3);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2441 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2442 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]J3={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2443 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero8=newScanner();intc2=o8.nextInt();//讀取數值o8.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為J[d1]，若寫成J[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2444 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2445 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2446 =====
=====標準答案=====<BOM>按順序應為J,s0,y8。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2447 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2f4newExam2();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2448 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);T7=scanner.nextInt();V5=scanner.nextInt();t8=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleN1;publicdoubleZ;publicdoubleP1;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleN1;publicdoubleZ;publicdoubleP1;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2449 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2450 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2451 =====
=====標準答案=====<BOM>變數名稱b3重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2452 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringH5;...，此外，ChineseLetter與EnglishLetter就可以刪除StringH5;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2453 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringu5,S,v2,q5,I1;Letter(Stringu5,StringS,Stringv2,Stringq5,StringI1){this.u5=u5;this.S=S;this.v2=v2;this.q5=q5;this.I1=I1;}publicStringgetSender(){returnq5;}publicStringgetReceiver(){returnS;}publicStringgetDate(){returnI1;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2454 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringZ3,N6,E,e1,M6;Letter(StringZ3,StringN6,StringE,Stringe1,StringM6){this.Z3=Z3;this.N6=N6;this.E=E;this.e1=e1;this.M6=M6;}publicStringgetSender(){returne1;}publicStringgetReceiver(){returnN6;}publicStringgetDate(){returnM6;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2455 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2456 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2457 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2458 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2459 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2460 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2461 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入b8.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2462 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的p2物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2463 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2464 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入M5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2465 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnY4;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2466 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2467 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2468 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2469 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringk4,Stringo,StringN5,Stringb6,StringF7){super(k4,o,N5,b6,F7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2470 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數Z3會衝突,導致Z3無法傳遞,建議在Class中宣告Z3即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。inth2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2471 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2472 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=N8.getSender();StringReceiver=N8.getReceiver();StringTitle=N8.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2473 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2474 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如s0.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2475 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:H9.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2476 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2477 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2478 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2479 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2480 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2481 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2482 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k8,my=g6<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2483 =====
=====標準答案=====<BOM>按順序應為F1,X6,x5。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2484 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2485 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2486 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如i8.equals("貓")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2487 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringN9,StringM,StringZ,Stringn4){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(N9,M,Z,n4);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2488 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，n5.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行S0S0:<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2489 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2490 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intM1=1;類別動作(M1);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2491 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2492 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]i0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2493 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=r7,my=t5<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2494 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringU4,Stringr9,Stringv,Stringv2){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(U4,r9,v,v2);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2495 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2496 =====
=====標準答案=====<BOM>按順序應為h8,k2,o3。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2497 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2498 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行g0.t7在呼叫g0物件中的物件資料時,應呼叫getSender()來回傳returnt7<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2499 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2500 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2501 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2502 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:L7.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2503 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringL2,Stringm7,StringR1,StringR2,StringO2){super(L2,m7,R1,R2,O2)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2504 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(B9,P2,k8);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2505 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2506 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnM7;。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2507 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2508 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2509 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]X0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2510 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2511 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2512 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=d4,my=p7<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2513 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerM=newScanner();intp=M.nextInt();//讀取數值M.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2514 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2515 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2516 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2517 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2518 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2519 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE2,Stringi2,Stringo7,Stringl,StringE3){super(E2,i2,o7,l,E3)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringE2,Stringi2,Stringo7,Stringl,StringE3){super(E2,i2,o7,l,E3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2520 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanners4=newScanner();intp=s4.nextInt();//讀取數值s4.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2521 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2522 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2523 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2524 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperv2=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,v2);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2525 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2526 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2527 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(m3)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2528 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2529 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2530 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2531 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2532 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2533 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2534 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerx4=newScanner();intV0=x4.nextInt();//讀取數值x4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為t1[B7]，若寫成t1[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2535 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=H1.nextInt();doubleu5=H1.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerH1=newScanner();intd1=H1.nextInt();//讀取數值H1.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2536 =====
=====標準答案=====<BOM>W9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperW9=newKeeper(...);PetY1=newPet(...,W9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(A3.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringA3,StringO6,StringR6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetY1=newPet(I2,O6,u0,W9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2537 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2538 =====
=====標準答案=====<BOM>按順序應為w6,R7,M5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2539 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2540 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2541 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2542 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intS7){S7=3;returnS7;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubler6=X(C2);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2543 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.k4=k4this.G7=G7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2544 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫letter中的物件動作來回傳值例:letter.getSender();而不是直接呼叫letter中的物件資料System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2545 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerL5=newScanner();intP9=L5.nextInt();//讀取數值L5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為y7[E4]，若寫成y7[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2546 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2547 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2548 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringO6="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2549 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2550 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2551 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=V3,my=z6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2552 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的C4與englishletter與letter就可刪除Stringd5,...;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2553 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2554 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o5){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2555 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"M7","b"};例如，本程式的MyMathUtil類別，需改成String[]x5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2556 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(o0),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]I6){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2557 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.Q3=Q3this.h3=h3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2558 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2559 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2560 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2561 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringo7="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2562 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2563 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2564 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的p0物件資料所以在呼叫p0的物件動作的時候應加上System.out.println("From:"+Z6+","+p0.getSender());System.out.println("To:"+O1+","+p0.getReceiver()+""+p0.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2565 =====
=====標準答案=====<BOM>變數名稱q1重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2566 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2567 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2568 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.r3=r3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2569 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2570 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2571 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]R){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2572 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用X9.display()顯示內容，此外Q8.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2573 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(N6)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2574 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2575 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數t7會衝突,導致t7無法傳遞,建議在Class中宣告t7即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intB7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2576 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2577 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2578 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2579 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(V7.equals("貓"))<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2580 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2581 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnc;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2582 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，h8.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行G9G9:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2583 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2584 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成w0.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2585 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(M1.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringG4,Stringr3)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將M1.Speak()改為n5.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keepern5=newKeeper(G4,r3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringM1,StringP2,StringO9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2586 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:P5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2587 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2588 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2589 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]M4){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2590 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringN3,StringA2,doublef5,doubleF){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(N3,A2,f5,F);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2591 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxN9=newKKBOx(l,w,h);呼叫時可用N9.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2592 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2593 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2594 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(S0)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2595 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2596 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=B.nextInt();doubleZ1=B.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerB=newScanner();inti6=B.nextInt();//讀取數值B.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2597 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2598 =====
=====標準答案=====<BOM>按順序應為M5,y1,v5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2599 =====
=====標準答案=====<BOM>按順序應為K3,v5,E。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2600 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如b2=i;應改成i=b2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2601 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2602 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2603 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2604 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2605 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的M7物件資料所以在呼叫M7的物件動作的時候應加上System.out.println("From:"+b5+","+M7.getSender());System.out.println("To:"+W2+","+M7.getReceiver()+""+M7.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2606 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2607 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:w3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2608 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2609 =====
=====標準答案=====<BOM>L變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperQ0=newKeeper(...);Pets1=newPet(...,Q0);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立L物件變數的值，例如，publicPet(StringD7,Stringd8,StringK6,KeeperL){...this.L=L;}Pet建構子內已有L參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Pets1=newPet(D7,d8,K6,Q0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2610 =====
=====標準答案=====<BOM>Envelop第10行P7.E4在呼叫P7物件中的物件資料時,應呼叫getSender()來回傳returnE4Envelop第11行的P7.H4/P7.p7與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2611 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2612 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2613 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2614 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2615 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2616 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]V3){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2617 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2618 =====
=====標準答案=====<BOM>變數名稱D5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2619 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringz3,StringP3,Stringe3,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2620 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2621 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]s1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2622 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2623 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2624 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成p9.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2625 =====
=====標準答案=====<BOM>V變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperV=newKeeper(...);PetF3=newPet(...,V);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(J0.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringJ0,Stringv7,Strings3,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetF3=newPet(O8,v7,l2,V);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2626 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2627 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F5=F5this.c6=c6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2628 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如U3，Q2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2629 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleL9,doubleN5,doubleo5應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.L9=g5;bb.N5=M3;bb.o5=O4;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.L9=g5;bb.N5=M3;bb.o5=O4;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleL9,doubleN5,doubleo5沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2630 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returne8=2*(T1*N1+N1*F3+T1*F3);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(T1*N1+N1*F3+F3*T1);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnT1*N1*F3;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.T1=sc.nextDouble();System.out.print("輸入寬度:");box.N1=sc.nextDouble();System.out.print("輸入高度:");box.F3=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("e8:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(T1*N1+N1*F3+F3*T1);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnT1*N1*F3;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.T1=sc.nextDouble();System.out.print("輸入寬度:");box.N1=sc.nextDouble();System.out.print("輸入高度:");box.F3=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("e8:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2631 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:e7=newExam(a6,M4,G0,y3,c4,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]n4){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2632 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intC3){...returnC3;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublex6=X(Q2);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2633 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成b6.equals("貓")，b6.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2634 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]W6){z5.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2635 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2636 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(o6.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中N9等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:J0.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringN9,Strings,Stringo6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2637 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(x8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterl3=(Letter)other;returno8.compareTo(l3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]J7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:J7)letter.compareTo(letter);for(Letterletter:J7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2638 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2639 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入Z8.I=2;Z8.o8=2;Z8.M0=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleI=kb.nextDouble();doubleo8=kb.nextDouble();doubleM0=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2640 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2641 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2642 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2643 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2644 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2645 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2646 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2647 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2648 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(j6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterj=(Letter)other;returnw5.compareTo(j.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]E8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:E8)letter.compareTo(letter);for(Letterletter:E8)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2649 =====
=====標準答案=====<BOM>按順序應為P6,g1,a1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2650 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intN0){...returnN0;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleu0=X(q0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2651 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2652 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2653 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(G4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterl=(Letter)other;returnN1.compareTo(l.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]K6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:K6)letter.compareTo(letter);for(Letterletter:K6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2654 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如N.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2655 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2656 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2657 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(s8,c4,x4);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2658 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2659 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫n9中的物件動作來回傳值例:n9.getSender();而不是直接呼叫n9中的物件資料System.out.println("From:"+w1+","+n9.getSender());System.out.println("To:"+L8+","+n9.getReceiver()+""+n9.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2660 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=h0.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2661 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2662 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2663 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(m8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]g5){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2664 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2665 =====
=====標準答案=====<BOM>StringW9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]W9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]O7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2666 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2667 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2668 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2669 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]a){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2670 =====
=====標準答案=====<BOM>變數名稱z5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2671 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2672 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2673 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2674 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(W3),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]B9){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2675 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringf4,k,Z7,O7,X3;Letter(Stringf4,Stringk,StringZ7,StringO7,StringX3){this.f4=f4;this.k=k;this.Z7=Z7;this.O7=O7;this.X3=X3;}publicStringgetSender(){returnO7;}publicStringgetReceiver(){returnk;}publicStringgetDate(){returnX3;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2676 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2677 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2678 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=B3.getSender();StringReceiver=B3.getReceiver();StringTitle=B3.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2679 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2680 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intV0=1;類別動作(V0);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2681 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=H.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2682 =====
=====標準答案=====<BOM>U6變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperU6=newKeeper(...);Petpet=newPet(...,U6);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petu=newPet(O7,N7,q3);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(q3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立U6物件變數的值，例如，publicPet(StringO7,StringN7,Stringq3,KeeperU6){...this.U6=U6;}Pet建構子內已有U6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petu=newPet(O7,N7,q3,e2);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫U6.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...U6.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2683 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2684 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2685 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如t4.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2686 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=C9,my=g3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2687 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2688 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2689 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2690 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2691 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2692 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublei8,doubleW4,doublew5)publicstaticdoubleVolume(doublei8,doubleW4,doublew5)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublei8=scanner.nextDouble();System.out.println("輸入寬");doubleW4=scanner.nextDouble();System.out.println("輸入高");doublew5=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.i8=i8;this.W4=W4;this.w5=w5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2693 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2694 =====
=====標準答案=====<BOM>按順序應為m9,M1,l0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2695 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationa3=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationa3;a3=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2696 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"x7","b"};例如，本程式的MyMathUtil類別，需改成String[]y={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2697 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2698 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringl2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2699 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(U,h5,Q);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2700 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterw2=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2701 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxD1=newKKBOx(l,w,h);呼叫時可用D1.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2702 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2703 =====
=====標準答案=====<BOM>按順序應為A0,B4,I8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2704 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringh5,StringQ3,Stringz9,Stringl2,StringO7){super(h5,Q3,z9,l2,O7)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringh5,StringQ3,Stringz9,Stringl2,StringO7){super(h5,Q3,z9,l2,O7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2705 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=N1.nextInt();doublet7=N1.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerN1=newScanner();intq=N1.nextInt();//讀取數值N1.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2706 =====
=====標準答案=====<BOM>按順序應為X7,d1,V4。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2707 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterv1=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");v1.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2708 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2709 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2710 =====
=====標準答案=====<BOM>按順序應為k3,q6,k0。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2711 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2712 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2713 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如I，t8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2714 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerG7=newScanner();intp=G7.nextInt();//讀取數值G7.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2715 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=R6.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2716 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2717 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intN9=1;類別動作(N9);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2718 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2719 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringw5,Stringk4,StringU3,Stringz5,StringT9){super(w5,k4,U3,z5,T9)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringw5,Stringk4,StringU3,Stringz5,StringT9){super(w5,k4,U3,z5,T9)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2720 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettero9=(Letter)other;returna0.compareTo(o9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]h1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:h1)letter.compareTo(letter);for(Letterletter:h1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2721 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleO1,doubleZ4,doubleB)publicstaticdoubleVolume(doubleO1,doubleZ4,doubleB)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleO1=scanner.nextDouble();System.out.println("輸入寬");doubleZ4=scanner.nextDouble();System.out.println("輸入高");doubleB=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.O1=O1;this.Z4=Z4;this.B=B;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2722 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2723 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2724 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2725 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2726 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerQ8=newScanner();intp=Q8.nextInt();//讀取數值Q8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2727 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2728 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，W1.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行B7B7:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2729 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2730 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperC5=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,C5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2731 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2732 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2733 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationC8=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationC8;C8=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2734 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublej9,doubled0,doubleb3應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.j9=B4;bb.d0=S2;bb.b3=S4;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.j9=B4;bb.d0=S2;bb.b3=S4;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublej9,doubled0,doubleb3沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2735 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如E4，t1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2736 =====
=====標準答案=====<BOM>變數名稱D9重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(i9.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2737 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2738 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.w2=w2this.r=r<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2739 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2740 =====
=====標準答案=====<BOM>按順序應為S3,N0,y8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2741 =====
=====標準答案=====<BOM>變數名稱l7重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2742 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2743 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2744 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=k0.getSender();StringReceiver=k0.getReceiver();StringTitle=k0.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2745 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2746 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2747 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2748 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2M4newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2749 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.Y3=Y3;this.t1=t1;this.X2=X2;重複定義只需要returnJ7=Y3*t1*X2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

Avg_Meteor_Score : 0.0071
