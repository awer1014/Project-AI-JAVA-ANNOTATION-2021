===== 0 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，X6,j6是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringX6;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 3 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 4 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 5 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringC9,StringS7,Strings3,StringG0,Stringm2){super(C9,S7,s3,G0,m2)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringC9,StringS7,Strings3,StringG0,Stringm2){super(C9,S7,s3,G0,m2)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 6 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如G6=i;應改成i=G6;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 7 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 8 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.g2=g2<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 9 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 10 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入Y0.t4=2;Y0.q3=2;Y0.d2=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublet4=kb.nextDouble();doubleq3=kb.nextDouble();doubled2=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 11 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 12 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 13 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入i.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 14 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 15 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 16 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]u2){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 17 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 18 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 19 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入h9.y6=2;h9.A8=2;h9.w2=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubley6=kb.nextDouble();doubleA8=kb.nextDouble();doublew2=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 20 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 21 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成i.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 22 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 23 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 24 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 25 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 26 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 27 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=s4.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 28 =====
=====標準答案=====<BOM>I2變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperI2=newKeeper(...);PetZ2=newPet(...,I2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(v9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringa4,Stringp2,Stringv9,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetZ2=newPet(m3,U6,s5,I2);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 29 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.Z0=Z0this.s=s<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 30 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 31 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 32 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 33 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 34 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.u1=u1;this.b0=b0;this.v=v;重複定義只需要returnt4=u1*b0*v;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 35 =====
=====標準答案=====<BOM>P0變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(v0,i7);透過Keeper建構子，將v0與i7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringW,Stringa2,StringF9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 36 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 37 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 38 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"s2","b"};例如，本程式的MyMathUtil類別，需改成String[]w3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 39 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 40 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 41 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 42 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]t1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 43 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringc9="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 44 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnE4;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 45 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如O3.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 46 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringf7="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 47 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxQ7=newKKBOx(l,w,h);呼叫時可用Q7.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 48 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 49 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 50 =====
=====標準答案=====<BOM>StringV5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]V5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]B6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 51 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]j0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 52 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerK6=newScanner();intT0=K6.nextInt();//讀取數值K6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為h5[L1]，若寫成h5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 53 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.c5=c5this.U8=U8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 54 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 55 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 56 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 57 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如z1，D0，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 58 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublev=X(G4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 59 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 60 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]E5){C0.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 61 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 62 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringH8,Stringd1,Stringz,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 63 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringt,Stringr,Stringc,Strings,Stringd){super(t,r,c,s,d)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 64 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 65 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入I5.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 66 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如f0，c1，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 67 =====
=====標準答案=====<BOM>按順序應為c9,M1,T6。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 68 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]K9={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 69 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 70 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneri8=newScanner();inth8=i8.nextInt();//讀取數值i8.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為Q6[s9]，若寫成Q6[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 71 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStrings3,Z5,m2,V6,z5;Letter(Strings3,StringZ5,Stringm2,StringV6,Stringz5){this.s3=s3;this.Z5=Z5;this.m2=m2;this.V6=V6;this.z5=z5;}publicStringgetSender(){returnV6;}publicStringgetReceiver(){returnZ5;}publicStringgetDate(){returnz5;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 72 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 73 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如o=i;應改成i=o;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 74 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 75 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(d5),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]D0){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 76 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 77 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]V={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 78 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如E2.equals("dog")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 79 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublek,doubleS6,doubleL5)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 80 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]e4){p1.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 81 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]F0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 82 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.n6=n6;this.P8=P8;this.C1=C1;重複定義只需要returnm1=n6*P8*C1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 83 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 84 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成g0.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 85 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(q0),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]U1){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 86 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringV7,StringA0,StringA7,StringX9,Stringx8){super(V7,A0,A7,X9,x8)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 87 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 88 =====
=====標準答案=====<BOM>U1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperU1=newKeeper(...);Petc2=newPet(...,U1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(y7.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringy7,Stringd1,Stringn8,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petc2=newPet(v5,d1,g4,U1);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 89 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 90 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 91 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(D5.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringf5,StringO6,StringD5,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 92 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 93 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(a+""+v7+",您好");System.out.println(N3);System.out.println(m+"敬上");System.out.println(Y0);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 94 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 95 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(a6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterr2=(Letter)other;returnr5.compareTo(r2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Q6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Q6)letter.compareTo(letter);for(Letterletter:Q6)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 96 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnT2=2*(w*Q0+Q0*U5+w*U5);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(w*Q0+Q0*U5+U5*w);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnw*Q0*U5;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.w=sc.nextDouble();System.out.print("輸入寬度:");box.Q0=sc.nextDouble();System.out.print("輸入高度:");box.U5=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("T2:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(w*Q0+Q0*U5+U5*w);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnw*Q0*U5;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.w=sc.nextDouble();System.out.print("輸入寬度:");box.Q0=sc.nextDouble();System.out.print("輸入高度:");box.U5=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("T2:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 97 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 98 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 99 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp5,Stringa1,Stringc6,Stringh5,StringJ2){super(p5,a1,c6,h5,J2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 100 =====
=====標準答案=====<BOM>按順序應為b4,f6,n2。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 101 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(N4)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 102 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成I8.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 103 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 104 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 105 =====
=====標準答案=====<BOM>StringY6={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]Y6={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]X){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 106 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 107 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 108 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]r5={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 109 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用d5.display()顯示內容，此外J6.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 110 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 111 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 112 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數W2會衝突,導致W2無法傳遞,建議在Class中宣告W2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intc6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 113 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 114 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannern9=newScanner();intp=n9.nextInt();//讀取數值n9.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 115 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]J){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 116 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 117 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 118 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringA8,StringJ4,Stringa7,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 119 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(k5,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringk,StringM3)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 120 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 121 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 122 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 123 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringK8,StringL3,StringM0,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 124 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k,my=J0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 125 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如t0，B2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 126 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 127 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.M2=M2<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 128 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 129 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero5=newScanner();inth8=o5.nextInt();//讀取數值o5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為v8[U6]，若寫成v8[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 130 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringpid,Stringname,Stringtype,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 131 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 132 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 133 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 134 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringx9="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 135 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 136 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 137 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 138 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 139 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(T4),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]n0){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 140 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 141 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublex6,doubleJ9,doublei3)publicstaticdoubleVolume(doublex6,doubleJ9,doublei3)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublex6=scanner.nextDouble();System.out.println("輸入寬");doubleJ9=scanner.nextDouble();System.out.println("輸入高");doublei3=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.x6=x6;this.J9=J9;this.i3=i3;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 142 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如J3.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 143 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 144 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 145 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 146 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);k6=scanner.nextInt();u4=scanner.nextInt();q0=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublec8;publicdoublee3;publicdoublew9;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublec8;publicdoublee3;publicdoublew9;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 147 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 148 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 149 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringc2,StringF8,Stringu1,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 150 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]c9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 151 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數f4會衝突,導致f4無法傳遞,建議在Class中宣告f4即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intC6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 152 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 153 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 154 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 155 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如o6.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 156 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringD7,Stringx0,doubleu2,doublej0){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(D7,x0,u2,j0);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 157 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 158 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 159 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intk1){...returnk1;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleR1=X(e1);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 160 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 161 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 162 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 163 =====
=====標準答案=====<BOM>c2變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperc2=newKeeper(...);Petpet=newPet(...,c2);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petk4=newPet(e4,x5,a6);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(a6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立c2物件變數的值，例如，publicPet(Stringe4,Stringx5,Stringa6,Keeperc2){...this.c2=c2;}Pet建構子內已有c2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petk4=newPet(e4,x5,a6,x8);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫c2.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...c2.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 164 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，y7.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 165 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"S8","b"};例如，本程式的MyMathUtil類別，需改成String[]Y5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 166 =====
=====標準答案=====<BOM>l7變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperl7=newKeeper(...);Petpet=newPet(...,l7);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetM7=newPet(h6,u9,m);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(m.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立l7物件變數的值，例如，publicPet(Stringh6,Stringu9,Stringm,Keeperl7){...this.l7=l7;}Pet建構子內已有l7參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetM7=newPet(h6,u9,m,Z6);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫l7.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...l7.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 167 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublex9,doubleR,doublem6應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.x9=L;bb.R=C5;bb.m6=k3;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.x9=L;bb.R=C5;bb.m6=k3;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublex9,doubleR,doublem6沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 168 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 169 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入d8.S7=2;d8.U5=2;d8.v=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleS7=kb.nextDouble();doubleU5=kb.nextDouble();doublev=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 170 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:W=newExam(n2,G0,p1,d0,s7,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]C){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 171 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 172 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]J2){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 173 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 174 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]l7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 175 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 176 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 177 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.G2=G2this.q1=q1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 178 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 179 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入A3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 180 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW9,Stringw4,Stringr6,StringL4,StringP8){super(W9,w4,r6,L4,P8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 181 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 182 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 183 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnf5;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 184 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成N0.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 185 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成E1.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 186 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 187 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行i9.i2在呼叫i9物件中的物件資料時,應呼叫getSender()來回傳returni2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 188 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 189 =====
=====標準答案=====<BOM>按順序應為l5,g5,R8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 190 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 191 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成k7.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 192 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 193 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 194 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]a6){a8.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 195 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.H7=H7;this.w=w;this.v0=v0;重複定義只需要returnV4=H7*w*v0;<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 196 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intw8=1;類別動作(w8);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 197 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"s4","b"};例如，本程式的MyMathUtil類別，需改成String[]h8={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 198 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringV1,StringI5,StringN4,StringS2,StringV){super(V1,I5,N4,S2,V)}}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 199 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"W7","b"};例如，本程式的MyMathUtil類別，需改成String[]L5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 200 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringu8="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 201 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=i,my=t4<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 202 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 203 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入I.H6=2;I.U6=2;I.w9=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleH6=kb.nextDouble();doubleU6=kb.nextDouble();doublew9=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 204 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 205 =====
=====標準答案=====<BOM>變數名稱j9重複宣告。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 206 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 207 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.l0=l0<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 208 =====
=====標準答案=====<BOM>h1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperh1=newKeeper(...);PetP6=newPet(...,h1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(B5.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringv6,StringD4,StringB5,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetP6=newPet(I8,q9,F6,h1);<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 209 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 210 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(U0),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]m6){...}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 211 =====
=====標準答案=====<BOM>Stringu8={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]u8={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]x8){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 212 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 213 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.t4=t4;this.t0=t0;this.u3=u3;重複定義只需要returnQ7=t4*t0*u3;<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 214 =====
=====標準答案=====<BOM>e8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepere8=newKeeper(...);PetQ0=newPet(...,e8);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(A6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringI2,Stringq0,StringA6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetQ0=newPet(Y9,J3,r6,e8);<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 215 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 216 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如p2=i;應改成i=p2;<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 217 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 218 =====
=====標準答案=====<BOM>n5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepern5=newKeeper(...);Petpet=newPet(...,n5);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petq1=newPet(F6,t5,g0);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(g0.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立n5物件變數的值，例如，publicPet(StringF6,Stringt5,Stringg0,Keepern5){...this.n5=n5;}Pet建構子內已有n5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petq1=newPet(F6,t5,g0,d4);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫n5.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...n5.display();speak();}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 219 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 220 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=X8.nextInt();doubleo1=X8.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerX8=newScanner();inti7=X8.nextInt();//讀取數值X8.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 221 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 222 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(k.equals("貓"))<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 223 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=V4,my=z9<EOM>
=====預測答案=====<BOM>a變數定義後需確。<EOM>
Meteor_Score : 0.0

===== 224 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 225 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，O8.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行d0d0:<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 226 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 227 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如r9，S，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 228 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.m9=m9;this.k8=k8;this.f5=f5;重複定義只需要returne6=m9*k8*f5;<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 229 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 230 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 231 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 232 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.C1=C1;this.C0=C0;this.z1=z1;重複定義只需要returnY=C1*C0*z1;<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 233 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 234 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入E9.display();<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 235 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperC4=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,C4);<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 236 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的T5物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 237 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 238 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入Q8.display();<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 239 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(g7.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringZ0,StringQ9,Stringg7,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 240 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 241 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 242 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(x8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettera1=(Letter)other;returnJ6.compareTo(a1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]O7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:O7)letter.compareTo(letter);for(Letterletter:O7)letter.display();<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 243 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:e2,Y5,Z7,Z1為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:F8,Z1為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:O3,s8為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:g,f1為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 244 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.i6=i6;this.n3=n3;this.l1=l1;重複定義只需要returng1=i6*n3*l1;<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 245 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 246 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 247 =====
=====標準答案=====<BOM>變數名稱重複宣告J3[X3]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:J3[1],Integer.parseInt(J3[2])<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 248 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 249 =====
=====標準答案=====<BOM>T3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperT3=newKeeper(...);Petz1=newPet(...,T3);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(n1.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringn1,StringW7,Stringz,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petz1=newPet(J3,W7,r8,T3);<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 250 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 251 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=F1.getSender();StringReceiver=F1.getReceiver();StringTitle=F1.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 252 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=y2.nextInt();doubleL6=y2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannery2=newScanner();inth9=y2.nextInt();//讀取數值y2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 253 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=L1.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 254 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringS5,StringQ9,Stringn,Strings6,StringU3){super(S5,Q9,n,s6,U3)}}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 255 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringS9,Stringx3,StringX8,StringQ,StringW7){super(S9,x3,X8,Q,W7)}}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 256 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 257 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 258 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的L4物件資料所以在呼叫L4的物件動作的時候應加上System.out.println("From:"+S4+","+L4.getSender());System.out.println("To:"+e6+","+L4.getReceiver()+""+L4.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 259 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:D2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 260 =====
=====標準答案=====<BOM>G9,p變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperG9=newKeeper(...);PetA6=newPet(...,G9);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringW,Stringi,StringI5,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetA6=newPet(W,i,I5,G9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 261 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 262 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，e.equals("貓")，e.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 263 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 264 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 265 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.x9=x9;this.D7=D7;this.h9=h9;重複定義只需要returnz7=x9*D7*h9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 266 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 267 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 268 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如d7，c3，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 269 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 270 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成b.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 271 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 272 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerk3=newScanner();intp=k3.nextInt();//讀取數值k3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 273 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(c5.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri6=(Letter)other;returnx.compareTo(i6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]L0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:L0)letter.compareTo(letter);for(Letterletter:L0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 274 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 275 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.U=Uthis.n4=n4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 276 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]c3={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 277 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringk1,Stringy5,StringN2,StringH1,Stringj3){super(k1,y5,N2,H1,j3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 278 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 279 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 280 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 281 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 282 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]i1){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 283 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 284 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 285 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.u6=u6;this.X4=X4;this.w6=w6;重複定義只需要returnu1=u6*X4*w6;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 286 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 287 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 288 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 289 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(G9),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]D){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 290 =====
=====標準答案=====<BOM>按順序應為S2,f2,f7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 291 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb0=newKKBOx(l,w,h);呼叫時可用b0.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 292 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 293 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 294 =====
=====標準答案=====<BOM>k變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperk=newKeeper(...);Peta=newPet(...,k);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringpid,Stringname,Stringtype,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Peta=newPet(p,n,ty,k);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 295 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 296 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 297 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數A6會衝突,導致A6無法傳遞,建議在Class中宣告A6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intt1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 298 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 299 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，T1變數型態為Int，Y3變數型態為Int，s2變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:E6,B9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 300 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用Q7.display()顯示內容，此外G0.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 301 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(p4.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringd7,Stringz3)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將p4.Speak()改為N8.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperN8=newKeeper(d7,z3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringp4,Stringy3,StringD9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 302 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 303 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 304 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 305 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 306 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 307 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 308 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 309 =====
=====標準答案=====<BOM>變數名稱重複宣告P7[T9]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:P7[1],Integer.parseInt(P7[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 310 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 311 =====
=====標準答案=====<BOM>Envelope擁有Letter的B7物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+u7+","+B7.getSender());System.out.println("To:"+l6+","+B7.getReceiver()+""+B7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 312 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringn2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 313 =====
=====標準答案=====<BOM>按順序應為s,N4,C6。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 314 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]s3){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 315 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.f1=f1this.n5=n5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 316 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 317 =====
=====標準答案=====<BOM>按順序應為g0,n1,M5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 318 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringe0,i6,Y6,M,W1;Letter(Stringe0,Stringi6,StringY6,StringM,StringW1){this.e0=e0;this.i6=i6;this.Y6=Y6;this.M=M;this.W1=W1;}publicStringgetSender(){returnM;}publicStringgetReceiver(){returni6;}publicStringgetDate(){returnW1;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 319 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 320 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 321 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 322 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 323 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 324 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入e3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 325 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 326 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxW8=newKKBOx(l,w,h);呼叫時可用W8.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 327 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如N7，p1，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 328 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 329 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]G7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 330 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 331 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("狗"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 332 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(M0.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中T6等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:M5.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringT6,Stringz1,StringM0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 333 =====
=====標準答案=====<BOM>變數名稱U0重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 334 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 335 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intk3){k3=3;returnk3;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleO7=X(B9);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 336 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=H4,my=y<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 337 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 338 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 339 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 340 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.U2=U2this.E5=E5<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 341 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 342 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:G5.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 343 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 344 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如Y5.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 345 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 346 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成K3.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 347 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 348 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 349 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 350 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"y0","b"};例如，本程式的MyMathUtil類別，需改成String[]O={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 351 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 352 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(q3+""+n1+",您好");System.out.println(L0);System.out.println(R0+"敬上");System.out.println(h2);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 353 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行V3.u7在呼叫V3物件中的物件資料時,應呼叫getSender()來回傳returnu7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 354 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數h5會衝突,導致h5無法傳遞,建議在Class中宣告h5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intl2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 355 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用H2.display()顯示內容，此外u0.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 356 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:x3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 357 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 358 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intw1){w1=3;returnw1;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleP0=X(C8);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 359 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnL4=2*(x5*b6+b6*x+x5*x);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(x5*b6+b6*x+x*x5);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnx5*b6*x;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.x5=sc.nextDouble();System.out.print("輸入寬度:");box.b6=sc.nextDouble();System.out.print("輸入高度:");box.x=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("L4:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(x5*b6+b6*x+x*x5);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnx5*b6*x;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.x5=sc.nextDouble();System.out.print("輸入寬度:");box.b6=sc.nextDouble();System.out.print("輸入高度:");box.x=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("L4:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 360 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(c2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterM2=(Letter)other;returnE4.compareTo(M2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]e8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:e8)letter.compareTo(letter);for(Letterletter:e8)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 361 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]S8){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 362 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 363 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 364 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 365 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 366 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 367 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intm2){m2=3;returnm2;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublej5=X(S8);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 368 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=f6,my=p7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 369 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 370 =====
=====標準答案=====<BOM>按順序應為V6,D2,x3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 371 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringo4,StringH5,StringG0,StringM1,StringJ4){super(o4,H5,G0,M1,J4)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 372 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 373 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 374 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 375 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.s=s<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 376 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 377 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 378 =====
=====標準答案=====<BOM>a0,v4變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepera0=newKeeper(...);Peto6=newPet(...,a0);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringE7,StringE2,Stringd6,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Peto6=newPet(E7,E2,d6,a0);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 379 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 380 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 381 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"m","b"};例如，本程式的MyMathUtil類別，需改成String[]q7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 382 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 383 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 384 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 385 =====
=====標準答案=====<BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"例如本段函數內應寫returnw3=2*(t*f0+f0*i0+t*i0);即可<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(t*f0+f0*i0+i0*t);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnt*f0*i0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.t=sc.nextDouble();System.out.print("輸入寬度:");box.f0=sc.nextDouble();System.out.print("輸入高度:");box.i0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("w3:"+box.getSurfaceArea());}<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"應將publicstaticvoidgetSurfaceArea改寫為publicdoublegetSurfaceArea(){return2*(t*f0+f0*i0+i0*t);}將publicstaticvoidgetvolume改寫為publicdoublegetVolume(){returnt*f0*i0;}並寫一個mainpublicstaticvoidmain(String[]args){Scannersc=newScanner(System.in);KKBoxbox=newKKBox();System.out.print("輸入長度:");box.t=sc.nextDouble();System.out.print("輸入寬度:");box.f0=sc.nextDouble();System.out.print("輸入高度:");box.i0=sc.nextDouble();System.out.println("Volume:"+box.getVolume());System.out.println("w3:"+box.getSurfaceArea());}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 386 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 387 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 388 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，m.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 389 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 390 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 391 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(g8,...);Keeperk=newKeeper(Q6,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 392 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(x5.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterB6=(Letter)other;returni9.compareTo(B6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]m7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:m7)letter.compareTo(letter);for(Letterletter:m7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 393 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringN4,StringE3,Stringf6,Stringm0,StringY7){super(N4,E3,f6,m0,Y7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 394 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(Z8,...);Keeperk=newKeeper(c1,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 395 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]y4){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 396 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 397 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringm5,Stringm7,doubler,doubleb){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(m5,m7,r,b);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 398 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerp=newScanner();intp=p.nextInt();//讀取數值p.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 399 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 400 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubles,doubleJ,doublet2)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 401 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(Z6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterR1=(Letter)other;returnL.compareTo(R1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]q6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:q6)letter.compareTo(letter);for(Letterletter:q6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 402 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 403 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringa,Stringz0,StringR3,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 404 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 405 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringG7,Stringa0,Stringl3,Stringi3,Stringc7){super(G7,a0,l3,i3,c7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 406 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 407 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 408 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]o8){l7.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 409 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 410 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(V2,s1,y);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 411 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 412 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 413 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 414 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:O3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 415 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，I9,x3是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringI9;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 416 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 417 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 418 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 419 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 420 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 421 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 422 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=f8.nextInt();doublel9=f8.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerf8=newScanner();intK9=f8.nextInt();//讀取數值f8.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 423 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterJ1=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 424 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 425 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 426 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.B0=B0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 427 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 428 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringU6,StringH2,StringM4,StringC0,Stringe7){super(U6,H2,M4,C0,e7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 429 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 430 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 431 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 432 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2s6newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 433 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數O3會衝突,導致O3無法傳遞,建議在Class中宣告O3即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intp2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 434 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=G9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 435 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringg2,Stringy,StringV9,StringC0,StringZ5){super(g2,y,V9,C0,Z5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 436 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 437 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 438 =====
=====標準答案=====<BOM>Envelope擁有Letter的Y1物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+M0+","+Y1.getSender());System.out.println("To:"+w7+","+Y1.getReceiver()+""+Y1.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 439 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 440 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 441 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.U2=U2;this.M2=M2;this.D3=D3;重複定義只需要returnb4=U2*M2*D3;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 442 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 443 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 444 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 445 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成J3.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 446 =====
=====標準答案=====<BOM>x0變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperx0=newKeeper(...);Pets8=newPet(...,x0);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(G1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringl,Stringv0,StringG1,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Pets8=newPet(D6,u4,n5,x0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 447 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 448 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterf2=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 449 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如b，M8，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 450 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterw=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");w.display();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 451 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 452 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 453 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleI8=X(z9);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 454 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 455 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 456 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 457 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 458 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 459 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleZ7,doubleD,doubleC6)publicstaticdoubleVolume(doubleZ7,doubleD,doubleC6)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleZ7=scanner.nextDouble();System.out.println("輸入寬");doubleD=scanner.nextDouble();System.out.println("輸入高");doubleC6=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.Z7=Z7;this.D=D;this.C6=C6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 460 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 461 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(T8.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringC0,StringU4,Stringy7,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 462 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如C1.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 463 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 464 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 465 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 466 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 467 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 468 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 469 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的K2與englishletter與letter就可刪除Stringm,...;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 470 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 471 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"M7","b"};例如，本程式的MyMathUtil類別，需改成String[]P0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 472 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 473 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerd4=newScanner();intp=d4.nextInt();//讀取數值d4.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 474 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 475 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如l5.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 476 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 477 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 478 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 479 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleo1=X(R2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 480 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 481 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnI6;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 482 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerf7=newScanner();intg3=f7.nextInt();//讀取數值f7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為T2[y1]，若寫成T2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 483 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，Q1.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 484 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 485 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 486 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 487 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 488 =====
=====標準答案=====<BOM>按順序應為s3,Y6,v8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 489 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 490 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringx4,StringT3,Stringx1,StringF1,StringS6){super(x4,T3,x1,F1,S6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 491 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 492 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 493 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 494 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 495 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringG7="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 496 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);K0=scanner.nextInt();t1=scanner.nextInt();X5=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublec1;publicdoubleb9;publicdoubleV4;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublec1;publicdoubleb9;publicdoubleV4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 497 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterb0=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");b0.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 498 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 499 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerx7=newScanner();intX8=x7.nextInt();//讀取數值x7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為Q0[R4]，若寫成Q0[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 500 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 501 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成A6.equals("貓")，A6.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 502 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringk2,Stringl6,Stringp9){this.k2=k2;this.l6=l6;this.p9=p9;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 503 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入H2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 504 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intg1){...returng1;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleZ7=X(Z9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 505 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 506 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 507 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 508 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 509 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 510 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 511 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 512 =====
=====標準答案=====<BOM>T0變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(I0,N3);透過Keeper建構子，將I0與N3的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringe,Stringf,Stringi3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 513 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 514 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h0,my=m7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 515 =====
=====標準答案=====<BOM>按順序應為W4,X2,C3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 516 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringy,Stringu1,Stringu6,Stringu3,StringJ2){super(y,u1,u6,u3,J2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 517 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用w8.display()顯示內容，此外N0.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 518 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 519 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]M6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 520 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 521 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerQ9=newScanner();intU4=Q9.nextInt();//讀取數值Q9.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為B4[t8]，若寫成B4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 522 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 523 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 524 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=V8,my=i3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 525 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]s0){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 526 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 527 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 528 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 529 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 530 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(M0.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中s5等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:u.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Strings5,StringQ,StringM0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 531 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 532 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 533 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringf2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 534 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]m5){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 535 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 536 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 537 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 538 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，z9.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 539 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 540 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(N)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 541 =====
=====標準答案=====<BOM>按順序應為r1,F0,U1。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 542 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入k9.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 543 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 544 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 545 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 546 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 547 =====
=====標準答案=====<BOM>S5變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperH=newKeeper(...);PetL8=newPet(...,H);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立S5物件變數的值，例如，publicPet(Stringq8,StringO1,Stringn3,KeeperS5){...this.S5=S5;}Pet建構子內已有S5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetL8=newPet(q8,O1,n3,H);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 548 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 549 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的T2物件資料所以在呼叫T2的物件動作的時候應加上System.out.println("From:"+N4+","+T2.getSender());System.out.println("To:"+Z3+","+T2.getReceiver()+""+T2.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 550 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 551 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 552 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 553 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:p8.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 554 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 555 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 556 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerP4=newScanner();intl4=P4.nextInt();//讀取數值P4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為p5[l9]，若寫成p5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 557 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 558 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 559 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 560 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 561 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 562 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 563 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 564 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.a1=a1this.z2=z2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 565 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 566 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(V6.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中e8等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:q5.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringe8,Stringe6,StringV6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 567 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 568 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 569 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入X3.o2=2;X3.R=2;X3.t3=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleo2=kb.nextDouble();doubleR=kb.nextDouble();doublet3=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 570 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入y5.c=2;y5.E1=2;y5.d7=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublec=kb.nextDouble();doubleE1=kb.nextDouble();doubled7=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 571 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]a5={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 572 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 573 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 574 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 575 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringS9,J4,S2,M,y0;Letter(StringS9,StringJ4,StringS2,StringM,Stringy0){this.S9=S9;this.J4=J4;this.S2=S2;this.M=M;this.y0=y0;}publicStringgetSender(){returnM;}publicStringgetReceiver(){returnJ4;}publicStringgetDate(){returny0;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 576 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]n7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 577 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerJ=newScanner();intN8=J.nextInt();//讀取數值J.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為K4[s6]，若寫成K4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 578 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 579 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 580 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 581 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 582 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 583 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]C2){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 584 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(h6.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中G8等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:B5.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringG8,StringY,Stringh6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 585 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.B8=B8this.y0=y0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 586 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(e3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringr2,StringP2,StringG2,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 587 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 588 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 589 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 590 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 591 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 592 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 593 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letteru9=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 594 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperL3=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,L3);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 595 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為list[i]，若寫成list[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 596 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如C，i8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 597 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringC1,Stringb3,StringX,Stringh0){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(C1,b3,X,h0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 598 =====
=====標準答案=====<BOM>按順序應為X2,s3,C2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 599 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 600 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 601 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationm7=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationm7;m7=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 602 =====
=====標準答案=====<BOM>按順序應為z1,K9,V6。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 603 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 604 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 605 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringU4,StringN8,Stringd5){this.U4=U4;this.N8=N8;this.d5=d5;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 606 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k6，f4，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterr5=(EnglishLetter)R6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectr5){LetterR6=(Letter)r5;returnR8.compareTo(R6.getDate());}先將原本宣告成Object的R6強制轉換成Letter類別型態這樣R6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 607 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數u5會衝突,導致u5無法傳遞,建議在Class中宣告u5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。inty4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 608 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 609 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intr5){...returnr5;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleN0=X(W8);<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 610 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=i7.getSender();StringReceiver=i7.getReceiver();StringTitle=i7.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 611 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 612 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的n7物件資料所以在呼叫n7的物件動作的時候應加上System.out.println("From:"+E2+","+n7.getSender());System.out.println("To:"+G7+","+n7.getReceiver()+""+n7.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 613 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringJ8,Stringp3,Stringj9,StringU5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(J8,p3,j9,U5);<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 614 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 615 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數v7會衝突,導致v7無法傳遞,建議在Class中宣告v7即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intS2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 616 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，S9.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行Z2Z2:<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 617 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 618 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 619 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=U5,my=x5<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 620 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV2=newScanner();intp=V2.nextInt();//讀取數值V2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 621 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 622 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.L9=L9;this.E7=E7;this.m=m;重複定義只需要returng5=L9*E7*m;<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 623 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.O0=O0<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 624 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 625 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 626 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行w3.D2在呼叫w3物件中的物件資料時,應呼叫getSender()來回傳returnD2<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 627 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]g9){I4.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 628 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 629 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 630 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(t5+""+v5+",您好");System.out.println(r6);System.out.println(U4+"敬上");System.out.println(N2);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 631 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入J2.display();<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 632 =====
=====標準答案=====<BOM>Envelop第10行U9.n9在呼叫U9物件中的物件資料時,應呼叫getSender()來回傳returnn9Envelop第11行的U9.V3/U9.k4與上述例子相同<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 633 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 634 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 635 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 636 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 637 =====
=====標準答案=====<BOM>按順序應為Q4,G5,s8。<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 638 =====
=====標準答案=====<BOM>StringP0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]P0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]P1){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 639 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=d0,my=g9<EOM>
=====預測答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
Meteor_Score : 0.0

===== 640 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如T6，p8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 641 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 642 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 643 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.Q5=Q5;this.Y7=Y7;this.N7=N7;重複定義只需要returnb2=Q5*Y7*N7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 644 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數t6會衝突,導致t6無法傳遞,建議在Class中宣告t6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intS1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 645 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，d4變數型態為Int，v6變數型態為Int，s6變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:m,w9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 646 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 647 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 648 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=r0,my=W<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 649 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 650 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 651 =====
=====標準答案=====<BOM>按順序應為X7,o8,B5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 652 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 653 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 654 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入l4.C1=2;l4.R6=2;l4.N8=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleC1=kb.nextDouble();doubleR6=kb.nextDouble();doubleN8=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 655 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 656 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.S8=S8;this.k4=k4;this.v4=v4;重複定義只需要returnd6=S8*k4*v4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 657 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 658 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 659 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成V5.equals("貓")，V5.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 660 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 661 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 662 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationQ6=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationQ6;Q6=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 663 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 664 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 665 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 666 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 667 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringj7,StringY7,StringP9,Stringw8,StringY8){super(j7,Y7,P9,w8,Y8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 668 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(J7+""+L1+",您好");System.out.println(r0);System.out.println(v5+"敬上");System.out.println(m0);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 669 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 670 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 671 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h5,my=T<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 672 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleC2,doubleA,doubler9)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 673 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 674 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 675 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 676 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(L8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh5=(Letter)other;returnB.compareTo(h5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]T2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:T2)letter.compareTo(letter);for(Letterletter:T2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 677 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]L0){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 678 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxP1=newKKBOx(l,w,h);呼叫時可用P1.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 679 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 680 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(p1,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(StringF1,Stringp5)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 681 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringz9="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 682 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 683 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringx8,C8,M6,j8,E3;Letter(Stringx8,StringC8,StringM6,Stringj8,StringE3){this.x8=x8;this.C8=C8;this.M6=M6;this.j8=j8;this.E3=E3;}publicStringgetSender(){returnj8;}publicStringgetReceiver(){returnC8;}publicStringgetDate(){returnE3;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 684 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(u6.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 685 =====
=====標準答案=====<BOM>變數名稱t0重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 686 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]G6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 687 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 688 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.V9=V9this.J6=J6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 689 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 690 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 691 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(q4+""+B1+",您好");System.out.println(Q2);System.out.println(O+"敬上");System.out.println(h);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 692 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如t4=i;應改成i=t4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 693 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 694 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 695 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 696 =====
=====標準答案=====<BOM>Stringy8={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]y8={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]N4){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 697 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=T7,my=M2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 698 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 699 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 700 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 701 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 702 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 703 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 704 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterg6=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");g6.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 705 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 706 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 707 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 708 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 709 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=Z4.getSender();StringReceiver=Z4.getReceiver();StringTitle=Z4.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 710 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如a0=i;應改成i=a0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 711 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 712 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleZ4,doublew2,doubleb3)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 713 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 714 =====
=====標準答案=====<BOM>變數名稱X1重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 715 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 716 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnm7;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 717 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 718 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"h7","b"};例如，本程式的MyMathUtil類別，需改成String[]s6={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 719 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnt3;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 720 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 721 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入S4.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 722 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(I0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterq4=(Letter)other;returnS5.compareTo(q4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]m1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:m1)letter.compareTo(letter);for(Letterletter:m1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 723 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 724 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intN9,...,Stringtestdate,...){super(N9,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 725 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=q9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 726 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 727 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperQ9=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,Q9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 728 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 729 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 730 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 731 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringz4,Stringr0,Stringf4,StringA9,StringB6){super(z4,r0,f4,A9,B6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 732 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 733 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 734 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 735 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 736 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intx9){x9=3;returnx9;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleB=X(L9);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 737 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 738 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 739 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 740 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.q1=q1this.X=X<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 741 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 742 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationm2=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationm2;m2=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 743 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerz=newScanner();intR7=z.nextInt();//讀取數值z.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為r2[E8]，若寫成r2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 744 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intV4){...returnV4;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleN1=X(l8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 745 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=E1,my=C8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 746 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 747 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnx;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 748 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]v6){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 749 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringR6,Stringf7,StringA1,StringJ4,Stringf0){super(R6,f7,A1,J4,f0)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringR6,Stringf7,StringA1,StringJ4,Stringf0){super(R6,f7,A1,J4,f0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 750 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 751 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 752 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.j2=j2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 753 =====
=====標準答案=====<BOM>按順序應為t7,x2,e7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 754 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 755 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperU=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,U);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 756 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.z9=z9;this.H8=H8;this.e3=e3;重複定義只需要returnx2=z9*H8*e3;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 757 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 758 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringG,O6,R8,s9,y9;Letter(StringG,StringO6,StringR8,Strings9,Stringy9){this.G=G;this.O6=O6;this.R8=R8;this.s9=s9;this.y9=y9;}publicStringgetSender(){returns9;}publicStringgetReceiver(){returnO6;}publicStringgetDate(){returny9;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 759 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 760 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 761 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 762 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，l0.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 763 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(Y5+""+m8+",您好");System.out.println(W9);System.out.println(g4+"敬上");System.out.println(Q2);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 764 =====
=====標準答案=====<BOM>變數名稱重複宣告I9[q0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:I9[1],Integer.parseInt(I9[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 765 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 766 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=i5.getSender();StringReceiver=i5.getReceiver();StringTitle=i5.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 767 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:U2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 768 =====
=====標準答案=====<BOM>按順序應為f3,d7,n。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 769 =====
=====標準答案=====<BOM>變數名稱d0重複宣告。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 770 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 771 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 772 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 773 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 774 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 775 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublee7,doubleI7,doubleG3)publicstaticdoubleVolume(doublee7,doubleI7,doubleG3)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublee7=scanner.nextDouble();System.out.println("輸入寬");doubleI7=scanner.nextDouble();System.out.println("輸入高");doubleG3=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.e7=e7;this.I7=I7;this.G3=G3;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 776 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringQ6,Stringz1,StringX8,Stringj0,StringD7){super(Q6,z1,X8,j0,D7)}}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 777 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 778 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 779 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterm2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");m2.display();}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 780 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 781 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 782 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 783 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 784 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 785 =====
=====標準答案=====<BOM>Envelop第10行b.q8在呼叫b物件中的物件資料時,應呼叫getSender()來回傳returnq8Envelop第11行的b.A8/b.x2與上述例子相同<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 786 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringi8,Stringu8,Stringr2,Stringa7,StringA8){super(i8,u8,r2,a7,A8)}}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 787 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 788 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]M0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 789 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]z0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 790 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerH7=newScanner();intp=H7.nextInt();//讀取數值H7.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 791 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringg3,Stringz5,Stringm2,Stringj,StringD1){super(g3,z5,m2,j,D1)}}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 792 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 793 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringH3,Stringo9,StringF8,StringE0){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(H3,o9,F8,E0);<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 794 =====
=====標準答案=====<BOM>Envelop第10行f.A5在呼叫f物件中的物件資料時,應呼叫getSender()來回傳returnA5Envelop第11行的f.k3/f.p2與上述例子相同<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 795 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 796 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 797 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=F9,my=O8<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 798 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.G8=G8;this.M5=M5;this.O5=O5;重複定義只需要returnN4=G8*M5*O5;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 799 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用g0.display()顯示內容，此外L4.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 800 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 801 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 802 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 803 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 804 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 805 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 806 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=j9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 807 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數m1會衝突,導致m1無法傳遞,建議在Class中宣告m1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intA3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 808 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]H6){U8.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 809 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);z9=scanner.nextInt();U6=scanner.nextInt();k2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleG7;publicdoubleD4;publicdoubleK2;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleG7;publicdoubleD4;publicdoubleK2;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 810 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 811 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如u5.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 812 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:B7.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 813 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 814 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成u5.equals("貓")，u5.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 815 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 816 =====
=====標準答案=====<BOM>Strings5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]s5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]l){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 817 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 818 =====
=====標準答案=====<BOM>按順序應為W4,r4,Z3。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 819 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]l){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 820 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.E3=E3;this.s1=s1;this.j5=j5;重複定義只需要returnu0=E3*s1*j5;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 821 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 822 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 823 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 824 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"l","b"};例如，本程式的MyMathUtil類別，需改成String[]p3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 825 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 826 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 827 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 828 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleZ0=X(D0);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 829 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 830 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublej2,doublel9,doubleW9)publicstaticdoubleVolume(doublej2,doublel9,doubleW9)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublej2=scanner.nextDouble();System.out.println("輸入寬");doublel9=scanner.nextDouble();System.out.println("輸入高");doubleW9=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.j2=j2;this.l9=l9;this.W9=W9;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 831 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 832 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(V2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterj=(Letter)other;returnf0.compareTo(j.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Z5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Z5)letter.compareTo(letter);for(Letterletter:Z5)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 833 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 834 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 835 =====
=====標準答案=====<BOM>y1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepery1=newKeeper(...);PetY5=newPet(...,y1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(c.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringc,Stringr,StringT6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetY5=newPet(n0,r,v4,y1);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 836 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 837 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 838 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 839 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 840 =====
=====標準答案=====<BOM>按順序應為r,M6,J3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 841 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(G3,U2,i9);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 842 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=X3.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 843 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 844 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 845 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleH1,doubleT5,doubleP3)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 846 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成N.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 847 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，r9.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行c5c5:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 848 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(B+""+V9+",您好");System.out.println(Q4);System.out.println(Q1+"敬上");System.out.println(o1);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 849 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 850 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 851 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 852 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如z6.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 853 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 854 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 855 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(Q.equals("狗"))<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 856 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 857 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 858 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 859 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 860 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Y","b"};例如，本程式的MyMathUtil類別，需改成String[]C7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 861 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 862 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(O4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterk3=(Letter)other;returni1.compareTo(k3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Y={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Y)letter.compareTo(letter);for(Letterletter:Y)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 863 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(j2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterC9=(Letter)other;returnF6.compareTo(C9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]x5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:x5)letter.compareTo(letter);for(Letterletter:x5)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 864 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，x5.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 865 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 866 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入R3.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 867 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannery4=newScanner();intW8=y4.nextInt();//讀取數值y4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為V1[C0]，若寫成V1[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 868 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 869 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 870 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 871 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 872 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 873 =====
=====標準答案=====<BOM>按順序應為g5,g8,L8。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 874 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 875 =====
=====標準答案=====<BOM>Envelope擁有Letter的R7物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+o8+","+R7.getSender());System.out.println("To:"+l0+","+R7.getReceiver()+""+R7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 876 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 877 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 878 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 879 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerN5=newScanner();intp=N5.nextInt();//讀取數值N5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 880 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2w9newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 881 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 882 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 883 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(a),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]P3){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 884 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterF8=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 885 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublex,doublef3,doubleh3)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 886 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]M9={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 887 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]o9={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 888 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，a7.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 889 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringY8,StringT6,Stringc,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 890 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(d5.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringi9,Stringk)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將d5.Speak()改為Q0.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperQ0=newKeeper(i9,k);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringd5,Stringe2,StringA5,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 891 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 892 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=A6;tel=L4;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 893 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 894 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 895 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的l9物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 896 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如q4.equals("dog")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 897 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 898 =====
=====標準答案=====<BOM>Stringp8={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]p8={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Q6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 899 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 900 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 901 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(x1.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中n2等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:e8.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringn2,Strings4,Stringx1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 902 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 903 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 904 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 905 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=S0.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 906 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]x4){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 907 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 908 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Q5與englishletter與letter就可刪除Stringv9,...;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 909 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 910 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 911 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 912 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublej9=X(P1);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 913 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 914 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.B7;}publicStringgetTitle(){returnthis.e0;}//可取得v8publicStringgetReceiver(){returnthis.v8;}//可取得vpublicStringgetDate(){returnthis.v;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 915 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 916 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=O1,my=i4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 917 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 918 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行q8.z6在呼叫q8物件中的物件資料時,應呼叫getSender()來回傳returnz6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 919 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 920 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]P4){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 921 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringu9,StringF0,Stringg7,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 922 =====
=====標準答案=====<BOM>按順序應為T9,g4,K8。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 923 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.T9=T9<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 924 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 925 =====
=====標準答案=====<BOM>K9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperK9=newKeeper(...);Petpet=newPet(...,K9);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petu7=newPet(S1,E5,v2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(v2.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立K9物件變數的值，例如，publicPet(StringS1,StringE5,Stringv2,KeeperK9){...this.K9=K9;}Pet建構子內已有K9參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petu7=newPet(S1,E5,v2,E);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫K9.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...K9.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 926 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.s6=s6;this.S=S;this.O1=O1;重複定義只需要returnh0=s6*S*O1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 927 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 928 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 929 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如r4=i;應改成i=r4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 930 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 931 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 932 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 933 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(d8,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringm5,StringO7)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 934 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 935 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 936 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 937 =====
=====標準答案=====<BOM>變數名稱重複宣告g[G6]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g[1],Integer.parseInt(g[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 938 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=R7.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 939 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerO3=newScanner();intp=O3.nextInt();//讀取數值O3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 940 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]C0){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 941 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:x2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 942 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 943 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.f=fthis.I=I<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 944 =====
=====標準答案=====<BOM>x5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperx5=newKeeper(...);Peta8=newPet(...,x5);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(m3.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringm9,Stringf7,Stringm3,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Peta8=newPet(W9,B4,X2,x5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 945 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterB3=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");B3.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 946 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 947 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"z4","b"};例如，本程式的MyMathUtil類別，需改成String[]t3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 948 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.Y3;}publicStringgetTitle(){returnthis.V8;}//可取得M0publicStringgetReceiver(){returnthis.M0;}//可取得b7publicStringgetDate(){returnthis.b7;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 949 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 950 =====
=====標準答案=====<BOM>D7變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperD7=newKeeper(...);Petpet=newPet(...,D7);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petp6=newPet(P6,h8,w9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(w9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立D7物件變數的值，例如，publicPet(StringP6,Stringh8,Stringw9,KeeperD7){...this.D7=D7;}Pet建構子內已有D7參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petp6=newPet(P6,h8,w9,P7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫D7.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...D7.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 951 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 952 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 953 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 954 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringT4,Stringr7,Stringg4,Stringp9,StringG0){super(T4,r7,g4,p9,G0)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringT4,Stringr7,Stringg4,Stringp9,StringG0){super(T4,r7,g4,p9,G0)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 955 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"c1","b"};例如，本程式的MyMathUtil類別，需改成String[]I4={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 956 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 957 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]J9={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 958 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.M0=M0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 959 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringd5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 960 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 961 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 962 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 963 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringC9,Stringo1,StringJ2){this.C9=C9;this.o1=o1;this.J2=J2;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 964 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 965 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 966 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 967 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]a){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 968 =====
=====標準答案=====<BOM>X1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperX1=newKeeper(...);PetZ0=newPet(...,X1);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(I7.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringe1,StringY3,StringI7,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetZ0=newPet(F4,P2,R7,X1);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 969 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 970 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 971 =====
=====標準答案=====<BOM>按順序應為O8,C9,N。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 972 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 973 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.n8=n8this.M8=M8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 974 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 975 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 976 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringM9,Stringk3,StringP1,StringD9,Strings1){super(M9,k3,P1,D9,s1)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 977 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperw5=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,w5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 978 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 979 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannert5=newScanner();intY4=t5.nextInt();//讀取數值t5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為v5[x6]，若寫成v5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 980 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=G9,my=t3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 981 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 982 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 983 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如x5，n1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterq0=(EnglishLetter)D8;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectq0){LetterD8=(Letter)q0;returny0.compareTo(D8.getDate());}先將原本宣告成Object的D8強制轉換成Letter類別型態這樣D8就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 984 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的s2物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 985 =====
=====標準答案=====<BOM>變數名稱重複宣告a8[o2]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:a8[1],Integer.parseInt(a8[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 986 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 987 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Y1","b"};例如，本程式的MyMathUtil類別，需改成String[]A1={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 988 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 989 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 990 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(z.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterV8=(Letter)other;returnG2.compareTo(V8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]n0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:n0)letter.compareTo(letter);for(Letterletter:n0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 991 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 992 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 993 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行F4.w2在呼叫F4物件中的物件資料時,應呼叫getSender()來回傳returnw2<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 994 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如I0.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 995 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 996 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 997 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 998 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]args){lt.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 999 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1000 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.K6=K6<EOM>
=====預測答案=====<BOM>a變數名稱=0,前加出之用。<EOM>
Meteor_Score : 0.0

===== 1001 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLettero2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");o2.display();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1002 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1003 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1004 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1005 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1006 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(S8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh2=(Letter)other;returnT6.compareTo(h2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]l6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:l6)letter.compareTo(letter);for(Letterletter:l6)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1007 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入s2.U7=2;s2.I2=2;s2.U0=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleU7=kb.nextDouble();doubleI2=kb.nextDouble();doubleU0=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1008 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubley1=X(I0);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1009 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperJ6=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,J6);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1010 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如O2，Z9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1011 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1012 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數Q1會衝突,導致Q1無法傳遞,建議在Class中宣告Q1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intD9=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1013 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1014 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1015 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"a1","b"};例如，本程式的MyMathUtil類別，需改成String[]F0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1016 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1017 =====
=====標準答案=====<BOM>按順序應為E3,Q6,z0。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1018 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如N，l5，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterI=(EnglishLetter)k6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectI){Letterk6=(Letter)I;returnx5.compareTo(k6.getDate());}先將原本宣告成Object的k6強制轉換成Letter類別型態這樣k6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1019 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1020 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1021 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1022 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如v7.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1023 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(s0.equals("貓"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1024 =====
=====標準答案=====<BOM>變數名稱W7重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(H0.equals("0")==false)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1025 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1026 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1027 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxs9=newKKBOx(l,w,h);呼叫時可用s9.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1028 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的a8物件資料所以在呼叫a8的物件動作的時候應加上System.out.println("From:"+W9+","+a8.getSender());System.out.println("To:"+z4+","+a8.getReceiver()+""+a8.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1029 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]z7){z4.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1030 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1031 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublep5,doubleA8,doubler0)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1032 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1033 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=A6.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1034 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc5,Stringm0,Stringr4,Stringv8,Stringf1){super(c5,m0,r4,v8,f1)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1035 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成k5.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1036 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1037 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringO8="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1038 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]T8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1039 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1040 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1041 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringe9,StringF7,StringC4,Stringi4,StringX7){super(e9,F7,C4,i4,X7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1042 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1043 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1044 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的w9物件資料所以在呼叫w9的物件動作的時候應加上System.out.println("From:"+e6+","+w9.getSender());System.out.println("To:"+z1+","+w9.getReceiver()+""+w9.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1045 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1046 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如H0.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1047 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1048 =====
=====標準答案=====<BOM>按順序應為B,H2,k9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1049 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);c4=scanner.nextInt();K4=scanner.nextInt();j1=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleU1;publicdoublek8;publicdoubleR;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleU1;publicdoublek8;publicdoubleR;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1050 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1051 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1052 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1053 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1054 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1055 =====
=====標準答案=====<BOM>i8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperi8=newKeeper(...);Petpet=newPet(...,i8);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petf2=newPet(W7,k1,G9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(G9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立i8物件變數的值，例如，publicPet(StringW7,Stringk1,StringG9,Keeperi8){...this.i8=i8;}Pet建構子內已有i8參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petf2=newPet(W7,k1,G9,K8);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫i8.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...i8.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1056 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]U0){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1057 =====
=====標準答案=====<BOM>變數名稱V1重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1058 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1059 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1060 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如v2，m9，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1061 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.G0=G0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1062 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:W9=newExam(L0,D1,j6,q4,d3,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]a){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1063 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的K物件資料所以在呼叫K的物件動作的時候應加上System.out.println("From:"+h3+","+K.getSender());System.out.println("To:"+W+","+K.getReceiver()+""+K.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1064 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1065 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1066 =====
=====標準答案=====<BOM>按順序應為K7,x0,W4。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1067 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=h1,my=q2<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1068 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1069 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublem,doubleb0,doubleh4)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1070 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1071 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1072 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1073 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1074 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);s=scanner.nextInt();Y0=scanner.nextInt();h2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublet8;publicdoubleP;publicdoubleo0;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublet8;publicdoubleP;publicdoubleo0;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1075 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成c5.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1076 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringV2,p7,E7,g3,J3;Letter(StringV2,Stringp7,StringE7,Stringg3,StringJ3){this.V2=V2;this.p7=p7;this.E7=E7;this.g3=g3;this.J3=J3;}publicStringgetSender(){returng3;}publicStringgetReceiver(){returnp7;}publicStringgetDate(){returnJ3;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1077 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterC0=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1078 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1079 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1080 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，Y8,m9是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringY8;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1081 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(Q2.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringk,Stringo5,StringQ2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1082 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringb6="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1083 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringr7,Stringx,Stringf0,Stringh7,Stringe8){super(r7,x,f0,h7,e8)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringr7,Stringx,Stringf0,Stringh7,Stringe8){super(r7,x,f0,h7,e8)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1084 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1085 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1086 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.Z2=Z2<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1087 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1088 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(L6)無法回傳double。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1089 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(A,m7,q5);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1090 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1091 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1092 =====
=====標準答案=====<BOM>StringH5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]H5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]M8){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1093 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1094 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1095 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intt2){...returnt2;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublew=X(A2);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1096 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成Y7.equals("貓")，Y7.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1097 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如V，V1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1098 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.g=g;this.j9=j9;this.R8=R8;重複定義只需要returnr1=g*j9*R8;<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1099 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入Q2.display();<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1100 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]c4={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1101 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleD7,doubleH7,doubleB5)<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1102 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringV6,Stringw7,Stringh6,Stringe3,Stringg8){super(V6,w7,h6,e3,g8)}}<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1103 =====
=====標準答案=====<BOM>變數名稱重複宣告j6[Z8]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:j6[1],Integer.parseInt(j6[2])<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1104 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1105 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1106 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);s1=scanner.nextInt();s6=scanner.nextInt();z0=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublew2;publicdoubles5;publicdoubleG2;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublew2;publicdoubles5;publicdoubleG2;<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1107 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1108 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(e6)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1109 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1110 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1111 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的I2物件資料所以在呼叫I2的物件動作的時候應加上System.out.println("From:"+T5+","+I2.getSender());System.out.println("To:"+j8+","+I2.getReceiver()+""+I2.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1112 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(R7,I1,k5);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1113 =====
=====標準答案=====<BOM>按順序應為F7,j1,H5。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1114 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1115 =====
=====標準答案=====<BOM>變數名稱重複宣告g1[k0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:g1[1],Integer.parseInt(g1[2])<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1116 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringk9="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1117 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerT7=newScanner();intp=T7.nextInt();//讀取數值T7.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1118 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1119 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1120 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1121 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1122 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數F2會衝突,導致F2無法傳遞,建議在Class中宣告F2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intB2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1123 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1124 =====
=====標準答案=====<BOM>按順序應為c8,y7,c2。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1125 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1126 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1127 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1128 =====
=====標準答案=====<BOM>變數名稱P1重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=0,<EOM>
Meteor_Score : 0.0

===== 1129 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1130 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1131 =====
=====標準答案=====<BOM>按順序應為c8,N5,b3。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1132 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入j6.display();<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1133 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行D3.O8在呼叫D3物件中的物件資料時,應呼叫getSender()來回傳returnO8<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1134 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1135 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1136 =====
=====標準答案=====<BOM>變數名稱V8重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(y8.equals("0")==false)<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1137 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1138 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.A5;}publicStringgetTitle(){returnthis.x2;}//可取得r6publicStringgetReceiver(){returnthis.r6;}//可取得Q2publicStringgetDate(){returnthis.Q2;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1139 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=D8.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1140 =====
=====標準答案=====<BOM>按順序應為K0,n2,Z。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1141 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1142 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1143 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1144 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringG3,Stringt,StringP0){this.G3=G3;this.t=t;this.P0=P0;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1145 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnv7;。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1146 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1147 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.T9=T9this.R=R<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1148 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，O5.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1149 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1150 =====
=====標準答案=====<BOM>按順序應為y5,u6,Q。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1151 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1152 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=j5,my=G6<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1153 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1154 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=K3,my=b9<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1155 =====
=====標準答案=====<BOM>按順序應為H2,f5,x0。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1156 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1157 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如S6，Y3，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1158 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成F6.equals(word)。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1159 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1160 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a,}請注確。<EOM>
Meteor_Score : 0.0

===== 1161 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:S0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1162 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的K6物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1163 =====
=====標準答案=====<BOM>Envelop第10行X5.Z2在呼叫X5物件中的物件資料時,應呼叫getSender()來回傳returnZ2Envelop第11行的X5.E/X5.Z1與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1164 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1165 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1166 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(v4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterb6=(Letter)other;returnZ7.compareTo(b6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]I0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:I0)letter.compareTo(letter);for(Letterletter:I0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1167 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterE2=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1168 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq=newScanner();intt5=q.nextInt();//讀取數值q.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為U2[M8]，若寫成U2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1169 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1170 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1171 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.r5=r5;this.n5=n5;this.k2=k2;重複定義只需要returng9=r5*n5*k2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1172 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入k9.p9=2;k9.J6=2;k9.v=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublep9=kb.nextDouble();doubleJ6=kb.nextDouble();doublev=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1173 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetteri=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");i.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1174 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:A5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1175 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.z3=z3this.m4=m4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1176 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數A5會衝突,導致A5無法傳遞,建議在Class中宣告A5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intR8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1177 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intP5,...,Stringtestdate,...){super(P5,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1178 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的W1物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1179 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerS1=newScanner();intp=S1.nextInt();//讀取數值S1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1180 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫P1中的物件動作來回傳值例:P1.getSender();而不是直接呼叫P1中的物件資料System.out.println("From:"+m2+","+P1.getSender());System.out.println("To:"+b2+","+P1.getReceiver()+""+P1.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1181 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1182 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerL3=newScanner();intj2=L3.nextInt();//讀取數值L3.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為f9[A6]，若寫成f9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1183 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1184 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1185 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1186 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerC0=newScanner();intF2=C0.nextInt();//讀取數值C0.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為u[B0]，若寫成u[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1187 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(j.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettern0=(Letter)other;returnA.compareTo(n0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t1)letter.compareTo(letter);for(Letterletter:t1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1188 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1189 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如R4，j5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1190 =====
=====標準答案=====<BOM>按順序應為x6,A1,h9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1191 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，O4變數型態為Int，b6變數型態為Int，V5變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:J7,z0為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1192 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(W7+""+F9+",您好");System.out.println(q4);System.out.println(C7+"敬上");System.out.println(o5);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1193 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1194 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:E2=newExam(p3,A8,X4,U8,J0,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]h8){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1195 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1196 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1197 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1198 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1199 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleY0=X(Y7);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1200 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1201 =====
=====標準答案=====<BOM>按順序應為V,j2,M。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1202 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，F.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1203 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如q3，o1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterp2=(EnglishLetter)O3;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectp2){LetterO3=(Letter)p2;returnK5.compareTo(O3.getDate());}先將原本宣告成Object的O3強制轉換成Letter類別型態這樣O3就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1204 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1205 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1206 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1207 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"x8","b"};例如，本程式的MyMathUtil類別，需改成String[]S6={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1208 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]B1={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1209 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1210 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=s6,my=f7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1211 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1212 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]Y4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1213 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1214 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如s1，q5，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterd4=(EnglishLetter)S7;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectd4){LetterS7=(Letter)d4;returnG4.compareTo(S7.getDate());}先將原本宣告成Object的S7強制轉換成Letter類別型態這樣S7就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1215 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1216 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如G1，D3，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1217 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1218 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringn9,StringD1,Stringq3,Stringb8,StringQ7){super(n9,D1,q3,b8,Q7)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1219 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=y5,my=Q9<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1220 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=A7,my=U0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1221 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]u6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1222 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1223 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1224 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數x會衝突,導致x無法傳遞,建議在Class中宣告x即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intm8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1225 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1226 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1227 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=R3,my=X1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1228 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，u7,B0是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringu7;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1229 =====
=====標準答案=====<BOM>t9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepert9=newKeeper(...);Petpet=newPet(...,t9);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petg2=newPet(h2,s0,N6);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(N6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立t9物件變數的值，例如，publicPet(Stringh2,Strings0,StringN6,Keepert9){...this.t9=t9;}Pet建構子內已有t9參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petg2=newPet(h2,s0,N6,E3);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫t9.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...t9.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1230 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intK6){...returnK6;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublee2=X(p);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1231 =====
=====標準答案=====<BOM>a1變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperV=newKeeper(...);Petj9=newPet(...,V);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立a1物件變數的值，例如，publicPet(Stringm8,StringJ0,StringS1,Keepera1){...this.a1=a1;}Pet建構子內已有a1參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petj9=newPet(m8,J0,S1,V);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1232 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1233 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1234 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublep0,doubley7,doubler3)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1235 =====
=====標準答案=====<BOM>按順序應為F9,H1,X9。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1236 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1237 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1238 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationg9=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationg9;g9=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1239 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerp0=newScanner();intK7=p0.nextInt();//讀取數值p0.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為k9[s9]，若寫成k9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1240 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=f0.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1241 =====
=====標準答案=====<BOM>變數名稱重複宣告N6[p4]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:N6[1],Integer.parseInt(N6[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1242 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(d2,e7,V2);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1243 =====
=====標準答案=====<BOM>按順序應為b3,v5,s4。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1244 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1245 =====
=====標準答案=====<BOM>按順序應為K0,T,Z3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1246 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(e9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterL0=(Letter)other;returnL4.compareTo(L0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]H={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:H)letter.compareTo(letter);for(Letterletter:H)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1247 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1248 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1249 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1250 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數G9會衝突,導致G9無法傳遞,建議在Class中宣告G9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intw7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1251 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1252 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1253 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1254 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]d4){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1255 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1256 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(Z0),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]r3){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1257 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1258 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1259 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW8,StringM5,Stringp3,StringK0,Stringl4){super(W8,M5,p3,K0,l4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1260 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1261 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]B){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1262 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.m7=m7this.j8=j8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1263 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1264 =====
=====標準答案=====<BOM>b7,k3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperb7=newKeeper(...);Petp2=newPet(...,b7);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringD8,StringB4,StringY2,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petp2=newPet(D8,B4,Y2,b7);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1265 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1266 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1267 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1268 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如u9，p2，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1269 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1270 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"f1","b"};例如，本程式的MyMathUtil類別，需改成String[]x3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1271 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，b1變數型態為Int，v6變數型態為Int，e8變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:K3,C5為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1272 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數h0會衝突,導致h0無法傳遞,建議在Class中宣告h0即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intx7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1273 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1274 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數I8會衝突,導致I8無法傳遞,建議在Class中宣告I8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intQ3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1275 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1276 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1277 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1278 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringW4,Stringm6,StringZ3){this.W4=W4;this.m6=m6;this.Z3=Z3;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1279 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1280 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringY,StringB1,Stringz5,Stringa2,StringH2){super(Y,B1,z5,a2,H2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1281 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);v6=scanner.nextInt();A=scanner.nextInt();I1=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublew;publicdoubleJ9;publicdoubleK9;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublew;publicdoubleJ9;publicdoubleK9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1282 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterT=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");T.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1283 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1284 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);v4=scanner.nextInt();l1=scanner.nextInt();Q4=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleu6;publicdoubleJ0;publicdoubleT5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleu6;publicdoubleJ0;publicdoubleT5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1285 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1286 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1287 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1288 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1289 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2b0newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1290 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperi8=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,i8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1291 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]A7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1292 =====
=====標準答案=====<BOM>變數名稱o9重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(Q9.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1293 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1294 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.F0=F0;this.c7=c7;this.k0=k0;重複定義只需要returnH5=F0*c7*k0;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1295 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1296 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1297 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=m1.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1298 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1299 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(o6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringM2,StringU6,StringM4,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1300 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1301 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleB7,doublek5,doublew0)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1302 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=V7.nextInt();doubleU4=V7.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV7=newScanner();intI1=V7.nextInt();//讀取數值V7.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1303 =====
=====標準答案=====<BOM>StringJ={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]J={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]r6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1304 =====
=====標準答案=====<BOM>L,c5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperL=newKeeper(...);PetG5=newPet(...,L);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringW6,Stringl5,StringZ2,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetG5=newPet(W6,l5,Z2,L);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1305 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1306 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成B6.equals("貓")，B6.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1307 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(y5.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringT5,StringD6)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將y5.Speak()改為d.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperd=newKeeper(T5,D6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringy5,StringU1,Stringk9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1308 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1309 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1310 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1311 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1312 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV5=newScanner();intA8=V5.nextInt();//讀取數值V5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為k2[p1]，若寫成k2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1313 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1314 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(z6),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]f8){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1315 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterU9=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");U9.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1316 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1317 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1318 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1319 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1320 =====
=====標準答案=====<BOM>按順序應為H5,M1,o2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1321 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=c3.getSender();StringReceiver=c3.getReceiver();StringTitle=c3.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1322 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringc0,StringZ9,Strings4,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1323 =====
=====標準答案=====<BOM>J6變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperJ6=newKeeper(...);Petpet=newPet(...,J6);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetW9=newPet(i1,V6,y2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(y2.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立J6物件變數的值，例如，publicPet(Stringi1,StringV6,Stringy2,KeeperJ6){...this.J6=J6;}Pet建構子內已有J6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetW9=newPet(i1,V6,y2,J7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫J6.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...J6.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1324 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1325 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1326 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1327 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringI6,Stringl1,StringI,Stringu2){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(I6,l1,I,u2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1328 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1329 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]S1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1330 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.v3=v3this.e9=e9<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1331 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=M6,my=J0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1332 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1333 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的v4與englishletter與letter就可刪除StringG5,...;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1334 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublex8,doublet0,doubleD1)publicstaticdoubleVolume(doublex8,doublet0,doubleD1)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublex8=scanner.nextDouble();System.out.println("輸入寬");doublet0=scanner.nextDouble();System.out.println("輸入高");doubleD1=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.x8=x8;this.t0=t0;this.D1=D1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1335 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intO0,...,Stringtestdate,...){super(O0,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1336 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1337 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]K2={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1338 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的F5物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1339 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=f2.getSender();StringReceiver=f2.getReceiver();StringTitle=f2.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1340 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.o3=o3this.j4=j4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1341 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1342 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleW1,doubled3,doubleI8)publicstaticdoubleVolume(doubleW1,doubled3,doubleI8)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleW1=scanner.nextDouble();System.out.println("輸入寬");doubled3=scanner.nextDouble();System.out.println("輸入高");doubleI8=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.W1=W1;this.d3=d3;this.I8=I8;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1343 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.K4;}publicStringgetTitle(){returnthis.f1;}//可取得r0publicStringgetReceiver(){returnthis.r0;}//可取得P4publicStringgetDate(){returnthis.P4;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1344 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1345 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE,Stringf3,Stringy6,StringC0,Stringm2){super(E,f3,y6,C0,m2)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringE,Stringf3,Stringy6,StringC0,Stringm2){super(E,f3,y6,C0,m2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1346 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(y8+""+D5+",您好");System.out.println(E8);System.out.println(u0+"敬上");System.out.println(v);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1347 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1348 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1349 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1350 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringb4,Stringr0,StringX3,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1351 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1352 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1353 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1354 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1355 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleK4,doublea4,doubleW3)publicstaticdoubleVolume(doubleK4,doublea4,doubleW3)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleK4=scanner.nextDouble();System.out.println("輸入寬");doublea4=scanner.nextDouble();System.out.println("輸入高");doubleW3=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.K4=K4;this.a4=a4;this.W3=W3;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1356 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleE,doubleQ2,doubleS2)publicstaticdoubleVolume(doubleE,doubleQ2,doubleS2)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleE=scanner.nextDouble();System.out.println("輸入寬");doubleQ2=scanner.nextDouble();System.out.println("輸入高");doubleS2=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.E=E;this.Q2=Q2;this.S2=S2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1357 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數S2會衝突,導致S2無法傳遞,建議在Class中宣告S2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intT6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1358 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1359 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1360 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1361 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1362 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublel8,doublem0,doublen8)publicstaticdoubleVolume(doublel8,doublem0,doublen8)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublel8=scanner.nextDouble();System.out.println("輸入寬");doublem0=scanner.nextDouble();System.out.println("輸入高");doublen8=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.l8=l8;this.m0=m0;this.n8=n8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1363 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1364 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=o.nextInt();doublem1=o.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero=newScanner();intN4=o.nextInt();//讀取數值o.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1365 =====
=====標準答案=====<BOM>變數名稱f重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1366 =====
=====標準答案=====<BOM>U5變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperZ5=newKeeper(...);PetH6=newPet(...,Z5);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立U5物件變數的值，例如，publicPet(Strings4,Stringy,Stringe1,KeeperU5){...this.U5=U5;}Pet建構子內已有U5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetH6=newPet(s4,y,e1,Z5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1367 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(V2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterQ2=(Letter)other;returnq0.compareTo(Q2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t9)letter.compareTo(letter);for(Letterletter:t9)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1368 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如w5.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1369 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如Z2，F2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterx0=(EnglishLetter)A3;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectx0){LetterA3=(Letter)x0;returnc7.compareTo(A3.getDate());}先將原本宣告成Object的A3強制轉換成Letter類別型態這樣A3就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1370 =====
=====標準答案=====<BOM>Envelop第10行w9.Y7在呼叫w9物件中的物件資料時,應呼叫getSender()來回傳returnY7Envelop第11行的w9.t8/w9.X0與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1371 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，V7,d7是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringV7;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1372 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublew5,doubleL7,doubles8應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.w5=a5;bb.L7=g8;bb.s8=j7;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.w5=a5;bb.L7=g8;bb.s8=j7;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublew5,doubleL7,doubles8沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1373 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成m0.equals("貓")，m0.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1374 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]w3){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1375 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1376 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1377 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1378 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1379 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterS2=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");S2.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1380 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1381 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1382 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1383 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=f7,my=W7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1384 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:u0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1385 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1386 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(W2.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中Q9等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:s2.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringQ9,StringG5,StringW2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1387 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1388 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如d1，d4，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLettery7=(EnglishLetter)G6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objecty7){LetterG6=(Letter)y7;returnT8.compareTo(G6.getDate());}先將原本宣告成Object的G6強制轉換成Letter類別型態這樣G6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1389 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1390 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1391 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如C3.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1392 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1393 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1394 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1395 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(F8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterm3=(Letter)other;returnn4.compareTo(m3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]O4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:O4)letter.compareTo(letter);for(Letterletter:O4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1396 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1397 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1398 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1399 =====
=====標準答案=====<BOM>m9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperm9=newKeeper(...);PetW7=newPet(...,m9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(u8.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringu8,Stringk9,StringO9,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetW7=newPet(l0,k9,U3,m9);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1400 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1401 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如Q9，R3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1402 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1403 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1404 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如Z3，g9，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1405 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1406 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1407 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1408 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的l2物件資料所以在呼叫l2的物件動作的時候應加上System.out.println("From:"+s9+","+l2.getSender());System.out.println("To:"+a8+","+l2.getReceiver()+""+l2.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1409 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1410 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneri1=newScanner();intE=i1.nextInt();//讀取數值i1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為B7[b9]，若寫成B7[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1411 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterf7=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");f7.display();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1412 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1413 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=A1.getSender();StringReceiver=A1.getReceiver();StringTitle=A1.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1414 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1415 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(v0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterd8=(Letter)other;returnq3.compareTo(d8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]n4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:n4)letter.compareTo(letter);for(Letterletter:n4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1416 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 1417 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1418 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(d2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1419 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1420 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettere2=(Letter)other;returnL1.compareTo(e2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]S={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:S)letter.compareTo(letter);for(Letterletter:S)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1421 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1422 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1423 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterS=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1424 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1425 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1426 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1427 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(B2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterR4=(Letter)other;returnO0.compareTo(R4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t4)letter.compareTo(letter);for(Letterletter:t4)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1428 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.s9=s9<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1429 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1430 =====
=====標準答案=====<BOM>v2變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperq8=newKeeper(...);PetG6=newPet(...,q8);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立v2物件變數的值，例如，publicPet(Stringp1,Stringe9,Strings5,Keeperv2){...this.v2=v2;}Pet建構子內已有v2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetG6=newPet(p1,e9,s5,q8);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1431 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1432 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1433 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1434 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:i6.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1435 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=W6.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1436 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1437 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1438 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1439 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1440 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1441 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1442 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成x7.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1443 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1444 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1445 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=j5,my=G6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1446 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.I6=I6this.O1=O1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1447 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleL1=X(G8);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1448 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1449 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數b8會衝突,導致b8無法傳遞,建議在Class中宣告b8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intM4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1450 =====
=====標準答案=====<BOM>變數名稱P9重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(X1.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1451 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的N9物件資料所以在呼叫N9的物件動作的時候應加上System.out.println("From:"+A3+","+N9.getSender());System.out.println("To:"+m8+","+N9.getReceiver()+""+N9.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1452 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，F5.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行m3m3:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1453 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如b6，N，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1454 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:E0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1455 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行x4.v3在呼叫x4物件中的物件資料時,應呼叫getSender()來回傳returnv3<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1456 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1457 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(inti3){...returni3;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleI6=X(j);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1458 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationO3=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationO3;O3=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1459 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用R5.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.X0=X0;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1460 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1461 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1462 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1463 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(P0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterp8=(Letter)other;returns.compareTo(p8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]s1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:s1)letter.compareTo(letter);for(Letterletter:s1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1464 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1465 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1466 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行m2.J在呼叫m2物件中的物件資料時,應呼叫getSender()來回傳returnJ<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1467 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.A7=A7this.n7=n7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1468 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1469 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫I5中的物件動作來回傳值例:I5.getSender();而不是直接呼叫I5中的物件資料System.out.println("From:"+n1+","+I5.getSender());System.out.println("To:"+s7+","+I5.getReceiver()+""+I5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1470 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1471 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringtitle,receiver,content,sender,date;Letter(Stringtitle,Stringreceiver,Stringcontent,Stringsender,Stringdate){this.title=title;this.receiver=receiver;this.content=content;this.sender=sender;this.date=date;}publicStringgetSender(){returnsender;}publicStringgetReceiver(){returnreceiver;}publicStringgetDate(){returndate;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1472 =====
=====標準答案=====<BOM>Stringf2={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]f2={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]W5){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1473 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1474 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(A4)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1475 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringg0;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringg0;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1476 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1477 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intK2){K2=3;returnK2;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublen=X(D0);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1478 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]t9){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1479 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"F7","b"};例如，本程式的MyMathUtil類別，需改成String[]Z8={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1480 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:p9.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1481 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1482 =====
=====標準答案=====<BOM>變數名稱L5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1483 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1484 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1485 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1486 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1487 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:l5.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1488 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.t3=t3;this.b8=b8;this.b1=b1;重複定義只需要returnq7=t3*b8*b1;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1489 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]O3){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1490 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1491 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(a0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteri=(Letter)other;returnj6.compareTo(i.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]K6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:K6)letter.compareTo(letter);for(Letterletter:K6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1492 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1493 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1494 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1495 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1496 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如u7，f4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1497 =====
=====標準答案=====<BOM>按順序應為s1,X1,q1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1498 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1499 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringp="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1500 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1501 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.E9=E9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1502 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1503 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1504 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1505 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1506 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1507 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1508 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1509 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1510 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetters1=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");s1.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1511 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1512 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(M.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterr3=(Letter)other;returnH9.compareTo(r3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]D7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:D7)letter.compareTo(letter);for(Letterletter:D7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1513 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行Q9.x7在呼叫Q9物件中的物件資料時,應呼叫getSender()來回傳returnx7<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1514 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]C4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1515 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationZ7=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationZ7;Z7=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1516 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1517 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(StringV7,Stringj4,StringW9){this.V7=V7;this.j4=j4;this.W9=W9;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1518 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1519 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如y7，R6，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1520 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1521 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1522 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringh2,Stringa7,StringQ9,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1523 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1524 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如R2，K5，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterH=(EnglishLetter)Y1;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectH){LetterY1=(Letter)H;returnF9.compareTo(Y1.getDate());}先將原本宣告成Object的Y1強制轉換成Letter類別型態這樣Y1就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1525 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1526 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:f9,P4,v8,z2為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:B3,z2為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:y3,u4為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:G4,W0為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1527 =====
=====標準答案=====<BOM>變數名稱P5重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(c5.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1528 =====
=====標準答案=====<BOM>變數名稱u0重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1529 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1530 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannert5=newScanner();intJ3=t5.nextInt();//讀取數值t5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為F3[x4]，若寫成F3[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1531 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1532 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1533 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1534 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1535 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1536 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1537 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成C1.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1538 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringT9,Stringt8,Stringj9,StringC5,StringK6){super(T9,t8,j9,C5,K6)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1539 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1540 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1541 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數F會衝突,導致F無法傳遞,建議在Class中宣告F即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intW=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1542 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1543 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=S,my=o1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1544 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱this.a,注意請注意JAVA程式的語法結構。<EOM>
Meteor_Score : 0.0

===== 1545 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerA0=newScanner();intU6=A0.nextInt();//讀取數值A0.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為E4[Z2]，若寫成E4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1546 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1547 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq5=newScanner();inty9=q5.nextInt();//讀取數值q5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為g9[p1]，若寫成g9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1548 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1549 =====
=====標準答案=====<BOM>按順序應為s3,f5,I7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1550 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1551 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1552 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringo2,Stringc0,StringJ8,Stringt8,StringW6){super(o2,c0,J8,t8,W6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1553 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如Z，G4，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1554 =====
=====標準答案=====<BOM>按順序應為T8,x7,l7。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1555 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1556 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(H2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterg8=(Letter)other;returnd1.compareTo(g8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]D6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:D6)letter.compareTo(letter);for(Letterletter:D6)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1557 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1558 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1559 =====
=====標準答案=====<BOM>按順序應為B6,K9,B5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1560 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1561 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleM7=X(u);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1562 =====
=====標準答案=====<BOM>Envelope擁有Letter的I6物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+j8+","+I6.getSender());System.out.println("To:"+C1+","+I6.getReceiver()+""+I6.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1563 =====
=====標準答案=====<BOM>按順序應為w7,O4,k4。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1564 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.y0=y0this.Z7=Z7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1565 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1566 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringF9,StringQ2,Stringr7,Stringc3,Stringm){super(F9,Q2,r7,c3,m)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1567 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1568 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1569 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1570 =====
=====標準答案=====<BOM>t7變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepert7=newKeeper(...);Pett4=newPet(...,t7);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(n8.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringn8,Stringq0,Stringa1,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Pett4=newPet(U5,q0,r9,t7);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1571 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(W0)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1572 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringo1,StringL2,StringX8,Stringu7,Stringv2){super(o1,L2,X8,u7,v2)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringo1,StringL2,StringX8,Stringu7,Stringv2){super(o1,L2,X8,u7,v2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1573 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1574 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1575 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1576 =====
=====標準答案=====<BOM>變數名稱v2重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1577 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1578 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫r中的物件動作來回傳值例:r.getSender();而不是直接呼叫r中的物件資料System.out.println("From:"+t2+","+r.getSender());System.out.println("To:"+E3+","+r.getReceiver()+""+r.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1579 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(h4.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1580 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1581 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleA0=X(t5);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1582 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]n0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1583 =====
=====標準答案=====<BOM>變數名稱重複宣告V3[J5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:V3[1],Integer.parseInt(V3[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1584 =====
=====標準答案=====<BOM>按順序應為M2,j6,v8。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1585 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1586 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1587 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);f6=scanner.nextInt();e7=scanner.nextInt();v=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleX7;publicdoubleO5;publicdoubleq5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleX7;publicdoubleO5;publicdoubleq5;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1588 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成m7.equals("貓")，m7.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1589 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1590 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1591 =====
=====標準答案=====<BOM>按順序應為r8,z3,R4。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1592 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1593 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用k0.display()顯示內容，此外E.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1594 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1595 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1596 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1597 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1598 =====
=====標準答案=====<BOM>h變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperh=newKeeper(...);Petpet=newPet(...,h);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petf8=newPet(Q9,K3,C2);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(C2.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立h物件變數的值，例如，publicPet(StringQ9,StringK3,StringC2,Keeperh){...this.h=h;}Pet建構子內已有h參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petf8=newPet(Q9,K3,C2,Z);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫h.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...h.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1599 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1600 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1601 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1602 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1603 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1604 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1605 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1606 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringO,StringB2,StringM6,StringZ9,StringS6){super(O,B2,M6,Z9,S6)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1607 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:G3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1608 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringh4,StringI,StringP7,StringN8,Stringw0){super(h4,I,P7,N8,w0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1609 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]j6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1610 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1611 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1612 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]q5={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1613 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=A5.getSender();StringReceiver=A5.getReceiver();StringTitle=A5.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1614 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1615 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1616 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1617 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1618 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1619 =====
=====標準答案=====<BOM>StringR1={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]R1={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]C3){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1620 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1621 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1622 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1623 =====
=====標準答案=====<BOM>按順序應為q0,Y6,B5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1624 =====
=====標準答案=====<BOM>按順序應為j6,g9,R3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1625 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1626 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(u8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]k){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1627 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]o6){l5.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1628 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1629 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1630 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerK8=newScanner();intp=K8.nextInt();//讀取數值K8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1631 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(O6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterE7=(Letter)other;returnW8.compareTo(E7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Q2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Q2)letter.compareTo(letter);for(Letterletter:Q2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1632 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1633 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1634 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1635 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1636 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(a1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]z2){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1637 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1638 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(obj.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettero=(Letter)other;returndate.compareTo(o.getDate());}<EOM><BOM>將第5~行修改為先將資料用Letter型態的陣列存取Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:list)letter.compareTo(letter);for(Letterletter:list)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1639 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:M2.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1640 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]A0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1641 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的E9與englishletter與letter就可刪除Stringd9,...;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1642 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1643 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1644 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1645 =====
=====標準答案=====<BOM>變數名稱Z7重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1646 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]G6={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1647 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1648 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleV6,doubleL6,doubleF0)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1649 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1650 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringF5;...，此外，ChineseLetter與EnglishLetter就可以刪除StringF5;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1651 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1652 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringi5,Stringu1,Stringb3){this.i5=i5;this.u1=u1;this.b3=b3;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1653 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:A3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1654 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperm6=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,m6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1655 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1656 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1657 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:B4.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1658 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1659 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1660 =====
=====標準答案=====<BOM>按順序應為J1,k,s。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1661 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"c2","b"};例如，本程式的MyMathUtil類別，需改成String[]z2={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1662 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1663 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1664 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1665 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1666 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1667 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);q9=scanner.nextInt();y7=scanner.nextInt();u4=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleB0;publicdoubleN5;publicdoubleU5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleB0;publicdoubleN5;publicdoubleU5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1668 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1669 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1670 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intu2){u2=3;returnu2;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublet9=X(k0);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1671 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.v8=v8;this.y7=y7;this.L6=L6;重複定義只需要returnN3=v8*y7*L6;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1672 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLettert1=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");t1.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1673 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如c5.equals("dog")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1674 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1675 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1676 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1677 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringv0,y1,q6,O8,Z1;Letter(Stringv0,Stringy1,Stringq6,StringO8,StringZ1){this.v0=v0;this.y1=y1;this.q6=q6;this.O8=O8;this.Z1=Z1;}publicStringgetSender(){returnO8;}publicStringgetReceiver(){returny1;}publicStringgetDate(){returnZ1;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1678 =====
=====標準答案=====<BOM>b9變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(C9,T4);透過Keeper建構子，將C9與T4的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringf3,Stringx4,Stringi5,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1679 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]Q7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1680 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=I2,my=s5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1681 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]u4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1682 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如z6，R6，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1683 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1684 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerp8=newScanner();intp=p8.nextInt();//讀取數值p8.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1685 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]S0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1686 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.c0;}publicStringgetTitle(){returnthis.a;}//可取得GpublicStringgetReceiver(){returnthis.G;}//可取得f8publicStringgetDate(){returnthis.f8;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1687 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1688 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1689 =====
=====標準答案=====<BOM>按順序應為k7,O2,m2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1690 =====
=====標準答案=====<BOM>變數名稱重複宣告t0[p]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:t0[1],Integer.parseInt(t0[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1691 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入B8.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1692 =====
=====標準答案=====<BOM>U3變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(n5,a4);透過Keeper建構子，將n5與a4的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringb6,StringJ4,StringY9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1693 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerE4=newScanner();intp=E4.nextInt();//讀取數值E4.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1694 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(S0)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1695 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleG3,doubleK9,doubleE2)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1696 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(e4.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterc9=(Letter)other;returnf4.compareTo(c9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]U4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:U4)letter.compareTo(letter);for(Letterletter:U4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1697 =====
=====標準答案=====<BOM>變數名稱R5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1698 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1699 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerK8=newScanner();intV2=K8.nextInt();//讀取數值K8.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為H[t6]，若寫成H[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1700 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1701 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1702 =====
=====標準答案=====<BOM>按順序應為G7,p2,n5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1703 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1704 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1705 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1706 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]p={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1707 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1708 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);r7=scanner.nextInt();w5=scanner.nextInt();F8=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleZ6;publicdoubleL1;publicdoubles6;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleZ6;publicdoubleL1;publicdoubles6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1709 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1710 =====
=====標準答案=====<BOM>t6變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperg4=newKeeper(...);PetV7=newPet(...,g4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立t6物件變數的值，例如，publicPet(Stringq8,StringG7,Stringk2,Keepert6){...this.t6=t6;}Pet建構子內已有t6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetV7=newPet(q8,G7,k2,g4);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1711 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1712 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如a5.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1713 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1714 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入c3.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1715 =====
=====標準答案=====<BOM>Envelope擁有Letter的L5物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+k4+","+L5.getSender());System.out.println("To:"+B8+","+L5.getReceiver()+""+L5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1716 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1717 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("dog")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1718 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=I1,my=p6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1719 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1720 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperw6=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,w6);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1721 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，j2.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1722 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1723 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.g4=g4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1724 =====
=====標準答案=====<BOM>G6變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(h5,S7);透過Keeper建構子，將h5與S7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringy6,StringF2,Stringp6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1725 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringa7,StringX7,StringT3,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1726 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1727 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubley0,doublet7,doubleN5應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.y0=k2;bb.t7=Y5;bb.N5=U6;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.y0=k2;bb.t7=Y5;bb.N5=U6;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubley0,doublet7,doubleN5沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1728 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1729 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringz,B2,z2,d9,Q9;Letter(Stringz,StringB2,Stringz2,Stringd9,StringQ9){this.z=z;this.B2=B2;this.z2=z2;this.d9=d9;this.Q9=Q9;}publicStringgetSender(){returnd9;}publicStringgetReceiver(){returnB2;}publicStringgetDate(){returnQ9;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1730 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Strings7,StringT6,Stringk8,StringH8,Stringl2){super(s7,T6,k8,H8,l2)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1731 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如P6=i;應改成i=P6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1732 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入e8.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1733 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationW5=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationW5;W5=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1734 =====
=====標準答案=====<BOM>變數名稱k重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1735 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]j={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1736 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1737 =====
=====標準答案=====<BOM>w5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperw5=newKeeper(...);Petpet=newPet(...,w5);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetG=newPet(X7,u7,A);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(A.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立w5物件變數的值，例如，publicPet(StringX7,Stringu7,StringA,Keeperw5){...this.w5=w5;}Pet建構子內已有w5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetG=newPet(X7,u7,A,V2);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫w5.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...w5.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1738 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1739 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxW6=newKKBOx(l,w,h);呼叫時可用W6.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1740 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1741 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringE2,StringI9,Stringl8,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1742 =====
=====標準答案=====<BOM>按順序應為A8,l4,T3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1743 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成X7.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1744 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(L6,...);Keeperk=newKeeper(g,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1745 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如o5，M0，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1746 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1747 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleY8,doubleH7,doublel應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.Y8=q2;bb.H7=A;bb.l=r9;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.Y8=q2;bb.H7=A;bb.l=r9;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleY8,doubleH7,doublel沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1748 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intQ2){Q2=3;returnQ2;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubley2=X(D);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1749 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1750 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1751 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.j3=j3this.T2=T2<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1752 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(t1)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1753 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1754 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringg2,W1,G6,i8,d5;Letter(Stringg2,StringW1,StringG6,Stringi8,Stringd5){this.g2=g2;this.W1=W1;this.G6=G6;this.i8=i8;this.d5=d5;}publicStringgetSender(){returni8;}publicStringgetReceiver(){returnW1;}publicStringgetDate(){returnd5;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1755 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成e3.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1756 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1757 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1758 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1759 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別只需要一個display，因此，需要刪除publicvoiddisplay2(){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1760 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，n4.equals("貓")，n4.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1761 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成s9.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1762 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1763 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1764 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"r9","b"};例如，本程式的MyMathUtil類別，需改成String[]J9={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1765 =====
=====標準答案=====<BOM>x3變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(H2,K5);透過Keeper建構子，將H2與K5的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringc6,StringZ7,Stringf3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1766 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.U6=U6;this.m5=m5;this.o5=o5;重複定義只需要returnN8=U6*m5*o5;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1767 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1768 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1769 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1770 =====
=====標準答案=====<BOM>J4變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(P3,m7);透過Keeper建構子，將P3與m7的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringF8,Stringj4,Stringl8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1771 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]o1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1772 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringn9,StringG3,Stringh4,StringZ1,StringA2){super(n9,G3,h4,Z1,A2)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1773 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1774 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1775 =====
=====標準答案=====<BOM>Stringy2={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]y2={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]h7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1776 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1777 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1778 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1779 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1780 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringw1,StringG3,StringF3,Stringh1,Stringf7){super(w1,G3,F3,h1,f7)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringw1,StringG3,StringF3,Stringh1,Stringf7){super(w1,G3,F3,h1,f7)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1781 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(K5),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]g0){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1782 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1783 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1784 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數T0會衝突,導致T0無法傳遞,建議在Class中宣告T0即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intr4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1785 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:u1.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1786 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=M4,my=N5<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1787 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1788 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=Z3,my=C6<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1789 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1790 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(f8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]v6){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1791 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1792 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1793 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1794 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringc3,Stringp7,StringL6,StringV5,Stringh8){super(c3,p7,L6,V5,h8)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1795 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1796 =====
=====標準答案=====<BOM>StringI={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]I={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]b2){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1797 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(Q3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettere4=(Letter)other;returny8.compareTo(e4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]E6={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:E6)letter.compareTo(letter);for(Letterletter:E6)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1798 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterd7=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1799 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1800 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(I8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterd6=(Letter)other;returnG9.compareTo(d6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]w9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:w9)letter.compareTo(letter);for(Letterletter:w9)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1801 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]p2={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1802 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringr1,d0,n6,l6,Y3;Letter(Stringr1,Stringd0,Stringn6,Stringl6,StringY3){this.r1=r1;this.d0=d0;this.n6=n6;this.l6=l6;this.Y3=Y3;}publicStringgetSender(){returnl6;}publicStringgetReceiver(){returnd0;}publicStringgetDate(){returnY3;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1803 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1804 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1805 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(ints){...returns;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublel4=X(Y6);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1806 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1807 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1808 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]s6){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1809 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k5，Y3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterm1=(EnglishLetter)n6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectm1){Lettern6=(Letter)m1;returnR6.compareTo(n6.getDate());}先將原本宣告成Object的n6強制轉換成Letter類別型態這樣n6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1810 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1811 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1812 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1813 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1814 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnX5;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1815 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleh9,doublec,doublea0應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.h9=H1;bb.c=c2;bb.a0=i4;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.h9=H1;bb.c=c2;bb.a0=i4;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleh9,doublec,doublea0沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1816 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 1817 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1818 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1819 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=m1,my=N0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1820 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]I={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1821 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1822 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleR3=X(h2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1823 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerP5=newScanner();intp=P5.nextInt();//讀取數值P5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1824 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:l0.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1825 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1826 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1827 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1828 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);t1=scanner.nextInt();I2=scanner.nextInt();q2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleh6;publicdoublei0;publicdoubleN1;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleh6;publicdoublei0;publicdoubleN1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1829 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1830 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1831 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1832 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 1833 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"T8","b"};例如，本程式的MyMathUtil類別，需改成String[]J9={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1834 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(g9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterv7=(Letter)other;returnF5.compareTo(v7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]t2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:t2)letter.compareTo(letter);for(Letterletter:t2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1835 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入p3.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1836 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.p0=p0this.T0=T0<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1837 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1838 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1839 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(L5),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]z2){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1840 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringc2,Stringn1,StringU,StringC2){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(c2,n1,U,C2);<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1841 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1842 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:Y2.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1843 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1844 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]r){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1845 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleQ0,doublen9,doubles7應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.Q0=y6;bb.n9=n1;bb.s7=U0;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.Q0=y6;bb.n9=n1;bb.s7=U0;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleQ0,doublen9,doubles7沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1846 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1847 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1848 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(D5+""+W7+",您好");System.out.println(c9);System.out.println(d+"敬上");System.out.println(t6);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1849 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如f.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1850 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1851 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1852 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行g2.A0在呼叫g2物件中的物件資料時,應呼叫getSender()來回傳returnA0<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1853 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1854 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=letter.getSender();StringReceiver=letter.getReceiver();StringTitle=letter.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1855 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1856 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1857 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(G0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterR7=(Letter)other;returnz5.compareTo(R7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Z4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Z4)letter.compareTo(letter);for(Letterletter:Z4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1858 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1859 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入C7.N2=2;C7.W0=2;C7.M2=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleN2=kb.nextDouble();doubleW0=kb.nextDouble();doubleM2=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1860 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.R2=R2this.w0=w0<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1861 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1862 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1863 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerA3=newScanner();intS9=A3.nextInt();//讀取數值A3.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為b4[N6]，若寫成b4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1864 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]K0){U8.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱this.width,注意請注意JAVA程式的語法結構while("]]]類別,。<EOM>
Meteor_Score : 0.0

===== 1865 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1866 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1867 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1868 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationV1=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationV1;V1=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1869 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"A7","b"};例如，本程式的MyMathUtil類別，需改成String[]D3={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1870 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]a8={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1871 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1872 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1873 =====
=====標準答案=====<BOM>按順序應為y7,W7,P3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1874 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterp5=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1875 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1876 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1877 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫X5中的物件動作來回傳值例:X5.getSender();而不是直接呼叫X5中的物件資料System.out.println("From:"+o5+","+X5.getSender());System.out.println("To:"+l0+","+X5.getReceiver()+""+X5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1878 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1879 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1880 =====
=====標準答案=====<BOM>變數名稱U3重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1881 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1882 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1883 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublec2=X(E3);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1884 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1885 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1886 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1887 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=V3.nextInt();doubleA5=V3.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV3=newScanner();intb3=V3.nextInt();//讀取數值V3.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1888 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1889 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(t6.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringJ8,StringI5,Stringt6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1890 =====
=====標準答案=====<BOM>H3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperH3=newKeeper(...);Petd0=newPet(...,H3);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(a6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringD8,StringL1,Stringa6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petd0=newPet(p5,H7,e1,H3);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1891 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(d),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Z6){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1892 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.v6=v6;this.N9=N9;this.H4=H4;重複定義只需要returnx7=v6*N9*H4;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1893 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(a6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterT2=(Letter)other;returnL5.compareTo(T2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]h1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:h1)letter.compareTo(letter);for(Letterletter:h1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1894 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1895 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerT6=newScanner();intp=T6.nextInt();//讀取數值T6.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1896 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，n6變數型態為Int，I2變數型態為Int，K4變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:k0,E9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1897 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1898 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublei5,doubleA0,doublel3)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1899 =====
=====標準答案=====<BOM>按順序應為E2,v1,r4。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1900 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1901 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1902 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1903 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1904 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(L8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterH0=(Letter)other;returnZ7.compareTo(H0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]I0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:I0)letter.compareTo(letter);for(Letterletter:I0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1905 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1906 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1907 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1908 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，i5.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行x8x8:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1909 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringu0,StringW1,Stringx1,StringM1,Stringn2){super(u0,W1,x1,M1,n2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1910 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.l=l;this.L5=L5;this.I=I;重複定義只需要returnJ1=l*L5*I;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1911 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1912 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:m6.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1913 =====
=====標準答案=====<BOM>v8變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperb4=newKeeper(...);PetW6=newPet(...,b4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立v8物件變數的值，例如，publicPet(Stringt7,Stringl4,Stringp4,Keeperv8){...this.v8=v8;}Pet建構子內已有v8參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetW6=newPet(t7,l4,p4,b4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1914 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.B1=B1this.F1=F1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1915 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行e6.L7在呼叫e6物件中的物件資料時,應呼叫getSender()來回傳returnL7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1916 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成j1.equals("貓")，j1.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1917 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1918 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]W4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1919 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1920 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1921 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1922 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1923 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1924 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1925 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1926 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1927 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1928 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=V8,my=w6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1929 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleT1,doubleO3,doubleN)publicstaticdoubleVolume(doubleT1,doubleO3,doubleN)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleT1=scanner.nextDouble();System.out.println("輸入寬");doubleO3=scanner.nextDouble();System.out.println("輸入高");doubleN=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.T1=T1;this.O3=O3;this.N=N;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1930 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.R2=R2this.y8=y8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1931 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，S4.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1932 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannera=newScanner();intp=a.nextInt();//讀取數值a.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1933 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intI=1;類別動作(I);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1934 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.t0=t0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1935 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1936 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1937 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1938 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1939 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如A9.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1940 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k9,my=H4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1941 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1942 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1943 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1944 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.y8=y8this.l0=l0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1945 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1946 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1947 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(s3.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringZ2,Stringr4,Strings3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1948 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.i=ithis.s4=s4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1949 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1950 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(j1.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringT2,StringP9,Stringj1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1951 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1952 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數e1會衝突,導致e1無法傳遞,建議在Class中宣告e1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intQ7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1953 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1954 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=f9,my=s6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1955 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1956 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1957 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1958 =====
=====標準答案=====<BOM>StringX0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]X0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]D6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1959 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1960 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=D8,my=i2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1961 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringe7,StringQ6,StringI0,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1962 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(x.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterE1=(Letter)other;returnK1.compareTo(E1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Q8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Q8)letter.compareTo(letter);for(Letterletter:Q8)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1963 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，J3.equals("貓")，J3.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1964 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1965 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如h3，d2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1966 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1967 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterv6=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");v6.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1968 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1969 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1970 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的o物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1971 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterH3=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1972 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1973 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1974 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:q4.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1975 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1976 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=Z0.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1977 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleu1,doublef4,doublea1)publicstaticdoubleVolume(doubleu1,doublef4,doublea1)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleu1=scanner.nextDouble();System.out.println("輸入寬");doublef4=scanner.nextDouble();System.out.println("輸入高");doublea1=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.u1=u1;this.f4=f4;this.a1=a1;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1978 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1979 =====
=====標準答案=====<BOM>a6變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperD4=newKeeper(...);Petb9=newPet(...,D4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立a6物件變數的值，例如，publicPet(Strings2,StringR5,StringQ1,Keepera6){...this.a6=a6;}Pet建構子內已有a6參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petb9=newPet(s2,R5,Q1,D4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1980 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1981 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1982 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE6,Stringk8,StringX9,StringG7,StringT6){super(E6,k8,X9,G7,T6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1983 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1984 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1985 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1986 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringz,StringD3,StringQ9,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1987 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1988 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1989 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1990 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1991 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]u9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1992 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 1993 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1994 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleo6,doublej5,doubleJ6應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.o6=O3;bb.j5=J5;bb.J6=I5;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.o6=O3;bb.j5=J5;bb.J6=I5;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleo6,doublej5,doubleJ6沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1995 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]K5){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1996 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1997 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringW2,StringY6,StringB5,Stringe9,StringB8){super(W2,Y6,B5,e9,B8)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1998 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 1999 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2000 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2001 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxu7=newKKBOx(l,w,h);呼叫時可用u7.volume();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2002 =====
=====標準答案=====<BOM>按順序應為Q9,x4,T3。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2003 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]u6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2004 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=K7,my=t5<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2005 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2006 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2007 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperq9=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,q9);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2008 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如z9，G9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2009 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的classtest類別，需改成type.equals("狗")。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式classtest類別，要改成ID=n9;tel=w7;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2010 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:F1,F0,M6,j3為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:X4,j3為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:O6,T為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:I,w8為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2011 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(T9,t5,L4);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2012 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2013 =====
=====標準答案=====<BOM>按順序應為F3,g9,t8。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2014 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.R=Rthis.k3=k3<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2015 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.I7=I7;this.F7=F7;this.N9=N9;重複定義只需要returnm3=I7*F7*N9;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2016 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2017 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2018 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2019 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2020 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2021 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2022 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]R1){H8.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2023 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:X0.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2024 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerR2=newScanner();intp=R2.nextInt();//讀取數值R2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2025 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringm9="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2026 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數S7會衝突,導致S7無法傳遞,建議在Class中宣告S7即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intm2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2027 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如d2=i;應改成i=d2;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2028 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2029 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2030 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2031 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2032 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2033 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublei9,doubleq3,doublei5)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2034 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2035 =====
=====標準答案=====<BOM>按順序應為h7,G8,J3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2036 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringT0="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2037 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.w4=w4<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2038 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2039 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.T5=T5this.N0=N0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2040 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringz2,StringO1,doubleZ0,doubleJ7){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(z2,O1,Z0,J7);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2041 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2042 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2043 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(w8),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]D2){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2044 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，U2.equals("貓")，U2.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2045 =====
=====標準答案=====<BOM>按順序應為L1,i6,a。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2046 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2047 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2048 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=t4,my=c3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2049 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2050 =====
=====標準答案=====<BOM>Envelope擁有Letter的u5物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+J+","+u5.getSender());System.out.println("To:"+T8+","+u5.getReceiver()+""+u5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2051 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.m0=m0this.k2=k2<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2052 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=R4.nextInt();doubleY=R4.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerR4=newScanner();intj3=R4.nextInt();//讀取數值R4.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2053 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2054 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]o7={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2055 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(u6.equals("貓"))<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2056 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.F5=F5;this.S3=S3;this.i6=i6;重複定義只需要returnx1=F5*S3*i6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2057 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2058 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如D1=i;應改成i=D1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2059 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2060 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringtitle,Stringreceiver,Stringcontent,Stringsender,Stringdate){super(title,receiver,content,sender,date)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2061 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，U3.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2062 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數N會衝突,導致N無法傳遞,建議在Class中宣告N即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intZ8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2063 =====
=====標準答案=====<BOM>按順序應為g9,C2,z8。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2064 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2065 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2066 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2067 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2068 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringz1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2069 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2070 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"s8","b"};例如，本程式的MyMathUtil類別，需改成String[]P1={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2071 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2072 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2073 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2074 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2075 =====
=====標準答案=====<BOM>按順序應為c2,m8,T5。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2076 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);V=scanner.nextInt();T2=scanner.nextInt();y7=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleK9;publicdoubleB1;publicdoubled8;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleK9;publicdoubleB1;publicdoubled8;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2077 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2078 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringa2,StringG5,StringB8,StringE8,StringT9){super(a2,G5,B8,E8,T9)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringa2,StringG5,StringB8,StringE8,StringT9){super(a2,G5,B8,E8,T9)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2079 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2080 =====
=====標準答案=====<BOM>o8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepero8=newKeeper(...);PetK=newPet(...,o8);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(w8.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringJ3,Stringl2,Stringw8,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetK=newPet(t8,k9,K5,o8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2081 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterk=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");k.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2082 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterr6=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2083 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:C8.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2084 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2085 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2086 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2087 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2088 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用e7.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.Q0=Q0;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2089 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2090 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2091 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2092 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2093 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2094 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2095 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=t2,my=L9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2096 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2097 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2098 =====
=====標準答案=====<BOM>Stringv9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]v9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]k2){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2099 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2100 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2101 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringi5,StringL7,Stringw1,StringM7,StringS6){super(i5,L7,w1,M7,S6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2102 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2103 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2104 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringc5="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2105 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.j0=j0this.K9=K9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2106 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"R1","b"};例如，本程式的MyMathUtil類別，需改成String[]r0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2107 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerI6=newScanner();inta2=I6.nextInt();//讀取數值I6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為u5[V3]，若寫成u5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2108 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerD5=newScanner();intp=D5.nextInt();//讀取數值D5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2109 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2110 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2111 =====
=====標準答案=====<BOM>變數名稱重複宣告A4[m3]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:A4[1],Integer.parseInt(A4[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2112 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2113 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2114 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2115 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2116 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2117 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2118 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringZ,o4,M,k1,U0;Letter(StringZ,Stringo4,StringM,Stringk1,StringU0){this.Z=Z;this.o4=o4;this.M=M;this.k1=k1;this.U0=U0;}publicStringgetSender(){returnk1;}publicStringgetReceiver(){returno4;}publicStringgetDate(){returnU0;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2119 =====
=====標準答案=====<BOM>J2變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperJ2=newKeeper(...);Petpet=newPet(...,J2);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petl4=newPet(B,y2,c7);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(c7.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立J2物件變數的值，例如，publicPet(StringB,Stringy2,Stringc7,KeeperJ2){...this.J2=J2;}Pet建構子內已有J2參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petl4=newPet(B,y2,c7,R7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫J2.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...J2.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2120 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=Z4,my=c9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2121 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2122 =====
=====標準答案=====<BOM>變數名稱O5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2123 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq6=newScanner();intX8=q6.nextInt();//讀取數值q6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為B0[U5]，若寫成B0[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2124 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2125 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2126 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.b=bthis.R4=R4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2127 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2128 =====
=====標準答案=====<BOM>a5變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(S8,j1);透過Keeper建構子，將S8與j1的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringi4,Stringd6,StringL8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2129 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]P5){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2130 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2131 =====
=====標準答案=====<BOM>變數名稱o8重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2132 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2133 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2134 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxM2=newKKBOx(l,w,h);呼叫時可用M2.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2135 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2136 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringD7,StringW5,StringH7,StringD,Stringw6){super(D7,W5,H7,D,w6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2137 =====
=====標準答案=====<BOM>StringQ7={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]Q7={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Y5){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2138 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2139 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2140 =====
=====標準答案=====<BOM>變數名稱V9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2141 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2142 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2143 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(D4.equals("貓"))<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2144 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2145 =====
=====標準答案=====<BOM>Envelop第10行d.G5在呼叫d物件中的物件資料時,應呼叫getSender()來回傳returnG5Envelop第11行的d.D9/d.A8與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2146 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2147 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);J4=scanner.nextInt();O9=scanner.nextInt();T7=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublel7;publicdoubleW2;publicdoubled5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublel7;publicdoubleW2;publicdoubled5;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2148 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數H會衝突,導致H無法傳遞,建議在Class中宣告H即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intS5=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2149 =====
=====標準答案=====<BOM>變數名稱b6重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2150 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2151 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2152 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnO;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2153 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2154 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2155 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringH7;...，此外，ChineseLetter與EnglishLetter就可以刪除StringH7;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2156 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q7.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterh7=(Letter)other;returnY5.compareTo(h7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]f1={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:f1)letter.compareTo(letter);for(Letterletter:f1)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2157 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2158 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2159 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2160 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k4,my=g4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2161 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]w1={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2162 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數O9會衝突,導致O9無法傳遞,建議在Class中宣告O9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intu6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2163 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringz3;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringz3;...<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2164 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2165 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.o9;}publicStringgetTitle(){returnthis.q0;}//可取得A4publicStringgetReceiver(){returnthis.A4;}//可取得x3publicStringgetDate(){returnthis.x3;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2166 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2167 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringn8,Stringx7,StringB2,Stringk9,Stringj6){super(n8,x7,B2,k9,j6)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2168 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2169 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2170 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2171 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入y6.B9=2;y6.J0=2;y6.Q5=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleB9=kb.nextDouble();doubleJ0=kb.nextDouble();doubleQ5=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2172 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringz8,Stringd0,StringZ4){this.z8=z8;this.d0=d0;this.Z4=Z4;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2173 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=N2.nextInt();doublea7=N2.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerN2=newScanner();intg7=N2.nextInt();//讀取數值N2.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2174 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如K9=i;應改成i=K9;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2175 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2176 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2177 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2178 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2179 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，o9,m6是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringo9;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2180 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2181 =====
=====標準答案=====<BOM>按順序應為c5,y2,B3。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2182 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2183 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2184 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterb6=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2185 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用c0.display()顯示內容，此外P4.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2186 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數e1會衝突,導致e1無法傳遞,建議在Class中宣告e1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intZ3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2187 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.sender;}publicStringgetTitle(){returnthis.title;}//可取得receiverpublicStringgetReceiver(){returnthis.receiver;}//可取得datepublicStringgetDate(){returnthis.date;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2188 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2189 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的C8物件資料所以在呼叫C8的物件動作的時候應加上System.out.println("From:"+W9+","+C8.getSender());System.out.println("To:"+y3+","+C8.getReceiver()+""+C8.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2190 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2191 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2192 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2193 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2194 =====
=====標準答案=====<BOM>變數名稱重複宣告X1[r0]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:X1[1],Integer.parseInt(X1[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2195 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入E1.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2196 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2197 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成e9.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2198 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2199 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2200 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如M6，g9，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterH2=(EnglishLetter)g6;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectH2){Letterg6=(Letter)H2;returnB4.compareTo(g6.getDate());}先將原本宣告成Object的g6強制轉換成Letter類別型態這樣g6就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2201 =====
=====標準答案=====<BOM>StringF0={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]F0={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]r9){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2202 =====
=====標準答案=====<BOM>變數名稱H1重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(d5.equals("0")==false)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2203 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入e4.p9=2;e4.f7=2;e4.x9=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublep9=kb.nextDouble();doublef7=kb.nextDouble();doublex9=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2204 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2205 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2206 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2207 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2208 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如D9，y1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterg7=(EnglishLetter)S4;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectg7){LetterS4=(Letter)g7;returnw1.compareTo(S4.getDate());}先將原本宣告成Object的S4強制轉換成Letter類別型態這樣S4就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2209 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2210 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2211 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2212 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數P9會衝突,導致P9無法傳遞,建議在Class中宣告P9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intv8=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2213 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2214 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2215 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，q4.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2216 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2217 =====
=====標準答案=====<BOM>變數名稱W4重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2218 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2219 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2220 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerC0=newScanner();intk6=C0.nextInt();//讀取數值C0.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為R3[C3]，若寫成R3[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2221 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2222 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，Keeperw0=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,w0);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2223 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2224 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerv9=newScanner();intp=v9.nextInt();//讀取數值v9.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2225 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2226 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2227 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2228 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"X8","b"};例如，本程式的MyMathUtil類別，需改成String[]B5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2229 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如L8.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2230 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2231 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2232 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleN9,doubleH1,doubleR6)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2233 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2234 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleK2,doublel4,doubleJ9)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2235 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperB2=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,B2);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2236 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublem2,doubleo6,doubleh0)publicstaticdoubleVolume(doublem2,doubleo6,doubleh0)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublem2=scanner.nextDouble();System.out.println("輸入寬");doubleo6=scanner.nextDouble();System.out.println("輸入高");doubleh0=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.m2=m2;this.o6=o6;this.h0=h0;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2237 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerM5=newScanner();intc9=M5.nextInt();//讀取數值M5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為j1[X8]，若寫成j1[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2238 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(N2.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringH9,StringD2,StringN2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2239 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2240 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);U3=scanner.nextInt();O5=scanner.nextInt();e6=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleE5;publicdoubleq6;publicdoublet5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleE5;publicdoubleq6;publicdoublet5;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2241 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(K6),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]i5){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2242 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2243 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2244 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，Petp=newPet(o1,...);Keeperk=newKeeper(H0,...);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一個物件資料privateKeeperkeeper:<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2245 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=X4.nextInt();doubleT=X4.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerX4=newScanner();intQ8=X4.nextInt();//讀取數值X4.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2246 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=U6,my=L9<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2247 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2248 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringy9,StringH7,Stringl0,StringZ5,Stringd7){super(y9,H7,l0,Z5,d7)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2249 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2250 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的h0物件資料所以在呼叫h0的物件動作的時候應加上System.out.println("From:"+j5+","+h0.getSender());System.out.println("To:"+u8+","+h0.getReceiver()+""+h0.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2251 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2252 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]M1){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2253 =====
=====標準答案=====<BOM>變數名稱O3重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2254 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2255 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returni3;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2256 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，f7,y0是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringf7;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2257 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如K.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2258 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2259 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2260 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(u9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterp8=(Letter)other;returnV4.compareTo(p8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]k7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:k7)letter.compareTo(letter);for(Letterletter:k7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2261 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2262 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=C9.nextInt();doubleK8=C9.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerC9=newScanner();intI2=C9.nextInt();//讀取數值C9.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2263 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2264 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=d7,my=O5<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2265 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2266 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2267 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.c0;}publicStringgetTitle(){returnthis.k1;}//可取得k8publicStringgetReceiver(){returnthis.k8;}//可取得j1publicStringgetDate(){returnthis.j1;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2268 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2269 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2270 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(F.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringr,Stringn5,StringO5,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2271 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(E5.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中O9等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:T4.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringO9,StringY,StringE5,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2272 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:P2,M1,w5,T4為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:M9,T4為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:u7,Z5為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:y2,d1為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2273 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringy3,StringT5,StringZ,StringC0){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(y3,T5,Z,C0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2274 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2275 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.q4=q4this.i7=i7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2276 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2277 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2278 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2279 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，name.equals("狗");<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2280 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2281 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2282 =====
=====標準答案=====<BOM>變數名稱重複宣告Z1[x8]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:Z1[1],Integer.parseInt(Z1[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2283 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2284 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數a6會衝突,導致a6無法傳遞,建議在Class中宣告a6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intJ3=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2285 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerI8=newScanner();inth4=I8.nextInt();//讀取數值I8.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為c6[r6]，若寫成c6[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2286 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2287 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2288 =====
=====標準答案=====<BOM>Envelop第10行M2.l1在呼叫M2物件中的物件資料時,應呼叫getSender()來回傳returnl1Envelop第11行的M2.G1/M2.l5與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2289 =====
=====標準答案=====<BOM>Envelope擁有Letter的S9物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+J1+","+S9.getSender());System.out.println("To:"+Z8+","+S9.getReceiver()+""+S9.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2290 =====
=====標準答案=====<BOM>按順序應為U,U1,z。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2291 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2292 =====
=====標準答案=====<BOM>Envelop第10行T5.K在呼叫T5物件中的物件資料時,應呼叫getSender()來回傳returnKEnvelop第11行的T5.h4/T5.l與上述例子相同<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2293 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2294 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2295 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用Y8.display()顯示內容，此外j7.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2296 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2297 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.r3=r3;this.j3=j3;this.h=h;重複定義只需要returno6=r3*j3*h;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2298 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]S9){F0.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2299 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成P.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2300 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.U1=U1this.u6=u6<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2301 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq1=newScanner();intj6=q1.nextInt();//讀取數值q1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為e9[w9]，若寫成e9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2302 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterr0=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");r0.display();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2303 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2304 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2305 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringp4,Stringg0,StringF8,StringT9,Stringe8){super(p4,g0,F8,T9,e8)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringp4,Stringg0,StringF8,StringT9,Stringe8){super(p4,g0,F8,T9,e8)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2306 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2307 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returns5;。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2308 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(m9),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]T0){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2309 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]e8){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2310 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.u2=u2;this.U6=U6;this.i7=i7;重複定義只需要returnW0=u2*U6*i7;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2311 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringO8,StringD4,Strings3,StringM,Stringr6){super(O8,D4,s3,M,r6)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2312 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate的結果有小數點,故rate的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2313 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerr2=newScanner();intp=r2.nextInt();//讀取數值r2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2314 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(S.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letteru8=(Letter)other;returni8.compareTo(u8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]P3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:P3)letter.compareTo(letter);for(Letterletter:P3)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2315 =====
=====標準答案=====<BOM>按順序應為F5,V9,j4。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2316 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2317 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]k){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2318 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2319 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);Y0=scanner.nextInt();K5=scanner.nextInt();X2=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublev6;publicdoublea3;publicdoublew0;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublev6;publicdoublea3;publicdoublew0;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2320 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"S2","b"};例如，本程式的MyMathUtil類別，需改成String[]y4={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2321 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2322 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]n9={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2323 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleJ0,doublen2,doubleb9)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2324 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入e5.N=2;e5.F1=2;e5.i5=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleN=kb.nextDouble();doubleF1=kb.nextDouble();doublei5=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2325 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2326 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2327 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫C0中的物件動作來回傳值例:C0.getSender();而不是直接呼叫C0中的物件資料System.out.println("From:"+o0+","+C0.getSender());System.out.println("To:"+Z0+","+C0.getReceiver()+""+C0.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2328 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2329 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2330 =====
=====標準答案=====<BOM>變數名稱f9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2331 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);O9=scanner.nextInt();k7=scanner.nextInt();f8=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubles6;publicdoublev6;publicdoublec1;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubles6;publicdoublev6;publicdoublec1;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2332 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2333 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intO7){O7=3;returnO7;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleI9=X(y1);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2334 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2335 =====
=====標準答案=====<BOM>Stringg8={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]g8={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]K7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2336 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如E7，w3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2337 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2338 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2339 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2340 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2341 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringk8,Stringb2,Stringn9,StringF5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(k8,b2,n9,F5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2342 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(u8.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterb3=(Letter)other;returnv6.compareTo(b3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]m8={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:m8)letter.compareTo(letter);for(Letterletter:m8)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2343 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=J9,my=u6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2344 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成u.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2345 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2346 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2347 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2348 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2349 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.s2=s2;this.y7=y7;this.c2=c2;重複定義只需要returnf7=s2*y7*c2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2350 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerq9=newScanner();intp=q9.nextInt();//讀取數值q9.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2351 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxH6=newKKBOx(l,w,h);呼叫時可用H6.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2352 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2353 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2354 =====
=====標準答案=====<BOM>StringM={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]M={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]V1){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2355 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=D8.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2356 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如A8.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2357 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.z8=z8this.b8=b8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2358 =====
=====標準答案=====<BOM>k5變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperk5=newKeeper(...);Petpet=newPet(...,k5);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petj1=newPet(l1,A7,K6);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(K6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立k5物件變數的值，例如，publicPet(Stringl1,StringA7,StringK6,Keeperk5){...this.k5=k5;}Pet建構子內已有k5參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petj1=newPet(l1,A7,K6,d8);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫k5.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...k5.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2359 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(f1,Y8,r);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2360 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2361 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2362 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2363 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2364 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("0")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2365 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2366 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2367 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringV2,Stringm1,StringO0,Stringn0,Stringb5){super(V2,m1,O0,n0,b5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2368 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2369 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]j6={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2370 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2371 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doubleo,doubleT5,doubleY2)publicstaticdoubleVolume(doubleo,doubleT5,doubleY2)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doubleo=scanner.nextDouble();System.out.println("輸入寬");doubleT5=scanner.nextDouble();System.out.println("輸入高");doubleY2=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.o=o;this.T5=T5;this.Y2=Y2;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2372 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX1,Stringp5,StringM,Stringk4,Strings3){super(X1,p5,M,k4,s3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2373 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2374 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2375 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerB1=newScanner();intp=B1.nextInt();//讀取數值B1.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2376 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=r7.getSender();StringReceiver=r7.getReceiver();StringTitle=r7.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2377 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2378 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2379 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2380 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2381 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2382 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2383 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如y4.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2384 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2385 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2386 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2387 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intg2=1;類別動作(g2);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2388 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2389 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2390 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2391 =====
=====標準答案=====<BOM>o0變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepero0=newKeeper(...);Petpet=newPet(...,o0);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetS6=newPet(O4,q8,C0);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(C0.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立o0物件變數的值，例如，publicPet(StringO4,Stringq8,StringC0,Keepero0){...this.o0=o0;}Pet建構子內已有o0參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetS6=newPet(O4,q8,C0,E7);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫o0.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...o0.display();speak();}<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2392 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2393 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，t2.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2394 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2395 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.F1=F1this.o=o<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2396 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2397 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數P會衝突,導致P無法傳遞,建議在Class中宣告P即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intN0=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2398 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2399 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2400 =====
=====標準答案=====<BOM>h3變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperh3=newKeeper(...);Petpet=newPet(...,h3);<EOM><BOM>請注意Pet中參數的對應順序，例如:Petl2=newPet(n4,D3,i);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(i.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立h3物件變數的值，例如，publicPet(Stringn4,StringD3,Stringi,Keeperh3){...this.h3=h3;}Pet建構子內已有h3參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petl2=newPet(n4,D3,i,f);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫h3.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...h3.display();speak();}<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2401 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerL4=newScanner();ints0=L4.nextInt();//讀取數值L4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為u9[C1]，若寫成u9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2402 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2403 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2404 =====
=====標準答案=====<BOM>變數名稱重複宣告X4[c6]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:X4[1],Integer.parseInt(X4[2])<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2405 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2406 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如h2，T1，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2407 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2408 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2409 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成i0.equals("貓")，i0.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2410 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2411 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成E7.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2412 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別應該改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter與EnglishLetter應刪除Stringtitile;...<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2413 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2414 =====
=====標準答案=====<BOM>按順序應為T3,F5,x6。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2415 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2416 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數n會衝突,導致n無法傳遞,建議在Class中宣告n即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intx=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2417 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>變數名稱<EOM>
Meteor_Score : 0.0

===== 2418 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:Evaluationb1=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:Evaluationb1;b1=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2419 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2420 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2421 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(I6.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2422 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.Z5=Z5;this.h5=h5;this.M8=M8;重複定義只需要returno8=Z5*h5*M8;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2423 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringC0,v9,t7,y7,I2;Letter(StringC0,Stringv9,Stringt7,Stringy7,StringI2){this.C0=C0;this.v9=v9;this.t7=t7;this.y7=y7;this.I2=I2;}publicStringgetSender(){returny7;}publicStringgetReceiver(){returnv9;}publicStringgetDate(){returnI2;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2424 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入S7.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2425 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2426 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入P8.O4=2;P8.x6=2;P8.v3=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleO4=kb.nextDouble();doublex6=kb.nextDouble();doublev3=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2427 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2428 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2429 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2430 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublee0,doubleL,doublet0)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2431 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料應該宣告在抽象類別Letter裡所以應加入protectedStringW6,s6,o8,M9,e9;Letter(StringW6,Strings6,Stringo8,StringM9,Stringe9){this.W6=W6;this.s6=s6;this.o8=o8;this.M9=M9;this.e9=e9;}publicStringgetSender(){returnM9;}publicStringgetReceiver(){returns6;}publicStringgetDate(){returne9;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2432 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2433 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2434 =====
=====標準答案=====<BOM>按順序應為r6,B9,P9。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2435 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數B3會衝突,導致B3無法傳遞,建議在Class中宣告B3即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intp7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2436 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringF1,Stringv6,Stringy0,StringJ,StringD0){super(F1,v6,y0,J,D0)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringF1,Stringv6,Stringy0,StringJ,StringD0){super(F1,v6,y0,J,D0)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2437 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]M7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2438 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2439 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式的Letter類別需要加入display的抽象動作publicabstractvoiddisplay();在test類別就可以直接用f6.display()顯示內容，此外p6.display()就可刪除。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的ChineseLetter類別與EnglishLetter類別都宣告相同的Content資料，應該移到Letter類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2440 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數L9會衝突,導致L9無法傳遞,建議在Class中宣告L9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。inta1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2441 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]q7={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2442 =====
=====標準答案=====<BOM>Envelop第10行p6.l0在呼叫p6物件中的物件資料時,應呼叫getSender()來回傳returnl0Envelop第11行的p6.F4/p6.R9與上述例子相同<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2443 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);I6=scanner.nextInt();J8=scanner.nextInt();e5=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublex9;publicdoublev4;publicdoublei1;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublex9;publicdoublev4;publicdoublei1;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2444 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2445 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxP=newKKBOx(l,w,h);呼叫時可用P.volume();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2446 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2447 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2448 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2449 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2450 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2451 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2452 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringq2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2453 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2454 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2455 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2456 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doubleq9,doubled0,doubleU2應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.q9=E3;bb.d0=t3;bb.U2=P5;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.q9=E3;bb.d0=t3;bb.U2=P5;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doubleq9,doubled0,doubleU2沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2457 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(u2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letters4=(Letter)other;returnn8.compareTo(s4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]j0={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:j0)letter.compareTo(letter);for(Letterletter:j0)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2458 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2459 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=F6,my=w7<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2460 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2461 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，F變數型態為Int，t6變數型態為Int，F0變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:b7,a9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2462 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneri5=newScanner();intx0=i5.nextInt();//讀取數值i5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為U5[m9]，若寫成U5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2463 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.C5=C5this.b1=b1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2464 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(q0,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringm2,Stringb1)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2465 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如b4.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2466 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2467 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2468 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2469 =====
=====標準答案=====<BOM>變數名稱j5重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2470 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2471 =====
=====標準答案=====<BOM>StringS5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]S5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]p7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2472 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的n5與englishletter與letter就可刪除StringV3,...;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2473 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2474 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成l9.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2475 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2476 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.X1=X1this.o=o<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2477 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(J.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(Stringn2,StringY5,StringJ,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2478 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2479 =====
=====標準答案=====<BOM>變數名稱重複宣告c1[M4]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:c1[1],Integer.parseInt(c1[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2480 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，J3.equals("貓")，J3.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2481 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2482 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2483 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2484 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2485 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2486 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(Y0.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringV0,StringV6,StringY0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2487 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2488 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式中的parent類別，x9.equals("貓")，x9.equals("狗")。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2489 =====
=====標準答案=====<BOM>變數名稱N7重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(l.equals("0")==false)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2490 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:LetterU8=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2491 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成c.equals(word)。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2492 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成e0.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2493 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(j0.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringu,Stringr3,Stringj0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2494 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2495 =====
=====標準答案=====<BOM>變數名稱N9重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2496 =====
=====標準答案=====<BOM>l9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperl9=newKeeper(...);PetU9=newPet(...,l9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(t7.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringt7,StringS0,Stringq4,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetU9=newPet(M8,S0,j2,l9);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2497 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數a6會衝突,導致a6無法傳遞,建議在Class中宣告a6即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intl4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2498 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2499 =====
=====標準答案=====<BOM>Envelope擁有Letter的T9物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+Q4+","+T9.getSender());System.out.println("To:"+B8+","+T9.getReceiver()+""+T9.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2500 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]N9={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2501 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2502 =====
=====標準答案=====<BOM>變數名稱F5重複宣告。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2503 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入I1.I9=2;I1.R0=2;I1.H1=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleI9=kb.nextDouble();doubleR0=kb.nextDouble();doubleH1=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2504 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數p0會衝突,導致p0無法傳遞,建議在Class中宣告p0即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intE2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2505 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intq6=1;類別動作(q6);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2506 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2507 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2508 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2509 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2510 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2511 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerX3=newScanner();intH0=X3.nextInt();//讀取數值X3.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為C2[X3]，若寫成C2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2512 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如V2=i;應改成i=V2;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2513 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2514 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=A7.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2515 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2516 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2517 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成K5.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2518 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringb1="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2519 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式Pet類別，需改成type.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2520 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2521 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublet5,doubleV2,doublex5應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.t5=L4;bb.V2=L1;bb.x5=b2;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.t5=L4;bb.V2=L1;bb.x5=b2;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublet5,doubleV2,doublex5沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2522 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2523 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2524 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2525 =====
=====標準答案=====<BOM>變數名稱B6重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(q6.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2526 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2527 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2528 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerK3=newScanner();intp=K3.nextInt();//讀取數值K3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2529 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2530 =====
=====標準答案=====<BOM>按順序應為m8,L0,R5。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2531 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerD4=newScanner();intp=D4.nextInt();//讀取數值D4.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2532 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2533 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerp3=newScanner();ints5=p3.nextInt();//讀取數值p3.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為u4[d2]，若寫成u4[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2534 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2535 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2536 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringz7,d6,x3,i3,I1;Letter(Stringz7,Stringd6,Stringx3,Stringi3,StringI1){this.z7=z7;this.d6=d6;this.x3=x3;this.i3=i3;this.I1=I1;}publicStringgetSender(){returni3;}publicStringgetReceiver(){returnd6;}publicStringgetDate(){returnI1;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2537 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如V2，y9，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2538 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2539 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2540 =====
=====標準答案=====<BOM>變數名稱重複宣告args[n]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:args[1],Integer.parseInt(args[2])<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2541 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2542 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=E0.getSender();StringReceiver=E0.getReceiver();StringTitle=E0.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2543 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2544 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2545 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(U0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettera6=(Letter)other;returnH2.compareTo(a6.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]w3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:w3)letter.compareTo(letter);for(Letterletter:w3)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2546 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2547 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intc1){...returnc1;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleA5=X(g4);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2548 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2549 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2550 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(Z2,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringc6,StringI7)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2551 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:a6=newExam(C2,P6,a7,I7,M9,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]l1){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2552 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringg9,E7,f3,V2,N5;Letter(Stringg9,StringE7,Stringf3,StringV2,StringN5){this.g9=g9;this.E7=E7;this.f3=f3;this.V2=V2;this.N5=N5;}publicStringgetSender(){returnV2;}publicStringgetReceiver(){returnE7;}publicStringgetDate(){returnN5;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2553 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2554 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2555 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2556 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫O0中的物件動作來回傳值例:O0.getSender();而不是直接呼叫O0中的物件資料System.out.println("From:"+r3+","+O0.getSender());System.out.println("To:"+Y6+","+O0.getReceiver()+""+O0.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2557 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2558 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，z4,e1是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringz4;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2559 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleL7,doublee1,doublea0)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2560 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringd3,Stringm9,StringB1,Stringj2,Stringr7){super(d3,m9,B1,j2,r7)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2561 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=S5.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2562 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2563 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如w3，d8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2564 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2565 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入a8.z0=2;a8.n2=2;a8.z6=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublez0=kb.nextDouble();doublen2=kb.nextDouble();doublez6=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2566 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2567 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.N3=N3<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2568 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2569 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2570 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=R.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2571 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2572 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2573 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫Z7中的物件動作來回傳值例:Z7.getSender();而不是直接呼叫Z7中的物件資料System.out.println("From:"+x5+","+Z7.getSender());System.out.println("To:"+D+","+Z7.getReceiver()+""+Z7.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2574 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(U6.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringc8,Strings6)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將U6.Speak()改為y8.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keepery8=newKeeper(c8,s6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringU6,StringY4,StringS9,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2575 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數e4會衝突,導致e4無法傳遞,建議在Class中宣告e4即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intv1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2576 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]z1){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2577 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]K9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2578 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2579 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2580 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intK2){...returnK2;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleS6=X(V7);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2581 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，J.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2582 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnQ;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2583 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2584 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringZ4,Strings1,StringS4,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2585 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2586 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.s3=s3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2587 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2wnewExam2();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2588 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2589 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringA3,o7,x,z3,t4;Letter(StringA3,Stringo7,Stringx,Stringz3,Stringt4){this.A3=A3;this.o7=o7;this.x=x;this.z3=z3;this.t4=t4;}publicStringgetSender(){returnz3;}publicStringgetReceiver(){returno7;}publicStringgetDate(){returnt4;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2590 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(N4.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringZ6,StringP0)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將N4.Speak()改為Y2.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperY2=newKeeper(Z6,P0);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringN4,Stringq0,Stringf8,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2591 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.E0=E0;this.T7=T7;this.P2=P2;重複定義只需要returnO0=E0*T7*P2;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2592 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的t5物件資料所以在呼叫t5的物件動作的時候應加上System.out.println("From:"+l+","+t5.getSender());System.out.println("To:"+e6+","+t5.getReceiver()+""+t5.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2593 =====
=====標準答案=====<BOM>按順序應為o2,y1,f5。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2594 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的X9物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2595 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2596 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);g2=scanner.nextInt();Z6=scanner.nextInt();p6=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleP6;publicdoubleX2;publicdoubleG2;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleP6;publicdoubleX2;publicdoubleG2;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2597 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getcount()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicintgetcount();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2598 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]i9){d7.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2599 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2600 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2601 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2602 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2603 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2604 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(c3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettere1=(Letter)other;returnl0.compareTo(e1.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]x={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:x)letter.compareTo(letter);for(Letterletter:x)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2605 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2606 =====
=====標準答案=====<BOM>變數名稱重複宣告u6[a5]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:u6[1],Integer.parseInt(u6[2])<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2607 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2608 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2609 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2610 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2611 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2612 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnW7;。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2613 =====
=====標準答案=====<BOM>Envelop第10行t5.P7在呼叫t5物件中的物件資料時,應呼叫getSender()來回傳returnP7Envelop第11行的t5.k6/t5.n與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2614 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleu9,doubleU3,doubleR9)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2615 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(t6.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterl8=(Letter)other;returnm2.compareTo(l8.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]X9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:X9)letter.compareTo(letter);for(Letterletter:X9)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2616 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，S7.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2617 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入X0.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2618 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(C0.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringZ8,Stringu1,StringX7,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2619 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2620 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2621 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2622 =====
=====標準答案=====<BOM>按順序應為b3,P3,p7。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2623 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2624 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2625 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2626 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入e5.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2627 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2628 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2629 =====
=====標準答案=====<BOM>Stringj4={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]j4={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]n){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2630 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2631 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2632 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2633 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=C8,my=L5<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2634 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2635 =====
=====標準答案=====<BOM>按順序應為C1,K8,Q0。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2636 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2637 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2638 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:m2.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2639 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2640 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringP3,StringA8,StringT8,Stringv5,Stringz8){super(P3,A8,T8,v5,z8)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2641 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2642 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2643 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2644 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(A2.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中w8等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:d5.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringw8,Stringv0,StringA2,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2645 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intY){Y=3;returnY;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleF3=X(c5);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2646 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublet4=X(k8);<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2647 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2648 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=G2,my=K1<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2649 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2650 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.K2=K2this.o1=o1<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2651 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。以本程式為例，I5,s4是可被繼承的物件資料，前面應該加上protective，例如，protectiveStringI5;<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。以本程式為例，speak函式式抽象動作，應改成abstictvoidspeak()。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2652 =====
=====標準答案=====<BOM>變數名稱g重複宣告。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2653 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2654 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2655 =====
=====標準答案=====<BOM>變數名稱重複宣告a8[M1]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:a8[1],Integer.parseInt(a8[2])<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2656 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]k4={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2657 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2658 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerp5=newScanner();intp=p5.nextInt();//讀取數值p5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2659 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2660 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(Q3)無法回傳double。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2661 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringy5,U6,s0,x1,R6;Letter(Stringy5,StringU6,Strings0,Stringx1,StringR6){this.y5=y5;this.U6=U6;this.s0=s0;this.x1=x1;this.R6=R6;}publicStringgetSender(){returnx1;}publicStringgetReceiver(){returnU6;}publicStringgetDate(){returnR6;}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2662 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=u4,my=z9<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2663 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2664 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]J4){...}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2665 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2666 =====
=====標準答案=====<BOM>變數名稱k1重複宣告。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2667 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2668 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerR1=newScanner();intT9=R1.nextInt();//讀取數值R1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為X0[C4]，若寫成X0[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2669 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Letterv7=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2670 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入W0.display();<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2671 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringt5,Stringv5,Stringi,Stringq7,StringD8){super(t5,v5,i,q7,D8)}}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2672 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2673 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringP1,StringY9,StringM,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a)需要用a變數這稱pt=1<EOM>
Meteor_Score : 0.0

===== 2674 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2675 =====
=====標準答案=====<BOM>變數名稱P0重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2676 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2677 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublev7,doubleT2,doubleI7應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.v7=z1;bb.T2=f7;bb.I7=k5;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.v7=z1;bb.T2=f7;bb.I7=k5;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublev7,doubleT2,doubleI7沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2678 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringO2,Stringx0,StringE8,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2679 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2680 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2681 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2682 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成o7.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2683 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用m5.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.h6=h6;...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2684 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(U3.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2685 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2686 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=I5,my=o9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2687 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2688 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2689 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);g9=scanner.nextInt();R2=scanner.nextInt();m4=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublem4;publicdoubleA5;publicdoublec7;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublem4;publicdoubleA5;publicdoublec7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2690 =====
=====標準答案=====<BOM>按順序應為N8,L,M1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2691 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2692 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2693 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(h1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]v3){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2694 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2695 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如N5，d，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2696 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2697 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2698 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]H0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2699 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2700 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如w1=i;應改成i=w1;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2701 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2702 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2703 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(x.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(Stringz7,StringL4)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將x.Speak()改為N3.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperN3=newKeeper(z7,L4);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringx,StringB4,StringJ6,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2704 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成D7.equals("貓")，D7.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2705 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]L3){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2706 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成Q6.equals("貓")，Q6.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2707 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2708 =====
=====標準答案=====<BOM>N2變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(A9,h6);透過Keeper建構子，將A9與h6的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringw0,StringV3,Stringg7,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2709 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnj;。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2710 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如K，O5，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2711 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2712 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=P9,my=K0<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2713 =====
=====標準答案=====<BOM>按順序應為j3,Z7,C2。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2714 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2715 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(A4,m6,s);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2716 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2717 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2718 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2719 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如type.equals("狗")。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2720 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]f9){w0.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2721 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如x，k5，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2722 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2723 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerw5=newScanner();intp=w5.nextInt();//讀取數值w5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2724 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2725 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);z8=scanner.nextInt();M1=scanner.nextInt();T=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubled6;publicdoublet2;publicdoublen6;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubled6;publicdoublet2;publicdoublen6;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2726 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2727 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成o.equals("貓")，o.equals("狗")。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如，本程式中的Keeper類別，只要打一段staticScannercopypid=newScanner(System.in);，<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2728 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2729 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2730 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2731 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，在Letter抽象類別宣告抽象動作,讓子類別去做覆寫publicabstractclassLetter{publicabstractvoiddisplay();}publicclassChineseLetterextendsLetter{....}publicclassEnglishLetterextendsLetter{....}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2732 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(p9,e4,y0);呼叫時可用b.volume();<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2733 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:x6,a1,r5,f4為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:s,f4為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:S8,a5為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:X7,F4為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2734 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2735 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Exam，Homework，以及Report類別有共同的物件資料，也各有專有的物件資料。因此，在建構子中，可將共同的資料透過super(...)傳遞給父類別的建構子去設定，而專有的物件資料則透過this指令設定。例如，publicExam(intK6,...,Stringtestdate,...){super(K6,...);this.testdate=testdate;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2736 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.x8=x8this.F7=F7<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2737 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2738 =====
=====標準答案=====<BOM>按順序應為O,c,l3。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2739 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2740 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:r0.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2741 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2742 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2743 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.S1=S1this.f2=f2<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2744 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2745 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(x2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterT5=(Letter)other;returnR5.compareTo(T5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]x5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:x5)letter.compareTo(letter);for(Letterletter:x5)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2746 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]p5={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2747 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2748 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2749 =====
=====標準答案=====<BOM>Envelop第10行F6.a3在呼叫F6物件中的物件資料時,應呼叫getSender()來回傳returna3Envelop第11行的F6.I2/F6.c5與上述例子相同<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2750 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringv2,StringC8,Stringq6,StringV,StringJ){super(v2,C8,q6,V,J)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringv2,StringC8,Stringq6,StringV,StringJ){super(v2,C8,q6,V,J)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2751 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.n9=n9this.Y=Y<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2752 =====
=====標準答案=====<BOM>按順序應為Y,Z,A。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2753 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2754 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublej9,doublek6,doubleC1應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.j9=o5;bb.k6=C4;bb.C1=Y5;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.j9=o5;bb.k6=C4;bb.C1=Y5;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublej9,doublek6,doubleC1沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2755 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。super的建構子函數需與父類別的建構子架構相同。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在子類別均有print()動作，可在父類別宣告print()為抽象動作再讓子類別覆寫，例如:publicabstractvoidprint();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2756 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2757 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2758 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2759 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2760 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=M4,my=L<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2761 =====
=====標準答案=====<BOM>按順序應為w2,h8,c7。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2762 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2763 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2764 =====
=====標準答案=====<BOM>變數名稱重複宣告J3[Z2]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:J3[1],Integer.parseInt(J3[2])<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2765 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelope擁有Letter的letter物件資料，所以不用宣告letter物件中的Stringsender,receiver,title;，而在呼叫letter的物件動作的時候應加上:System.out.println("From:"+senderAddr+","+letter.getSender());System.out.println("To:"+receiverAddr+","+letter.getReceiver()+""+letter.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2766 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2767 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2768 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2769 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM>
Meteor_Score : 0.0

===== 2770 =====
=====標準答案=====<BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);建構子使用時須符合建構子本身的參數設計，因此，以此程式來說，應更改成下面形式:q4=newExam(Q6,F5,S1,o2,d2,date,range);<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]q5){...}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractpublicvoidprint();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2771 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2772 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2773 =====
=====標準答案=====<BOM>按順序應為R6,T,Q1。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2774 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的h8與englishletter與letter就可刪除Stringl3,...;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2775 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2776 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2777 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(k9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterY9=(Letter)other;returnA.compareTo(Y9.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]W2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:W2)letter.compareTo(letter);for(Letterletter:W2)letter.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2778 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2779 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2780 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2781 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2782 =====
=====標準答案=====<BOM>P1變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperP1=newKeeper(...);Petpet=newPet(...,P1);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetN6=newPet(P4,u7,L5);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(L5.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立P1物件變數的值，例如，publicPet(StringP4,Stringu7,StringL5,KeeperP1){...this.P1=P1;}Pet建構子內已有P1參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetN6=newPet(P4,u7,L5,B4);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫P1.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...P1.display();speak();}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2783 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2784 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，t5變數型態為Int，P0變數型態為Int，d9變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:l5,l2為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2785 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringX0,StringW1,Stringr2,StringI0,StringC1){super(X0,W1,r2,I0,C1)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2786 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2787 =====
=====標準答案=====<BOM>StringQ6={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]Q6={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]L9){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2788 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k2,my=d<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2789 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2790 =====
=====標準答案=====<BOM>按順序應為E7,M6,n。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2791 =====
=====標準答案=====<BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}"本段程式碼的main裡沒有任何動作<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2792 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]V){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2793 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]u7){K5.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2794 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入p6.display();<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2795 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerV5=newScanner();intW0=V5.nextInt();//讀取數值V5.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為G2[A8]，若寫成G2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2796 =====
=====標準答案=====<BOM>StringE4={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]E4={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]a){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2797 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2798 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2799 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleI6,doublee4,doubleI4)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2800 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2801 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2802 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行K.h0在呼叫K物件中的物件資料時,應呼叫getSender()來回傳returnh0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2803 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2804 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用例如：Stringxx;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2805 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2806 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2807 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=d2,my=V0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2808 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數e5會衝突,導致e5無法傳遞,建議在Class中宣告e5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intB6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2809 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2810 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2811 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2812 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(R1),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]K4){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2813 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2814 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringO3,StringM8,StringY8,StringV4){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(O3,M8,Y8,V4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2815 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2816 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如n6=i;應改成i=n6;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2817 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2818 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(o3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterI2=(Letter)other;returnc0.compareTo(I2.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]Q2={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:Q2)letter.compareTo(letter);for(Letterletter:Q2)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2819 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2820 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2821 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringF2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2822 =====
=====標準答案=====<BOM>按順序應為w7,G2,D2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2823 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2824 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如title，receiver，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2825 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE1,StringO9,StringD7,Stringv6,StringM){super(E1,O9,D7,v6,M)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2826 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2827 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2828 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringM8,Stringg3,StringO3,StringX9){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(M8,g3,O3,X9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2829 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2830 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2831 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成type.equals("貓")，type.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2832 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2833 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2834 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2835 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(h6.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringX5,StringL2)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將h6.Speak()改為B7.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperB7=newKeeper(X5,L2);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringh6,StringZ2,StringK3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2836 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringH9,StringW8,Stringn,Stringe4,Stringt4){super(H9,W8,n,e4,t4)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2837 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2838 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入z7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2839 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2840 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(o0.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterj5=(Letter)other;returnT5.compareTo(j5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]d5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:d5)letter.compareTo(letter);for(Letterletter:d5)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2841 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]e8={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2842 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2843 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2844 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入i0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2845 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(P3.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2846 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2847 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2848 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2849 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2850 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2851 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2852 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的display()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoiddisplay();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2853 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如l4.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2854 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}本程式需撰寫main函式publicstaticvoidmain(String[]args){ChineseLetterW8=newChineseeLetter("教授","王","很高興跟您聯絡","銘哥","2019/01/05");W8.display();}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2855 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2856 =====
=====標準答案=====<BOM>類別動作需要的變數未宣告請宣告一個函數給類別使用例如intn=1;類別動作(n);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:staticvoid函數名稱(參數){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2857 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:E6.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2858 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2859 =====
=====標準答案=====<BOM>v8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperv8=newKeeper(...);PetD0=newPet(...,v8);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(O3.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringO3,Stringf8,Stringy9,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetD0=newPet(a9,f8,O4,v8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2860 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnn9;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2861 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2862 =====
=====標準答案=====<BOM>Envelop第10行n2.J2在呼叫n2物件中的物件資料時,應呼叫getSender()來回傳returnJ2Envelop第11行的n2.C4/n2.t8與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2863 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=z3.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2864 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2865 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(r,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(StringW7,StringA0)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2866 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2867 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(X1.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringJ,StringL3)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將X1.Speak()改為l8.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:Keeperl8=newKeeper(J,L3);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringX1,StringT5,StringA,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2868 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如z7，z，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterb6=(EnglishLetter)r9;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectb6){Letterr9=(Letter)b6;returnK.compareTo(r9.getDate());}先將原本宣告成Object的r9強制轉換成Letter類別型態這樣r9就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2869 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2870 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，S2.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2871 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入A0.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2872 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2873 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringu2,Stringk3,StringP5,Stringk1,StringU2){super(u2,k3,P5,k1,U2)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringu2,Stringk3,StringP5,Stringk1,StringU2){super(u2,k3,P5,k1,U2)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2874 =====
=====標準答案=====<BOM>變數名稱P8重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(f5.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2875 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2876 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2877 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上StringZ0;...，此外，ChineseLetter與EnglishLetter就可以刪除StringZ0;...<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2878 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2879 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行t0.Y8在呼叫t0物件中的物件資料時,應呼叫getSender()來回傳returnY8<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2880 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2881 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的q1物件資料所以在呼叫q1的物件動作的時候應加上System.out.println("From:"+r9+","+q1.getSender());System.out.println("To:"+Q3+","+q1.getReceiver()+""+q1.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2882 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2883 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2884 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(Y9),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]H1){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2885 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如r2，Z0，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterV3=(EnglishLetter)J7;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(ObjectV3){LetterJ7=(Letter)V3;returnF6.compareTo(J7.getDate());}先將原本宣告成Object的J7強制轉換成Letter類別型態這樣J7就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2886 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.q6=q6<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2887 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerJ7=newScanner();inth4=J7.nextInt();//讀取數值J7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為w3[f3]，若寫成w3[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2888 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數i5會衝突,導致i5無法傳遞,建議在Class中宣告i5即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intn6=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2889 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2890 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(J0),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]S7){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2891 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]B={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2892 =====
=====標準答案=====<BOM>t變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepert=newKeeper(...);Petpet=newPet(...,t);<EOM><BOM>請注意Pet中參數的對應順序，例如:PetH5=newPet(h9,d4,z9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(z9.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立t物件變數的值，例如，publicPet(Stringh9,Stringd4,Stringz9,Keepert){...this.t=t;}Pet建構子內已有t參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetH5=newPet(h9,d4,z9,R3);<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。可在Pet程式中呼叫speak()發出叫聲，以及呼叫t.display()讓飼主顯示自己的資料。例如:publicvoiddisplay(){...t.display();speak();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2893 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]V7={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2894 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.Z8=Z8<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2895 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2896 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2897 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringS7,X8,M4,G8,W7;Letter(StringS7,StringX8,StringM4,StringG8,StringW7){this.S7=S7;this.X8=X8;this.M4=M4;this.G8=G8;this.W7=W7;}publicStringgetSender(){returnG8;}publicStringgetReceiver(){returnX8;}publicStringgetDate(){returnW7;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 2898 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2899 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入O3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2900 =====
=====標準答案=====<BOM>按順序應為s4,w7,I1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2901 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2902 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringU0,StringJ1,StringP7,Stringi4,StringN3){super(U0,J1,P7,i4,N3)}}publicclassChineseLetterextendsLetter{publicChineseLetter(StringU0,StringJ1,StringP7,Stringi4,StringN3){super(U0,J1,P7,i4,N3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2903 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2904 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入c0.T1=2;c0.E=2;c0.d8=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleT1=kb.nextDouble();doubleE=kb.nextDouble();doubled8=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2905 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2906 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"e3","b"};例如，本程式的MyMathUtil類別，需改成String[]p0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2907 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的p0物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2908 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:D.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2909 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2910 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2911 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成d4.equals(word)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2912 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]I){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2913 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(V2.equals("貓"))<EOM><BOM>建構子本身不是物件動作函數，因此不能在建構子前面加上void關鍵字，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。例如:publicKeeper(StringI2,Stringq8)<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。以本程式為例，pet物件具有speak動作，因此應該將V2.Speak()改為C9.Speak()。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如:KeeperC9=newKeeper(I2,q8);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringV2,StringU9,StringC0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2914 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2915 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(q.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterg0=(Letter)other;returnd.compareTo(g0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]K4={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:K4)letter.compareTo(letter);for(Letterletter:K4)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2916 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringtitle;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringtitle;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2917 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入i0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2918 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2919 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2920 =====
=====標準答案=====<BOM>按順序應為D2,k,z。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2921 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Y6","b"};例如，本程式的MyMathUtil類別，需改成String[]d0={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2922 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入q5.m0=2;q5.m3=2;q5.w4=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doublem0=kb.nextDouble();doublem3=kb.nextDouble();doublew4=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2923 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=c5.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2924 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringR7,StringV9,StringF0,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2925 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.v1=v1this.D9=D9<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2926 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2927 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerP0=newScanner();intp=P0.nextInt();//讀取數值P0.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2928 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2929 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2930 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2931 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2932 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2933 =====
=====標準答案=====<BOM>按順序應為u8,N1,m。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2934 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2935 =====
=====標準答案=====<BOM>變數名稱重複宣告C5[O3]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:C5[1],Integer.parseInt(C5[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2936 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2937 =====
=====標準答案=====<BOM>Envelop第10行a6.P9在呼叫a6物件中的物件資料時,應呼叫getSender()來回傳returnP9Envelop第11行的a6.B9/a6.l3與上述例子相同<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2938 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:Y4.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2939 =====
=====標準答案=====<BOM>d1變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperH0=newKeeper(...);Petu3=newPet(...,H0);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立d1物件變數的值，例如，publicPet(StringC1,Stringt4,StringM5,Keeperd1){...this.d1=d1;}Pet建構子內已有d1參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petu3=newPet(C1,t4,M5,H0);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2940 =====
=====標準答案=====<BOM>變數名稱d6重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2941 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2942 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2943 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Strings5,StringW,StringU4,StringJ8,StringU7){super(s5,W,U4,J8,U7)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2944 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2945 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式中的Pet類別，需改成Pet(Stringu2,Stringr5,Stringc7){this.u2=u2;this.r5=r5;this.c7=c7;}<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper需要寫在另一個Class。並在Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2946 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(z8,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringw4,Stringo6)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2947 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);E9=scanner.nextInt();P4=scanner.nextInt();w8=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublew1;publicdoubleR9;publicdoublee7;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublew1;publicdoubleR9;publicdoublee7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2948 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2949 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2950 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2951 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的pet類別，需改成z5.equals("貓")，z5.equals("狗")。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2952 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2953 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intB0){B0=3;returnB0;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleS1=X(f0);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2954 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2955 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringR4,Stringl0,Stringa2,StringA1,Stringf8){super(R4,l0,a2,A1,f8)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2956 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2957 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublex8,doubleF8,doublek9)publicstaticdoubleVolume(doublex8,doubleF8,doublek9)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublex8=scanner.nextDouble();System.out.println("輸入寬");doubleF8=scanner.nextDouble();System.out.println("輸入高");doublek9=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.x8=x8;this.F8=F8;this.k9=k9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2958 =====
=====標準答案=====<BOM>按順序應為P9,N7,d。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2959 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2960 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如Y2.equals("狗")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2961 =====
=====標準答案=====<BOM>變數名稱n7重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 2962 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringn0,Stringa,doubley3,doublez){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(n0,a,y3,z);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2963 =====
=====標準答案=====<BOM>按順序應為R,b7,E4。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2964 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=e1,my=V7<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2965 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2966 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2967 =====
=====標準答案=====<BOM>Stringk6={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]k6={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Q1){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2968 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2969 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"E5","b"};例如，本程式的MyMathUtil類別，需改成String[]U6={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2970 =====
=====標準答案=====<BOM>StringC5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]C5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Q6){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2971 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);e=scanner.nextInt();i2=scanner.nextInt();b8=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublej4;publicdoubleP9;publicdoubleM5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublej4;publicdoubleP9;publicdoubleM5;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2972 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2973 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2974 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2975 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.h2=h2this.K7=K7<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2976 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數D3會衝突,導致D3無法傳遞,建議在Class中宣告D3即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intz4=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2977 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入T3.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2978 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2979 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2980 =====
=====標準答案=====<BOM>變數名稱G8重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2981 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2982 =====
=====標準答案=====<BOM>Y9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperY9=newKeeper(...);Peta5=newPet(...,Y9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(e1.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(Stringe1,StringO3,StringS0,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Peta5=newPet(T7,O3,D0,Y9);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2983 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2984 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。此處應呼叫B5中的物件動作來回傳值例:B5.getSender();而不是直接呼叫B5中的物件資料System.out.println("From:"+g+","+B5.getSender());System.out.println("To:"+U7+","+B5.getReceiver()+""+B5.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2985 =====
=====標準答案=====<BOM>W6,p8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperW6=newKeeper(...);Petd7=newPet(...,W6);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringA6,Stringf4,Stringb3,Keeperk){...this.keeper=k;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petd7=newPet(A6,f4,b3,W6);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2986 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2987 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2988 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2989 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2990 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數M2會衝突,導致M2無法傳遞,建議在Class中宣告M2即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intS=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2991 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2992 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2993 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 2994 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2995 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);o0=scanner.nextInt();L6=scanner.nextInt();g0=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoublet4;publicdoublez9;publicdoubleY3;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoublet4;publicdoublez9;publicdoubleY3;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2996 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2997 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 2998 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 2999 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3000 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=j6,my=C<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3001 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3002 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3003 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringu9,Stringp4,doubleE,doublev){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(u9,p4,E,v);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3004 =====
=====標準答案=====<BOM>按順序應為K9,c6,q1。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3005 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringD1,StringC4,StringW8,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3006 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3007 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3008 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式Student類別，publicStringSudent不需要String<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3009 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3010 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3011 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3012 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3013 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3014 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleQ0,doublex6,doubleO6)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3015 =====
=====標準答案=====<BOM>按順序應為u9,T5,z9。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3016 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3017 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3018 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3019 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3020 =====
=====標準答案=====<BOM>Stringv6={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]v6={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]r7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3021 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=f4,my=l4<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3022 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3023 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3024 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationV6=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationV6;V6=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3025 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。因為Envelop擁有Letter的I5物件資料所以在呼叫I5的物件動作的時候應加上System.out.println("From:"+j0+","+I5.getSender());System.out.println("To:"+h5+","+I5.getReceiver()+""+I5.getTitle());<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3026 =====
=====標準答案=====<BOM>Envelope擁有Letter的q8物件資料，Envelope物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。System.out.println("From:"+R3+","+q8.getSender());System.out.println("To:"+e4+","+q8.getReceiver()+""+q8.getTitle());<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3027 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3028 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"Z5","b"};例如，本程式的MyMathUtil類別，需改成String[]J4={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3029 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleJ5,doubleX5,doubleB)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3030 =====
=====標準答案=====<BOM>o7變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keeperd7=newKeeper(...);Petf=newPet(...,d7);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立o7物件變數的值，例如，publicPet(Stringh7,Stringg,Stringe2,Keepero7){...this.o7=o7;}Pet建構子內已有o7參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petf=newPet(h7,g,e2,d7);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3031 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3032 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleA()應回傳一個型態為double的值，所以應加上returnA2;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3033 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:Q7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3034 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3035 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3036 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3037 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3038 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3039 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3040 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3041 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。將程式碼更改為voiddisplay(){System.out.println(I5+""+g2+",您好");System.out.println(S3);System.out.println(E8+"敬上");System.out.println(I3);}<EOM><BOM>因覆寫抽象動作故刪除<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3042 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3043 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]H0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3044 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3045 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3046 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3047 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerU1=newScanner();inte8=U1.nextInt();//讀取數值U1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為C2[V3]，若寫成C2[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3048 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(I1.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterv5=(Letter)other;returnc1.compareTo(v5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]B3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:B3)letter.compareTo(letter);for(Letterletter:B3)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3049 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scanneru2=newScanner();intp=u2.nextInt();//讀取數值u2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3050 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringG1,Stringz2,StringU,StringA2,Stringv6){super(G1,z2,U,A2,v6)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3051 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3052 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3053 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(b4)無法回傳double。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3054 =====
=====標準答案=====<BOM>按順序應為C6,f3,g。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3055 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(a3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterO0=(Letter)other;returnq.compareTo(O0.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]q5={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:q5)letter.compareTo(letter);for(Letterletter:q5)letter.display();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3056 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3057 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnK3;。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3058 =====
=====標準答案=====<BOM>變數名稱重複宣告publicstaticdoubleSurface(doublee6,doublei8,doubleZ5)publicstaticdoubleVolume(doublee6,doublei8,doubleZ5)此兩段程式碼為宣告物件動作後面()內應改為publicstaticdoubleSurface()publicstaticdoubleVolume()括弧內不需重複宣告<EOM><BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"應在main裡使用Scannerscanner=newScanner(System.in);再將其程式碼加在後面System.out.println("輸入長");doublee6=scanner.nextDouble();System.out.println("輸入寬");doublei8=scanner.nextDouble();System.out.println("輸入高");doubleZ5=scanner.nextDouble();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);物件宣告動作內應為this.e6=e6;this.i8=i8;this.Z5=Z5;<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3059 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringo0,Stringu0,StringD8,Stringp4,StringD7){super(o0,u0,D8,p4,D7)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3060 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3061 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3062 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3063 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3064 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3065 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3066 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringb2,StringA0,StringK6,Stringi5,Stringj1){super(b2,A0,K6,i5,j1)}}<EOM>
=====預測答案=====<BOM>變數名稱;<EOM><BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3067 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3068 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3069 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.O6=O6this.n3=n3<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3070 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 3071 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，KeeperH6=newKeeper(Kid,Tell);Petpt=newPet(Pid,Name,Type,H6);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3072 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行o9.B6在呼叫o9物件中的物件資料時,應呼叫getSender()來回傳returnB6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3073 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 3074 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.S2=S2this.Z6=Z6<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3075 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3076 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.5

===== 3077 =====
=====標準答案=====<BOM>變數名稱H3重複宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3078 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(N3,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringo4,StringI3)<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3079 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intn6){n6=3;returnn6;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublez1=X(Q);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3080 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3081 =====
=====標準答案=====<BOM>該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式沒有該類別,請先撰寫該類別,才能產生物件。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]g2){...}main函數已被宣告過,函數名稱不可相同。<EOM><BOM>請注意JAVA程式的語法結構。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3082 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3083 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3084 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]P3={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3085 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(z2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3086 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3087 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Strings3,Stringi4,Strings4,StringB6,Stringg4){super(s3,i4,s4,B6,g4)}}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3088 =====
=====標準答案=====<BOM>當EnglishLetter物件擁有Letter物件時，EnglishLetter物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。publicclassEnglishLetterextendsLetter{@Overridepublicvoiddisplay(){System.out.print("Dear"+getTitle()+getReceiver()+",");System.out.print(getContent());System.out.print("Sincerely");System.out.print(getSender());System.out.print(getDate());}}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3089 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3090 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerN6=newScanner();intk0=N6.nextInt();//讀取數值N6.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為Y[N9]，若寫成Y[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3091 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);L0=scanner.nextInt();o9=scanner.nextInt();E1=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleD8;publicdoublef7;publicdoubleP5;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleD8;publicdoublef7;publicdoubleP5;<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3092 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如，本程式的Word類別，需改成N1.equals(word)。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3093 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，本程式的Pet類別應使用o8.equals("貓")<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}例如，本程式的Pet類別需宣告建構子，如publicPet(){this.A7=A7;...}<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3094 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3095 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3096 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3097 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3098 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intJ8){...returnJ8;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doublek7=X(x3);<EOM>
=====預測答案=====<BOM>正確。<EOM>
Meteor_Score : 0.0

===== 3099 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringY3,Stringm5,StringP8,StringE6,StringI6){super(Y3,m5,P8,E6,I6)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3100 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3101 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3102 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringJ7,b1,z1,D9,E6;Letter(StringJ7,Stringb1,Stringz1,StringD9,StringE6){this.J7=J7;this.b1=b1;this.z1=z1;this.D9=D9;this.E6=E6;}publicStringgetSender(){returnD9;}publicStringgetReceiver(){returnb1;}publicStringgetDate(){returnE6;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3103 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3104 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}本程式缺少建構子的宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3105 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3106 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3107 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3108 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringz8,StringM0,Strings9,Stringa5){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(z8,M0,s9,a5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3109 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(p4.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中m6等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:G.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringm6,Stringk9,Stringp4,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3110 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Strings4;...，此外，ChineseLetter與EnglishLetter就可以刪除Strings4;...<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3111 =====
=====標準答案=====<BOM>使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3112 =====
=====標準答案=====<BOM>ans變數需先宣告後才能使用<EOM><BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。如果呼叫函數需傳遞參數，請先宣告該參數正確的型態並取得正確的值之後，再呼叫函數。例如:inta=1;函數(a);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}含數未宣告,請先宣告該函數.例如:int函數名稱(參數){}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3113 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3114 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]e4){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3115 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3116 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入i1.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3117 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(S2.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettera5=(Letter)other;returnV8.compareTo(a5.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]m3={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:m3)letter.compareTo(letter);for(Letterletter:m3)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3118 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入t3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3119 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3120 =====
=====標準答案=====<BOM>s6變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepers6=newKeeper(...);PetQ8=newPet(...,s6);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(V3.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。Pet(StringV3,StringO1,StringG5,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，PetQ8=newPet(P3,O1,x7,s6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3121 =====
=====標準答案=====<BOM>Stringp9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]p9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]q7){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3122 =====
=====標準答案=====<BOM>JavaDoubleclass的parseDouble（）方法是Java中的一種內置方法，該方法返回一個新的double值，該double值初始化為指定的字符串表示的值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3123 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3124 =====
=====標準答案=====<BOM>變數名稱重複宣告該變數已被宣告,若需更新該變數,只需重新賦予該變數新的資料即可.例如:Stringname="Alex";name="Chris";<EOM><BOM>XX變數需先宣告後才能使用<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3125 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度StringF0="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3126 =====
=====標準答案=====<BOM>變數名稱R2重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3127 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Strings,StringC,StringA1,Stringl2,StringY9){super(s,C,A1,l2,Y9)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Strings,StringC,StringA1,Stringl2,StringY9){super(s,C,A1,l2,Y9)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3128 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]m3={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3129 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如,在本程式中應刪除此段函數在main裡加入以下程式碼KKBoxbox=newKKBox();System.out.println("Volume:"+box.Volume());System.out.println("SurfaceArea:"+box.SurfaceArea());<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。例如應將程式碼改為Scannerscanner=newScanner(System.in);b7=scanner.nextInt();H7=scanner.nextInt();g4=scanner.nextInt();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本段應更改為publicdoubleV1;publicdoubleY2;publicdoublez9;<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如本段應更改為publicdoubleV1;publicdoubleY2;publicdoublez9;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3130 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3131 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3132 =====
=====標準答案=====<BOM>兩個字串間的比較用equals函數較為恰當，如y9.equals("貓")。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3133 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如c8，w3，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。31行少了@Override32行應為EnglishLetterr6=(EnglishLetter)D3;Comparable介面可以實做在Letter類別內所以不需要在ChineseLetter/EnglishLetter類別多編寫compareTo的物件動作abstractpublicclassLetterimplementsComparable因為物件資料都在Letter類別裡而且需要用到comparable介面時做的也只有一個物件動作@OverridepublicintcompareTo(Objectr6){LetterD3=(Letter)r6;returnu3.compareTo(D3.getDate());}先將原本宣告成Object的D3強制轉換成Letter類別型態這樣D3就可以使用跟Letter有關的相關訊息。如:Letter的物件資料、Letter的物件動作因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3134 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3135 =====
=====標準答案=====<BOM>按順序應為p9,V3,l。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3136 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerc3=newScanner();intp=c3.nextInt();//讀取數值c3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3137 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.z6=z6this.o6=o6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3138 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3139 =====
=====標準答案=====<BOM>Z6變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperZ6=newKeeper(...);Petz4=newPet(...,Z6);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(z6.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(StringQ9,StringM5,Stringz6,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petz4=newPet(A3,T6,l3,Z6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3140 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intN5){...returnN5;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleJ3=X(i6);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3141 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returng2;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3142 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3143 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3144 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=L9.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3145 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3146 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3147 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3148 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3149 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3150 =====
=====標準答案=====<BOM>變數需先宣告後才能使用，如變數p和n。<EOM><BOM>有static宣告的是類別資料/動作，物件資料/動作則無static宣告。變數i是物件資料，應刪除static。建構子接受參數設定給物件資料，要注意順序。如x=i;應改成i=x;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3151 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數V8會衝突,導致V8無法傳遞,建議在Class中宣告V8即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intL7=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3152 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3153 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3154 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如f9，g8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3155 =====
=====標準答案=====<BOM>變數名稱N5重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(x7.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3156 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3157 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=q4,my=B2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3158 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3159 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3160 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerM2=newScanner();intp=M2.nextInt();//讀取數值M2.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3161 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>函數可分為回傳與不回傳,不回傳可使用void,回傳需依照需求回傳相對應的資料型態,回傳在最後一步才回傳.example:publicvoid函數名稱(參數){內容...}public回傳型態函數名稱(參數){內容...return回傳變數;}函數回傳值必須在運算結束後再進行回傳<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3162 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3163 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleF8,doublex5,doubleR4)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3164 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3165 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerk4=newScanner();intP3=k4.nextInt();//讀取數值k4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為O9[u5]，若寫成O9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3166 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3167 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3168 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3169 =====
=====標準答案=====<BOM>按順序應為m8,p0,s8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3170 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3171 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3172 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，x4.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3173 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3174 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3175 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intR){...returnR;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleY7=X(m2);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3176 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(A9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Lettera7=(Letter)other;returnm9.compareTo(a7.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]J7={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:J7)letter.compareTo(letter);for(Letterletter:J7)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3177 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=K5,my=K8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3178 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3179 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3180 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3181 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnL6;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3182 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(T1.equals("狗"))<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。此題中z7等物件資料，以及speak()等物件動作，不需要加static宣告。<EOM><BOM>不應該在建構子裡面，呼叫自己來產生物件，而是在其他地方(例如，主程式或其他函式)。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式的display()應該是物件動作，因為每個Pet物件要顯示自己的物件資料。可以將static宣告去除，例如:F6.display();<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringz7,Stringj4,StringT1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3183 =====
=====標準答案=====<BOM>k8變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(g2,I0);透過Keeper建構子，將g2與I0的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringM1,Stringz4,Stringq3,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3184 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3185 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。只需在letter類別使用Comparable即可<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3186 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入L0.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3187 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]y2={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3188 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returnS8;。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3189 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3190 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3191 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringu6,Stringu5,StringJ5,Stringj3,StringT1){super(u6,u5,J5,j3,T1)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringu6,Stringu5,StringJ5,Stringj3,StringT1){super(u6,u5,J5,j3,T1)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3192 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3193 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3194 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3195 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3196 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3197 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(C3),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]E4){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3198 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3199 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3200 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3201 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3202 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=A8,my=b2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3203 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3204 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>注意，抽象類別因可能含有抽象動作，因此JAVA不允許直接從抽象類別產生物件。抽象類別無法直接產生物件，例如:下面指令是錯誤的:EvaluationO9=newEvaluation();但是，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如:EvaluationO9;O9=newExam(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3205 =====
=====標準答案=====<BOM>StringP9={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]P9={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o4){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3206 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入n7.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3207 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3208 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本程式的this.t5=t5;this.y6=y6;this.x7=x7;重複定義只需要returnI3=t5*y6*x7;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3209 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3210 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doubleV7,doublee3,doubleS9)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3211 =====
=====標準答案=====<BOM>按順序應為M,a,Z。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3212 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringj3="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3213 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3214 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(z3.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){Letterg4=(Letter)other;returnm2.compareTo(g4.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]h9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:h9)letter.compareTo(letter);for(Letterletter:h9)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3215 =====
=====標準答案=====<BOM>變數名稱o6重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3216 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(StringW7,Stringz7,doubleu3,doubleI4){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(W7,z7,u3,I4);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3217 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3218 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的a7物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3219 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringR5,Stringv4,StringF2,Stringo6,Stringx5){super(R5,v4,F2,o6,x5)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3220 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3221 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，H7.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3222 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=i1,my=L2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3223 =====
=====標準答案=====<BOM>按順序應為d1,n6,y8。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3224 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，while(f6.equals("0"))<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。是equals不是euqals。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3225 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3226 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3227 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3228 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=o0.nextInt();doubles8=o0.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannero0=newScanner();intd2=o0.nextInt();//讀取數值o0.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3229 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=m5,my=U3<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3230 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3231 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringo1,StringT5,Stringj3,Stringh3,StringI1){super(o1,T5,j3,h3,I1)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringo1,StringT5,Stringj3,Stringh3,StringI1){super(o1,T5,j3,h3,I1)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3232 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]v4={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3233 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3234 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3235 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerA3=newScanner();intp=A3.nextInt();//讀取數值A3.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3236 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3237 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=O7,my=X8<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3238 =====
=====標準答案=====<BOM>按順序應為C7,A3,d5。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3239 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3240 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3241 =====
=====標準答案=====<BOM>變數名稱k8重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3242 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"F1","b"};例如，本程式的MyMathUtil類別，需改成String[]m5={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3243 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3244 =====
=====標準答案=====<BOM>Stringy5={"春秋冬夏"};"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"本程式應改為staticString[]y5={"春","夏","秋","冬"};<EOM><BOM>"所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]Q9){...}"例如,本程式main函式只需寫呼叫函式的程式碼就好ex:publicstaticvoidmain(){season();System.out.println(S);}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3245 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringo0,StringC9,Stringz9,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3246 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=t5.getSender();StringReceiver=t5.getReceiver();StringTitle=t5.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3247 =====
=====標準答案=====<BOM>按順序應為I,t1,A。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3248 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3249 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]l={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3250 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，這裡的Letter類別需要改成publicabstractvoiddisplay();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Letter需要加上Stringa4;...，此外，ChineseLetter與EnglishLetter就可以刪除Stringa4;...<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3251 =====
=====標準答案=====<BOM>B:3~5函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intX3){X3=3;returnX3;}B:10~10函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleE1=X(a6);<EOM><BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}。類別主動作publicstaticvoidmain()內需String[]args。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3252 =====
=====標準答案=====<BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main中加入Petpet=newPet();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式應在main中加入Petpet=newPet();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3253 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringT,Strings4,Stringc9,StringU4,StringN7){super(T,s4,c9,U4,N7)}}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3254 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的x3與englishletter與letter就可刪除StringZ5,...;<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3255 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=S4.nextInt();doubleX7=S4.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerS4=newScanner();intb7=S4.nextInt();//讀取數值S4.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3256 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3257 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫contWord函數須傳遞兩個String型別的參數。例如，contWord(I5,y)<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。以本程式為例，countWord函示應該設為類別函式，才能在主程式直接呼叫。如下例，staticintcountWord(Stringg5,Stringl8)<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3258 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"U4","b"};例如，本程式的MyMathUtil類別，需改成String[]d9={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3259 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。運算不能用陣列，因為陣列無法計算長度Stringn2="999999999";<EOM><BOM>需分辨函數與變數的不同。函數未宣告，若需要使用該函數，請在類別中宣告。例如:int函數名稱(參數){...}<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。函數必須有回傳值，否則要在函數宣告錢加上void回傳值應該在做完函數後再回傳，而非每經過迴圈都回傳<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3260 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3261 =====
=====標準答案=====<BOM>R9變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperR9=newKeeper(...);Petu5=newPet(...,R9);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(c0.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringe5,Stringe8,Stringc0,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petu5=newPet(b5,n2,W7,R9);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3262 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。呼叫類別動作Target.toss(M),代表toss()必須回傳數值故需宣告函數回傳型態再return一個值<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]o6){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3263 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]k3={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3264 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3265 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，本程式Letter類別需要加入T4.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3266 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，speak()當輸入的不是貓也不是狗時，會造成沒有回傳值。<EOM><BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3267 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3268 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。main函式的宣告方法:publicstaticvoidmain(String[]j7){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3269 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]t0={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3270 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。if(this.getDate().compareTo(W9.getDate())<0)這樣會形成不斷呼叫自己本身的函數(compareTo)的無線迴圈且getDate()所回傳的值屬於String不能直接比大小有兩個解決方法1.寫出一個函式把getDate()所回傳的值轉成int2.因為Java的String類別也是有實作Comparable介面也是依照原則return1;return0;return-1如下列:@OverridepublicintcompareTo(Objectother){LetterU3=(Letter)other;returnu2.compareTo(U3.getDate());}<EOM><BOM>將第5~8行修改為先將資料用Letter型態的陣列存取Letter[]j9={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};需要呼叫letter.compareTo()的動作來實現比較大小這樣才有達到依照日期排序的輸出結果for(Letterletter:j9)letter.compareTo(letter);for(Letterletter:j9)letter.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3271 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3272 =====
=====標準答案=====<BOM>變數名稱重複宣告I[V7]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:I[1],Integer.parseInt(I[2])<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3273 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringd1,StringG2,StringU,Stringf3,StringS3){super(d1,G2,U,f3,S3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3274 =====
=====標準答案=====<BOM>"宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={""a"",""b""};"正常的main函式撰寫應為publicstaticvoidmain()陣列宣告應為String[]g0={"春","夏","秋","冬"};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3275 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(StringK7,StringY2,StringW1,Stringk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3276 =====
=====標準答案=====<BOM>"若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值"本段程式的num宣告後沒有使用可加入doublenum=c6.nextDouble();並將System.out.print("Numberis:");改成System.out.print("Numberis:+num");<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3277 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3278 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3279 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringS1,StringE4,Stringu6,Stringv5,StringL3){super(S1,E4,u6,v5,L3)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3280 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。Math.random()是用於隨機產生隨機亂數，應該有變數接收<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3281 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3282 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(y3)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3283 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}應該使用this關鍵字來區分局部變數和物件變數例:this.XXX=XXX<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3284 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3285 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3286 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如n2，q8，...可放到父類別Letter中，並宣告為protected。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3287 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.o=o<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3288 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的Letter類別需要加入main函式main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3289 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如，StringSender=s2.getSender();StringReceiver=s2.getReceiver();StringTitle=s2.getTitle();<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。使用抽象動作的覆寫機制，不需使用旗標方式來判斷以呼叫不同的動作。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3290 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行b3.H2在呼叫b3物件中的物件資料時,應呼叫getSender()來回傳returnH2<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3291 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxb=newKKBOx(l,w,h);呼叫時可用b.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3292 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringf3,StringE7,Stringz7,Stringh8){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如，super(f3,E7,z7,h8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3293 =====
=====標準答案=====<BOM>按順序應為y6,i7,S。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3294 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3295 =====
=====標準答案=====<BOM>e8變數需先宣告後才能使用。Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，Keepere8=newKeeper(...);Petz1=newPet(...,e8);<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，if(y1.equals("狗"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如，publicPet(Stringk6,StringH6,Stringy1,Keeperkeeper){...this.keeper=keeper;}Pet建構子內已有keeper參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petz1=newPet(x6,s9,t4,e8);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3296 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3297 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3298 =====
=====標準答案=====<BOM>陣列初值設定錯誤，會導致陣列內容是空的，應該給於適當的初值。例如，staticintword[]={0,0,0,0,0,0,0,0,0,0};<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3299 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3300 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(p3)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3301 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]U4){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3302 =====
=====標準答案=====<BOM>按順序應為V4,h1,f3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3303 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3304 =====
=====標準答案=====<BOM>a變數需先宣告後才能使用<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3305 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。因為運算必須使用數字，所以應在等於後改為一個數字或將程式改為可輸入r.M0=2;r.T2=2;r.k=2;或是若要讓使用者自己輸入數字，則要用因為要讓使用者輸入數字以計算體積及表面積，所以需要importScanner，並且在主程式的地方新增一個物件importjava.util.Scanner;Scannerkb=newScanner(System.in);呼叫此函數需要給定資料的資料型態(next.Byte(),nextDouble(),nextFloat,nextInt(),nextLine(),nextLong(),nextShot())doubleM0=kb.nextDouble();doubleT2=kb.nextDouble();doublek=kb.nextDouble();<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3306 =====
=====標準答案=====<BOM>物件動作必須在產生物件後才能呼叫。例如:類別物件變數=new類別();物件變數.物件動作(參數...);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3307 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3308 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3309 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3310 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(intlength,intwidth,intheight)。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3311 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3312 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3313 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerD1=newScanner();intC7=D1.nextInt();//讀取數值D1.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為v9[A3]，若寫成v9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3314 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的s2物件。<EOM><BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。新增物件動作-kp.display();<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3315 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3316 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(StringE4,Stringy9,StringO7,Stringw2,Stringa2){super(E4,y9,O7,w2,a2)}}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3317 =====
=====標準答案=====<BOM>所謂類別主動作main()是指類別程式中的類別主程式，本身屬於靜態動作，需要寫在類別裡面，最多只需撰寫一個，且不需要回傳數值。例如，本程式的ChineseLetter類別，main函式的宣告方法:publicstaticvoidmain(String[]args){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3318 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"J8","b"};例如，本程式的MyMathUtil類別，需改成String[]A7={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3319 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.c=cthis.y6=y6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3320 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.l4=l4this.W0=W0<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3321 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3322 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3323 =====
=====標準答案=====<BOM>x變數需先宣告後才能使用。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3324 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3325 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.J6=J6this.x8=x8<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3326 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。A函數本身無須傳遞任何參數，因此在呼叫A函數時，不可將任何值放入參數列中。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3327 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數N1會衝突,導致N1無法傳遞,建議在Class中宣告N1即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intq2=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3328 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。"飼主:"型態為String，Z2.display()型態為void，兩者無法相加。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3329 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。例如本段14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式因後面有呼叫函數應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如本程式應將體積和表面積分開寫成兩個函式並在main中呼叫<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"本程式14,15行呼叫函數volume以及surfaceArea但兩者並不是函數而是一個變數值應改為doublevolume(){returnlength*width*height;}doublesurfaceArea(){returnlength*width+width*height+height*length;}並在main中呼叫KKBoxdata=newKKBox(length,width,height);System.out.println("Thevolumeis"+data.volume());System.out.println("ThesurfaceAreais"+data.surfaceArea());<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3330 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。例如indexof應改為indexOf<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3331 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.K3=K3this.N9=N9<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3332 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3333 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3334 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的getScore(),getRate()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:abstractdoublegetScore();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:h7,D7,R6,m5為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:T6,m5為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:q1,h6為Homework子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:u3,n8為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3335 =====
=====標準答案=====<BOM>按順序應為t2,i7,u1。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3336 =====
=====標準答案=====<BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。例如，L7變數型態為Int，X6變數型態為Int，P3變數型態為Double，但輸入資料皆為String，因此需要轉型。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式缺少抽象動作的宣告:publicabstractvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:u1,j9為Exam子類別的物件資料，不應出現在父類別。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3337 =====
=====標準答案=====<BOM>宣告陣列的方式:資料型態[]變數名稱;資料型態[]變數名稱={...,...,...};例如，int[]x;String[]y={"B0","b"};例如，本程式的MyMathUtil類別，需改成String[]M1={45,89,75,12,45,95,46,21}。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3338 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如,本程式參數doublec,doublej9,doublej應宣告在函數外<EOM><BOM>"建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}"本程式應在main內加入KKBoxbb=KKBox();bb.c=b4;bb.j9=K0;bb.j=J0;<EOM><BOM>"物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。"本程式應在main內加入KKBoxbb=KKBox();bb.c=b4;bb.j9=K0;bb.j=J0;<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);本程式的物件doublec,doublej9,doublej沒被產生<EOM><BOM>"物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。"例如,本段程式應該在main裡呼叫<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3339 =====
=====標準答案=====<BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。輸出時需使用System.out.println()。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3340 =====
=====標準答案=====<BOM>ChineseLetter和EnglishLetter已繼承Letter,子類別的建構子可以使用super函式取得父類別的物件資料publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringi7,Stringt1,Stringi8,Stringl8,StringJ6){super(i7,t1,i8,l8,J6)}}publicclassChineseLetterextendsLetter{publicChineseLetter(Stringi7,Stringt1,Stringi8,Stringl8,StringJ6){super(i7,t1,i8,l8,J6)}}<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3341 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3342 =====
=====標準答案=====<BOM>變數名稱重複宣告a9[z9]的值已被宣告,無法改變該變數型態.需要宣告新變數.例如:a9[1],Integer.parseInt(a9[2])<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3343 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3344 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3345 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3346 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3347 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3348 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，publicabstractclassEvaluation{...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如:本程式中各子類別應該實作其print()函式內容，以覆寫父類別的print()抽象動作。不需要另寫Eprint()，Hprint()，以及Rprint()。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3349 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=J0,my=y7<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3350 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3351 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=k9,my=w0<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3352 =====
=====標準答案=====<BOM>當Envelop物件擁有Letter物件時，Envelop物件可以直接呼叫Letter物件的物件動作去取得該動作回傳值。例如:c6.display();<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3353 =====
=====標準答案=====<BOM>按順序應為I6,C3,M4。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3354 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a,正確。<EOM>
Meteor_Score : 0.0

===== 3355 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerj5=newScanner();intp=j5.nextInt();//讀取數值j5.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3356 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]B9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3357 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerb4=newScanner();intk2=b4.nextInt();//讀取數值b4.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為h9[J9]，若寫成h9[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3358 =====
=====標準答案=====<BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數)]]></Message><Linelist><lineBegin="33"End="33"src="newCustomer0"/><lineBegin="34"End="34"src="newCustomer0"/></Linelist></Error><Errortpye="物件:物件動作概念(建構子)"><Message><![CDATA[建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3359 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如本程式可修改成publicStringgetSender(){returnthis.X3;}publicStringgetTitle(){returnthis.N2;}//可取得q9publicStringgetReceiver(){returnthis.q9;}//可取得N9publicStringgetDate(){returnthis.N9;}abstractvoiddisplay();<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3360 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。<EOM><BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如:privateLetterletter;<EOM><BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。例如:Lettert4=newChineseLetter(...);<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3361 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。不變的物件資料要宣告在Letter的抽象類別裡所以要加入protectedStringC7,B3,S9,C3,X1;Letter(StringC7,StringB3,StringS9,StringC3,StringX1){this.C7=C7;this.B3=B3;this.S9=S9;this.C3=C3;this.X1=X1;}publicStringgetSender(){returnC3;}publicStringgetReceiver(){returnB3;}publicStringgetDate(){returnX1;}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3362 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3363 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerE3=newScanner();intX=E3.nextInt();//讀取數值E3.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為a3[V2]，若寫成a3[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3364 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3365 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Grades類別，publicclassGrades後面要加上extendsEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3366 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>型態相同者才能進行運算，例如:字串與字串、數字與數字。變數的型態與Scanner物件動作所取得的資料型態必須相同,因此，需呼叫Scanner物件的正確函式。例如:intmoney=j7.nextInt();doublex0=j7.nextDouble();<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerj7=newScanner();intB8=j7.nextInt();//讀取數值j7.nextLine();//清除Enter空值Scanner函數庫使用錯誤常用的函數庫有:int:nextInt()String:nextLine()double:nextDouble()<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3367 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3368 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。未importScanner函數庫,println後只能輸出結果,不能接收數值<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3369 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=I9,my=r<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3370 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3371 =====
=====標準答案=====<BOM>按順序應為w1,N0,B5。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3372 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。要顯示物件內的資訊,依照題意要定義ChineseLetter的display()物件動作publicvoiddisplay(){System.out.print(getReceiver()+""+getTitle());...}在主程式中,利用ChineseLetter物件呼叫display()即可。例如:publicstaticvoidmain(String[]h6){a4.display();}<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);<EOM><BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。搞混父類別跟子類別的關係,因為ChineseLetter屬於子類別,需繼承Letter所以原來ChineseLetter所宣告的資料與動作要放到Letter類別<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3373 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]v0){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3374 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。B類別屬於父類別,才能在B類別宣告一個有著A類別建構子的物件並寫在main函式當中例如，publicabstractclassLetter{publicstaticvoidmain(String[]U0){Letterlt;Letterlt=newChineseLetter("...");lt.display();Letterlt=newEnglishLetter("...");lt.display();}}<EOM><BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}<EOM><BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。在Letter宣告抽象動作,讓子類別去做覆寫<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3375 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。應為this.J2=J2this.V4=V4<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3376 =====
=====標準答案=====<BOM>變數名稱o9重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3377 =====
=====標準答案=====<BOM>XX變數需先宣告後才能使用該變數定義後需要初始化,才能做運算.宣告及初始化方法:inta;a=1<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerO7=newScanner();intg8=O7.nextInt();//讀取數值O7.nextLine();//清除Enter空值<EOM><BOM>陣列位置要賦予數值,該數值應為h5[z0]，若寫成h5[變數++]則會先在原本的位置前進一位，再給予數值。這可能導致溢位與陣列數值位置錯誤。<EOM><BOM>當陣列的大小超過陣列賦予最大值，陣列會溢位導致錯誤。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3378 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。此題呼叫X函數須傳遞一個int型別的參數，因此不能傳遞字串。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3379 =====
=====標準答案=====<BOM>n!的算法為:n*(n-1)*(n-2)*(n-3)*(n-4)....*1<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3380 =====
=====標準答案=====<BOM>變數名稱E2重複宣告。<EOM><BOM>字串間的比較應使用equals函數較為恰當。例如，while(c5.equals("0")==false)<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3381 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3382 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。Envelop第10行E9.j5在呼叫E9物件中的物件資料時,應呼叫getSender()來回傳returnj5<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3383 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3384 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如:publicclassEnglishLetterextendsLetter{publicEnglishLetter(Stringt9,Stringy7,StringA1,StringQ4,StringP7){super(t9,y7,A1,Q4,P7)}}<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3385 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3386 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱this.a,<EOM>
Meteor_Score : 0.0

===== 3387 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。在java裡字串的資料型態要大寫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3388 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(m1.equals("dog"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:Pet(StringS4,Stringf9,Stringm1,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3389 =====
=====標準答案=====<BOM>局部變數只在所宣告的函式內被存取或修改，而且需要先有值才能進行運算。Class與main的變數y9會衝突,導致y9無法傳遞,建議在Class中宣告y9即可.<EOM><BOM>型態相同者才能進行運算，例如，在下面的算術運算式中，運算結果是整數型態，因此，r會是0。intk1=5;doubler=5/10;因此，要利用型態強制轉換，將整數轉換成實數再進行運算，如:doubler=(double)5/10;<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3390 =====
=====標準答案=====<BOM>按順序應為O6,K7,T2。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3391 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3392 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3393 =====
=====標準答案=====<BOM>物件資料/動作與類別資料/動作的差別在於有無static宣告。有static宣告的是類別資料/動作，物件資料/動作則無static宣告。類別資料/動作只有一份，且為類別與所有該類別的物件共享，物件資料則是每個物件各有獨立的一份，彼此不相關。本程式因為是類別動作，所以要在類別動作函數前加上static宣告。例如:publicstaticdoublevolume(...){...}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3394 =====
=====標準答案=====<BOM>變數名稱重複宣告本程式需刪除重複宣告的部分<EOM><BOM>"Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。"publicstaticvoidmain(String[]o9){Letter[]list={newChineseLetter("教授","王","很高興跟您連絡","銘哥","2019/01/05"),newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2018/11/01"),newEnglishLetter("Professor","Liu","Iamsorry!","K.Ming","2018/07/05")};Arrays.sort(list);//Letterlt=newEnglishLetter("Professor","Wang","Iamgladtowritetoyou!","J.J.Lin","2019/01/05");//lt.display();for(Letterit:list){it.display();System.out.println("========================");}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3395 =====
=====標準答案=====<BOM>A4變數沒有給予值無法使用。<EOM><BOM>產生物件的語法是，類別名稱物件變數=new類別名稱(參數);例如，下列指令:Keeperk1=newKeeper(B5,A0);透過Keeper建構子，將B5與A0的資料傳遞給物件k1。<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringd8,StringD6,Stringz0,Keeperkeeper){...this.keeper=keeper;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3396 =====
=====標準答案=====<BOM>物件資料需要新增物件後，才會有物件資料。請先宣告物件並給予物件資料。<EOM><BOM>迴圈概念:for(開始位置;結束位置;增減數量){內容...}while(狀態){內容...}請注意若增減的變數或狀態與起始位置變數不同，會導致開始位置變數沒更新，可能導致無窮迴圈。此為無限迴圈，應設定終止條件<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3397 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如本程式應在類別開頭宣告String[]s6={"春","夏","秋","冬"};否則staticStringprint函數將收不到參數值<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3398 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。例如，本程式Evaluation類別，需改成publicabstractclassEvaluation。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3399 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=u6,my=u6<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3400 =====
=====標準答案=====<BOM>函數的宣告架構如下:回傳值型態函數名稱(參數型態參數，...){...}如volume(doublel,doublew,doubleh)<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3401 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式Letter類別的display()動作應隨不同的的子類別(ChineseLetter和EnglishLetter)有不同的變化，因此，在Letter類別須宣告為抽象動作，例如:publicabstractvoiddisplay();而ChineseLetter類別和EnglishLetter類別則分別寫各自的display()函式。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3402 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3403 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3404 =====
=====標準答案=====<BOM>當A物件擁有B物件時，A物件可以直接呼叫B物件的物件動作去取得該動作回傳值。例如可在本程式的publicvoiddisplay()中加入b3.display();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3405 =====
=====標準答案=====<BOM>B:3~5:函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。void函式本身並不會有回傳值，以此例而言，須將void改成double，並且提供一個回傳值。例如，doubleX(intW7){...returnW7;}B:10~10,函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。呼叫X函數須傳遞一個int型別的參數。例如，doubleN=X(j5);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3406 =====
=====標準答案=====<BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3407 =====
=====標準答案=====<BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:Scannerscan=newScanner();intp=scan.nextInt();//讀取數值scan.nextLine();//清除Enter空值例如，本程式PET類別，需加入一行Scannerscanner=newScanner(System.in);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3408 =====
=====標準答案=====<BOM>因為鍵盤只有一個，Scanner物件可以宣告一次即可，不需要針對每一次讀取鍵盤，宣告不同的scanner物件。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3409 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。X(2)無法回傳double。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3410 =====
=====標準答案=====<BOM>引用函數錯誤，應為selflntroduce();。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3411 =====
=====標準答案=====<BOM>請注意JAVA程式的語法結構。mx=q9,my=F8<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3412 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，t3.equals("狗");<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。建立物件之間的關係，要加一行P1P1:<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3413 =====
=====標準答案=====<BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，本程式的Evalution是抽象類別，其建構子如下:publicEvalution(Stringl8,Stringz3,doubleC1,doubleN7){...}因此，子類別呼叫super(...)須注意參數順序與父類別一致，例如:super(l8,z3,C1,N7);<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3414 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。例如，if(type.equals("貓"))<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立keeper物件變數的值，例如:publicPet(Stringb3,Stringu6,Strings3,Keeperk){...this.keeper=k;}<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3415 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2Z6newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3416 =====
=====標準答案=====<BOM>按順序應為A1,j4,d3。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3417 =====
=====標準答案=====<BOM>物件資料/動作是物件所擁有的資料/動作，每個物件有自己的資料/動作，與其他的物件無關。語法上，沒有加上static宣告的，就是物件資料與物件動作。你也可以宣告物件資料與物件動作的存取權限，例如，privateint物件變數;表示物件變數資料只能給該物件本身使用。<EOM><BOM>產生物件的語法是類別名稱物件變數=new類別名稱(參數);例如，KKBOxR5=newKKBOx(l,w,h);呼叫時可用R5.volume();<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3418 =====
=====標準答案=====<BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。例如，可以在本程式的Keeper類別中加入privateKeeperkeeper，並在本程式的Pet類別中加入Keeperkeeper。<EOM>
=====預測答案=====<BOM>a變數名稱<EOM>
Meteor_Score : 0.0

===== 3419 =====
=====標準答案=====<BOM>變數名稱Q8重複宣告。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3420 =====
=====標準答案=====<BOM>抽象類別須加上abstract關鍵字宣告類別。就像一般的父類別，其資料與動作可以由子類別繼承。抽象類別也扮演物件導向多型的重要角色，抽象類別變數可以承接不同的子類別物件，展現不同的行為。例如，本程式的Letter類別需要加上Letterel=newEnglishLetter(...);el.display();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3421 =====
=====標準答案=====<BOM>建構子本身不是物件動作函數，宣告建構子要用跟類別一樣的名字，如需共用，應宣告為public。此外，建構子可將獲得的參數資料，透過this指令賦予給物件或類別資料,如:建構子(參數){...this.物件資料=參數;}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3422 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。例如，doubleX()應回傳一個型態為double的值，所以應加上returny6;。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3423 =====
=====標準答案=====<BOM>抽象動作是抽象類別裡面的物件動作，只宣告函式名稱以及參數列型態，沒有實質的函式內容。實際的函式內容則由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。本程式的print()動作應隨不同的的子類別有不同的變化，因此須宣告為抽象動作，例如:publicabstractvoidprint();<EOM><BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。例如，本程式父類別的print()函式的存取權限層級是public，而子類別print()函式的存取權限層級是default，造成編譯錯誤。應改成:publicvoidprint();<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:id,name,score,prop為Evaluation父類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:range,date為Exam子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:deadline,description為HomeWork子類別的物件資料。共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如:content,literature為Report子類別的物件資料。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3424 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classBextendsA{B(){super();...}例如，本程式的Envelop類別，這裡不需要使用super應該改成this.t0=t0<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3425 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3426 =====
=====標準答案=====<BOM>需分辨函數與變數的不同。因rate1的結果有小數點,故rate1的變數型態是double,但因為in跟out的兩個變數都是int,結果只會是整數,所以需要在運算式前加上(double),才會得到小數點的答案。<EOM><BOM>若需要從鍵盤輸入資料,需先引進Scanner函數庫，如:importjava.util.Scanner;接下來，宣告Scanner物件，並呼叫適當的函數讀取不同型態的資料。如:ScannerB=newScanner();intp=B.nextInt();//讀取數值B.nextLine();//清除Enter空值<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3427 =====
=====標準答案=====<BOM>正確。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3428 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3429 =====
=====標準答案=====<BOM>S3變數需先宣告後才能使用Keeper應擺在Pet前面才能讓Pet有Keeper的資料，例如，KeeperU2=newKeeper(...);Petw1=newPet(...,U2);<EOM><BOM>兩物件之間的關係經常可利用一物件擁有另一物件來實踐。例如，要描述寵物(Pet)與飼主(Keeper)的關係，可以在Pet物件內宣告一個物件資料，類型是Keeper，以表示該Pet物件的Keeper是誰。可利用建構子建立S3物件變數的值，例如，publicPet(Stringx5,Stringq1,StringX7,KeeperS3){...this.S3=S3;}Pet建構子內已有S3參數可以取得Keeper的資料，因此，下列程式可產生擁有Keeper物件的Pet物件，Petw1=newPet(x5,q1,X7,U2);<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3430 =====
=====標準答案=====<BOM>該變數定義後需要初始化,才能做運算宣告及初始化方法:inta;a=1<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3431 =====
=====標準答案=====<BOM>在JAVA，super代表父類別，例如，子類別的建構子可以使用super()函式呼叫父類別的建構子，來建立父類別物件，接著建立本身的物件。例如:classChineseLetterextendsLetter{ChineseLetter(){super();}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3432 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3433 =====
=====標準答案=====<BOM>抽象動作實際的函式內容是由子類別來實踐並加以覆寫，進而完成物件動作的多型功能。注意:子類別函式的存取權限層級不能小於父類別函式的存取權限層級。應覆寫父類別的抽象動作display()。<EOM><BOM>共同的物件資料/動作是可以被子類別繼承的，只需在父類別宣告一次即可。各自不同的物件資料/動作則由各子類別宣告即可。例如，ChineseLetter和EnglishLetter類別的共同資料，如k6，M2，...可放到父類別Letter中，並宣告為protected。<EOM><BOM>Comparable介面是JAVA內建的Interface，允許類別實作intcompareTo(Object)動作，進而協助該類別的物件進行大小或順序的比較。注意，intcompareTo(Object)動作傳回值1，0，-1分別代表物件本身相較於Object參數物件來得大，相等或小。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3434 =====
=====標準答案=====<BOM>為了避免程式和資料的冗餘問題，應該善用繼承的機制。相同的資料或動作可藉由proetced宣告，給子類別繼承使用。應再新增一個類別用來封裝重複的資料，如classA{....}子類別B可用extends來繼承父類別A，例如:classBextendsA{...}<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3435 =====
=====標準答案=====<BOM>變數名稱重複宣告<EOM><BOM>引用函數錯誤，請確認所呼叫的函數或函數庫是否存在。StringTokenizer物件使用錯誤，請先了解StringTokenizer的各種運算函數，再進行呼叫。<EOM><BOM>檢查關鍵字(如public，class，int，String，,...)，標點符號，以及函數名稱是否有誤。class名稱不可使用關鍵字<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3436 =====
=====標準答案=====<BOM>函數必須要宣告回傳值的型態，否則要在函數宣告前加上void。此外，函式邏輯必須完備，避免造成某些狀況無傳回值。再者，呼叫函數時則需要注意傳遞正確型態的參數。<EOM><BOM>在此類別中沒有Exam，若要新增一個物件，要用存在的類別-Exam2b4newExam2();<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

===== 3437 =====
=====標準答案=====<BOM>字串間的比較應使用equals函數較為恰當。JAVA字串比較使用equals函數較為通用。<EOM>
=====預測答案=====<BOM>a變數名稱=.a,<EOM>
Meteor_Score : 0.0

Avg_Meteor_Score : 0.0077
